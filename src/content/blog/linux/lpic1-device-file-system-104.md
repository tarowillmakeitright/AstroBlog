---
author: Taro Gray
pubDatetime: 2025-01-31T08:00:00.000Z
title: デバイス、Linuxファイルシステム、FHS (主題104)編
postSlug: lpic1-device-file-system
featured: true
ogImage: https://github.com/satnaing/astro-paper/assets/53733092/1ef0cf03-8137-4d67-ac81-84a032119e3a
tags:
  - Linux
description: デバイス、Linuxファイルシステム、FHS (主題104)編
---

## `parted` を使用して MBR 形式の新しいハードディスクにパーティションを作成する方法

### **問題**

`parted` を使用して、新しいハードディスクに以下の要件の通りパーティションを作成した。

- **先頭に 1000MB の基本パーティションを作成**
- **ファイルシステムは ext4**
- **パーティションテーブルは MBR 形式**

次のコマンドのうち、**正しくパーティションを作成するために必要なものを選びなさい**。（**全て選択**）

### **選択肢**

1. `mklabel gpt`
2. `print`
3. `mkpart primary ext4 1 1000MB`
4. `mklabel mbr`
5. `mklabel msdos`
6. `create ext4 1 1000MB`
7. `show`
8. `mkpart 1 1000MB`

---

### **正解**

✅ **`mklabel msdos`**  
✅ **`print`**  
✅ **`mkpart primary ext4 1 1000MB`**

---

### **解説**

#### **1. `mklabel msdos`**

- **MBR 形式のパーティションテーブルを作成するコマンド**。
- MBR（Master Boot Record）形式のパーティションテーブルを作成するために必要。
- `msdos` は MBR の別名。

✅ **正解！**

⸻

#### **2. `print`**

- **現在のパーティションテーブルの状態を確認するコマンド**。
- 作成したパーティションが正しく認識されているか確認するために使用。
  ✅ **正解！** ⸻ #### **3. `mkpart primary ext4 1 1000MB`**

- **1000MB の基本（primary）パーティションを作成するコマンド**。
- `mkpart primary <ファイルシステム> <開始位置> <終了位置>` の形式で指定。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mklabel gpt`**

- **GPT（GUID Partition Table）形式のパーティションテーブルを作成するコマンド**。
- 問題では **MBR 形式** のパーティションテーブルを作成するため **不正解**。

⸻

❌ **`create ext4 1 1000MB`**

- **`parted` にこのようなコマンドは存在しない**。
- **パーティションを作成する場合は `mkpart` を使用する**。

⸻

❌ **`mklabel mbr`**

- **`parted` では MBR 形式のパーティションテーブルを作成する場合、`mklabel msdos` を使用する**。
- `mklabel mbr` というコマンドは **存在しない**。

⸻

❌ **`show`**

- **`parted` には `show` というコマンドは存在しない**。
- パーティション情報を確認するには **`print`** を使用する。

⸻

❌ **`mkpart 1 1000MB`**

- `mkpart` コマンドの **書式が間違っている**。
- 正しくは **`mkpart primary ext4 1 1000MB`**。

⸻

### **まとめ**

| コマンド                         | 目的                                               | 正解か |
| -------------------------------- | -------------------------------------------------- | ------ |
| **mklabel msdos**                | **MBR（msdos）形式のパーティションテーブルを作成** | ✅     |
| **print**                        | **パーティションの状態を確認**                     | ✅     |
| **mkpart primary ext4 1 1000MB** | **1000MB の基本パーティションを作成**              | ✅     |
| mklabel gpt                      | GPT（GUID Partition Table）形式を作成              | ❌     |
| create ext4 1 1000MB             | 無効なコマンド                                     | ❌     |
| mklabel mbr                      | 無効なコマンド                                     | ❌     |
| show                             | 無効なコマンド                                     | ❌     |
| mkpart 1 1000MB                  | 書式が間違っている                                 | ❌     |

⸻

💡 **ポイント**

- **MBR 形式を指定するには `mklabel msdos`**
- **パーティション作成は `mkpart primary ext4 1 1000MB`**
- **パーティション確認には `print`**
- **GPT 形式（`mklabel gpt`）は今回のケースでは不適切！**

✅ **「parted で MBR のパーティションを作成するなら `mklabel msdos` → `mkpart primary ext4 1 1000MB` → `print` で確認！」**

## `fdisk -l /dev/sda` の出力からスワップ領域のパーティションを特定する

### **問題**

以下は、コマンド `fdisk -l /dev/sda` の表示結果からの抜粋である。  
**パーティションタイプがスワップ領域のパーティション** はどれか。

### **選択肢**

1. `/dev/sda1`
2. `/dev/sda5`
3. `/dev/sda2`
4. `/dev/sda6`

---

### **正解**

✅ **`/dev/sda6`**

---

### **解説**

`fdisk -l /dev/sda` コマンドは、指定したディスク `/dev/sda` のパーティションテーブルを表示します。各パーティションの詳細情報には、**パーティション番号**、**開始位置**、**終了位置**、**サイズ**、**タイプ**などが含まれます。

**スワップ領域**として使用されるパーティションは、通常、**パーティションタイプが `82`**（`Linux swap`）に設定されています。以下に、`fdisk -l /dev/sda` の出力例を示します。

```
Disk /dev/sda: 100 GB, 100000000000 bytes
255 heads, 63 sectors/track, 12158 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
```

```
Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1        1045     8385861   83  Linux
/dev/sda2            1046        2090     8385862+  83  Linux
/dev/sda3            2091        3135     8385862+  83  Linux
/dev/sda4            3136        3187      418492+   5  Extended
/dev/sda5            3136        3187      418460   82  Linux swap / Solaris
```

上記の例では、`/dev/sda5` のパーティションタイプが `82`（`Linux swap / Solaris`）となっており、**スワップ領域**として使用されることがわかります。

**注意点**：

- **パーティションタイプ `82`** は、**スワップ領域**を示します。
- **パーティションタイプ `83`** は、**Linuxファイルシステム**（`ext4` など）を示します。
- **パーティションタイプ `5`** は、**拡張パーティション**を示します。

したがって、`fdisk -l /dev/sda` の出力を確認し、**パーティションタイプが `82`** に設定されているパーティションを探すことで、**スワップ領域**として使用されているパーティションを特定できます。

---

### **まとめ**

- **スワップ領域のパーティションタイプ**：`82`（`Linux swap`）
- **`fdisk -l` コマンドの出力**を確認し、**パーティションタイプが `82`** のパーティションを探す
- **正解**：`/dev/sda6`（パーティションタイプが `82` の場合）

---

💡 **ポイント**

- **`fdisk -l` コマンド**でディスクのパーティション情報を確認できる
- **スワップ領域**のパーティションタイプは**`82`**
- **パーティションタイプ**を確認して、**スワップ領域**を特定しよう！

✅ **「`fdisk -l` でパーティションタイプ `82` を探せば、スワップ領域がわかる！」**

## `mkfs` または `mke2fs` コマンドで不良ブロックを検査してからファイルシステムを作成する方法

### **問題**

`mkfs` または `mke2fs` コマンドでファイルシステムを作成する際、**不良ブロックがないか検査してから作成** したい。  
適切なオプションを選びなさい。

### **選択肢**

1. `-a`
2. `-k`
3. `-c`
4. `-s`
5. `-e`

---

### **正解**

✅ **`-c`**

---

### **解説**

`mkfs` や `mke2fs` コマンドでファイルシステムを作成する際に、**不良ブロック（bad blocks）を事前に検査するには `-c` オプションを使用** します。

#### **1. `-c` オプションの意味**

- **不良ブロックをチェックしてからファイルシステムを作成**
- **事前に `badblocks` コマンドを実行し、壊れたブロックをマーク**
- 例：
  ```bash
  mkfs.ext4 -c /dev/sdb1
  ```
  または

```
mke2fs -c /dev/sdb1
```

✅ 正解！

⸻

誤った選択肢の解説

❌ -a - mkfs コマンドや mke2fs には -a オプションは 存在しない。- 間違い！

⸻

❌ -k - mke2fs -k は、既存のスーパーブロックを 保持（keep） するオプション。- 不良ブロックのチェックには関係しない。- 間違い！

⸻

❌ -s - mke2fs -s は、スーパーブロックのバックアップ数を設定 するオプション。- 不良ブロックのチェックには関係しない。- 間違い！

⸻

❌ -e - mke2fs -e <オプション> は、不良ブロックが検出された際のエラー処理方法を設定 するオプション。- 不良ブロックを検査するのではなく、検出後の動作を決める。- 間違い！

⸻

まとめ

```

オプション 目的 正解か
-c 不良ブロックを検査してからファイルシステムを作成 ✅
-a 無効なオプション（存在しない） ❌
-k 既存のスーパーブロックを保持する ❌
-s スーパーブロックのバックアップ数を設定 ❌
-e 不良ブロック発生時のエラー処理方法を設定 ❌

```

⸻

💡 ポイント - 不良ブロックをチェックしてから作成するなら -c！- 事前に badblocks を実行するため、安全なディスクセットアップが可能！

✅ 「mkfs.ext4 -c /dev/sdb1 で不良ブロックをチェックしてからフォーマット！」

## `ext2` ファイルシステムを `/dev/hda1` に作成する方法

### **問題**

`ext2` ファイルシステムを **`/dev/hda1`** に作成したい。
適切なコマンドを **全て選択** しなさい。

### **選択肢**

1. `mke2fs /dev/hda1`
2. `mkfs -t ext2 /dev/hda1`
3. `mke2fs -j /dev/hda1`
4. `mkfs /dev/hda1`
5. `mkfs -c ext2 /dev/hda1`

---

### **正解**

✅ **`mkfs -t ext2 /dev/hda1`**
✅ **`mke2fs /dev/hda1`**
✅ **`mkfs /dev/hda1`**

---

### **解説**

#### **1. `mke2fs /dev/hda1`**

- `mke2fs` は **`ext2` ファイルシステムを作成するための専用コマンド**。
- `mke2fs` のデフォルトは **`ext2`** なので、オプションなしで `ext2` ファイルシステムを作成できる。

✅ **正解！**

⸻

#### **2. `mkfs -t ext2 /dev/hda1`**

- `mkfs` は **汎用的なファイルシステム作成コマンド**。
- `-t ext2` を指定することで、`ext2` ファイルシステムを作成できる。

✅ **正解！**

⸻

#### **3. `mkfs /dev/hda1`**

- `mkfs` はデフォルトで `ext2` を作成する場合がある（システムの設定による）。
- `mkfs` の挙動は `mke2fs` に依存するため、**デフォルトが `ext2` なら正しく動作する**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mke2fs -j /dev/hda1`**

- `-j` オプションをつけると **`ext3` ファイルシステムが作成される**。
- **`ext2` ではなく `ext3` になるため不正解！**

⸻

❌ **`mkfs -c ext2 /dev/hda1`**

- `-c` は **不良ブロックのチェックを行うオプション**。
- ただし、正しい書式は **`mkfs -t ext2 -c /dev/hda1`** なので、**書式が誤っている**。

⸻

### **まとめ**

| コマンド                     | 説明                                                    | 正解か |
| ---------------------------- | ------------------------------------------------------- | ------ |
| **`mkfs -t ext2 /dev/hda1`** | **汎用 `mkfs` コマンドで `ext2` を作成**                | ✅     |
| **`mke2fs /dev/hda1`**       | **`ext2` 作成専用のコマンド**                           | ✅     |
| **`mkfs /dev/hda1`**         | **デフォルトで `ext2` を作成する場合がある**            | ✅     |
| `mke2fs -j /dev/hda1`        | `-j` により `ext3` が作成される                         | ❌     |
| `mkfs -c ext2 /dev/hda1`     | `-c` の位置が間違っている（正しくは `mkfs -t ext2 -c`） | ❌     |

⸻

💡 **ポイント**

- **`mke2fs /dev/hda1` は `ext2` 作成の専用コマンド**
- **`mkfs -t ext2 /dev/hda1` も `ext2` を作成可能**
- **`mkfs /dev/hda1` もデフォルトが `ext2` なら動作する**
- **`-j` をつけると `ext3` になるので注意！**

✅ **「`mke2fs /dev/hda1` or `mkfs -t ext2 /dev/hda1` で `ext2` 作成！」**

## exFAT ファイルシステムの特徴

### **問題**

exFAT ファイルシステムの特徴として **正しいものを 2 つ選択** しなさい。

### **選択肢**

1. **4GiB以上の大容量のファイルを扱える**
2. **すべてのLinuxでデフォルトでマウントできる**
3. **FATの後継であり、FATと互換性がある**
4. **フラッシュドライブ向けのファイルシステムである**
5. **扱えるファイルの最大サイズは 4GiB である**

---

### **正解**

✅ **フラッシュドライブ向けのファイルシステムである**
✅ **4GiB以上の大容量のファイルを扱える**

---

### **解説**

#### **1. 4GiB以上の大容量のファイルを扱える**

- exFAT は **FAT32 の後継として開発** され、大容量のファイルを扱えるように設計された。
- **1 ファイルの最大サイズは 16EiB（エクサバイト）**。
- FAT32 では **4GiB を超えるファイルを扱えない** が、exFAT では可能。

✅ **正解！**

⸻

#### **2. フラッシュドライブ向けのファイルシステムである**

- exFAT は **USB メモリや SD カードなどのフラッシュストレージ向け** に最適化されている。
- **ジャーナリング機能を持たず、書き込み回数を減らす** ことで、フラッシュメモリの寿命を延ばす設計になっている。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **すべてのLinuxでデフォルトでマウントできる**

- exFAT は **Microsoft が開発した独自のファイルシステム**。
- 以前は **Linux ではデフォルトでサポートされていなかった**。
- **Linux カーネル 5.4 以降** では **ネイティブサポート** されたが、**古いディストリビューションでは `exfat-utils` パッケージをインストールしないと使えない**。

⸻

❌ **FATの後継であり、FATと互換性がある**

- exFAT は **FAT32 の後継として開発された** が、**FAT32 との直接的な互換性はない**。
- **FAT32 から exFAT に変換するにはフォーマットが必要** で、**そのまま互換性があるわけではない**。

⸻

❌ **扱えるファイルの最大サイズは 4GiB である**

- これは **FAT32 の制限**。
- **exFAT では 4GiB を超えるファイルを扱えるため誤り！**

⸻

### **まとめ**

| 特徴                                               | exFAT の対応                                 | 正解か |
| -------------------------------------------------- | -------------------------------------------- | ------ |
| **4GiB以上の大容量のファイルを扱える**             | **✅（最大 16EiB）**                         | ✅     |
| **すべてのLinuxでデフォルトでマウントできる**      | **❌（古いLinuxでは `exfat-utils` が必要）** | ❌     |
| **FATの後継であり、FATと互換性がある**             | **❌（FAT32 からの直接的な互換性はない）**   | ❌     |
| **フラッシュドライブ向けのファイルシステムである** | **✅（フラッシュメモリの寿命を考慮）**       | ✅     |
| **扱えるファイルの最大サイズは 4GiB である**       | **❌（これは FAT32 の制限）**                | ❌     |

⸻

💡 **ポイント**

- **exFAT は 4GiB を超えるファイルを扱える！**
- **exFAT はフラッシュストレージ向けに最適化！**
- **Linux ではカーネル 5.4 以降で標準サポートされているが、古い環境では追加パッケージが必要！**
- **FAT32 とは直接の互換性はない！**

✅ **「exFAT は 4GiB 超のファイルを扱えて、フラッシュストレージ向け！」**

## MBR形式・GPT形式のパーティションテーブルをサポートするパーティション操作コマンド

### **問題**

**MBR形式・GPT形式のパーティションテーブル** をサポートするパーティション操作コマンドはどれか。

### **選択肢**

1. `mgedit`
2. `parted`
3. `mgdisk`
4. `mgpart`
5. `partedit`

---

### **正解**

✅ **`parted`**

---

### **解説**

#### **1. `parted`**

- **MBR（Master Boot Record）** と **GPT（GUID Partition Table）** の両方をサポートするパーティション操作コマンド。
- **ディスクのパーティションを作成・削除・変更** できる。
- **大容量ディスク（2TB 以上）に対応する GPT をサポート** している。
- **対話モード・コマンドモードの両方で使用可能**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mgedit`**

- **実在しないコマンド**。
- `parted` のようなパーティション操作ツールではない。

⸻

❌ **`mgdisk`**

- `gdisk`（GPT専用のパーティション操作ツール）に似た名前だが、**存在しないコマンド**。

⸻

❌ **`mgpart`**

- **実在しないコマンド**。
- `parted` や `fdisk` とは関係ない。

⸻

❌ **`partedit`**

- **実在しないコマンド**。
- `parted` のようなパーティション管理ツールではない。

⸻

### **まとめ**

| コマンド     | 説明                                               | 正解か |
| ------------ | -------------------------------------------------- | ------ |
| **`parted`** | **MBR/GPT をサポートするパーティション操作ツール** | ✅     |
| `mgedit`     | 存在しないコマンド                                 | ❌     |
| `mgdisk`     | 存在しないコマンド                                 | ❌     |
| `mgpart`     | 存在しないコマンド                                 | ❌     |
| `partedit`   | 存在しないコマンド                                 | ❌     |

⸻

💡 **ポイント**

- **`parted` は MBR / GPT の両方をサポート！**
- **`fdisk` は MBR のみ、`gdisk` は GPT のみ対応**
- **2TB 以上のディスクを扱うなら GPT（parted を使用するのが一般的）**

✅ **「MBR・GPT のパーティションを操作するなら `parted`！」**

## GRUB（GRUB Legacy または GRUB2）のインストール方法

### **問題**

デバイスファイルを指定して、ブートローダの **GRUB（GRUB Legacy または GRUB2）** をインストールしたい。
**3番目のディスク** にインストールする場合のコマンドと、**2番目のディスクの1番目のパーティション** にインストールする場合のコマンドを選びなさい。（**2つ選択**）

### **選択肢**

1. `grub-install /dev/hdc0`
2. `grub-install /dev/sdb`
3. `grub-install /dev/hdc`
4. `grub-install /dev/sdb1`
5. `grub-install /dev/hd3`
6. `grub-install /dev/sdb0`

---

### **正解**

✅ **`grub-install /dev/hdc`**
✅ **`grub-install /dev/sdb1`**

---

### **解説**

#### **1. `grub-install /dev/hdc`（3番目のディスクにインストール）**

- **IDE（PATA）ディスクの場合、`/dev/hdc` は 3 番目のディスク** に相当する。
- GRUB は通常、ディスク全体（MBR または GPT の先頭セクタ）にインストールされるため、**`/dev/hdc` にインストールするのが正しい**。

✅ **正解！**

⸻

#### **2. `grub-install /dev/sdb1`（2番目のディスクの1番目のパーティションにインストール）**

- **`/dev/sdb` は 2 番目のディスク（SATA/SCSI ディスク）を指す**。
- **`/dev/sdb1` は 2 番目のディスクの 1 番目のパーティション** なので、**GRUB を特定のパーティションにインストールしたい場合に適切**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`grub-install /dev/hdc0`**

- **`/dev/hdc0` というデバイス名は存在しない**（IDE の場合 `hdc1` などがパーティション名）。
- **正しくは `/dev/hdc` または `/dev/hdc1`**。

⸻

❌ **`grub-install /dev/sdb`**

- **`/dev/sdb` は 2 番目のディスク全体** を指すため、**MBR や GPT のブートローダをインストールするのには適している**。
- ただし、問題文では「**2番目のディスクの1番目のパーティション**」を求めているため、**不適切**。

⸻

❌ **`grub-install /dev/hd3`**

- **`/dev/hd3` というデバイス名は存在しない**（IDE の場合 `hda`, `hdb`, `hdc`, `hdd` まで）。
- **3番目のディスクは `/dev/hdc`** なので、これは間違い。

⸻

❌ **`grub-install /dev/sdb0`**

- **`/dev/sdb0` というデバイス名は存在しない**。
- **通常、パーティションは `/dev/sdb1`, `/dev/sdb2` のように番号が付く**。

⸻

### **まとめ**

| コマンド                     | 目的                                                     | 正解か |
| ---------------------------- | -------------------------------------------------------- | ------ |
| **`grub-install /dev/hdc`**  | **3番目のディスク（IDE `hdc`）にインストール**           | ✅     |
| **`grub-install /dev/sdb1`** | **2番目のディスクの1番目のパーティションにインストール** | ✅     |
| `grub-install /dev/hdc0`     | 無効なデバイス名（`/dev/hdc1` ならあり得る）             | ❌     |
| `grub-install /dev/sdb`      | 2番目のディスク全体（パーティション指定ではない）        | ❌     |
| `grub-install /dev/hd3`      | 存在しないデバイス名（`/dev/hdc` が正しい）              | ❌     |
| `grub-install /dev/sdb0`     | 存在しないデバイス名（`/dev/sdb1` なら正しい）           | ❌     |

⸻

💡 **ポイント**

- **ディスク全体に GRUB をインストールするなら `/dev/sdX` や `/dev/hdX`**
- **パーティションに GRUB をインストールするなら `/dev/sdX1` のように指定**
- **IDE の 3 番目のディスクは `/dev/hdc`、SATA の 2 番目のディスクは `/dev/sdb`**
- **デバイス名に `0` をつけるのは誤り！（`/dev/sdb0` は存在しない）**

✅ **「GRUB のインストール先を正しく指定しよう！」**

## 論理パーティションを表すデバイスファイル

### **問題**

論理パーティションを表すデバイスファイルは次のうちどれか。（**全て選択**）

### **選択肢**

1. `/dev/sda4`
2. `/dev/sda6`
3. `/dev/sda5`
4. `/dev/sda1`
5. `/dev/sda3`

---

### **正解**

✅ **`/dev/sda5`**
✅ **`/dev/sda6`**

---

### **解説**

Linux では、ディスクのパーティションには **基本パーティション**（プライマリパーティション）と **論理パーティション** があります。

#### **1. パーティションの種類**

- **基本パーティション（プライマリパーティション）**

  - `/dev/sda1` ～ `/dev/sda4` の範囲で作成可能（最大4つ）。
  - 拡張パーティションもこの範囲に含まれる。

- **拡張パーティション**

  - **基本パーティションの1つを拡張パーティションとして設定** し、その中に論理パーティションを作成。
  - `/dev/sda4` が拡張パーティションになることが多い。

- **論理パーティション**
  - **拡張パーティション内に作成されるパーティション**。
  - **デバイスファイルは `/dev/sda5` 以降（`/dev/sda5`, `/dev/sda6`, `/dev/sda7`...）となる**。

⸻

### **各デバイスファイルの確認**

| デバイスファイル | 種類                                                       | 正解か |
| ---------------- | ---------------------------------------------------------- | ------ |
| `/dev/sda1`      | 基本パーティション                                         | ❌     |
| `/dev/sda3`      | 基本パーティション                                         | ❌     |
| `/dev/sda4`      | **通常は拡張パーティション**（論理パーティションではない） | ❌     |
| `/dev/sda5`      | **論理パーティションの最初の番号**                         | ✅     |
| `/dev/sda6`      | **2番目以降の論理パーティション**                          | ✅     |

⸻

### **まとめ**

- **基本パーティション**：`/dev/sda1` ～ `/dev/sda4`
- **論理パーティション**：**`/dev/sda5` 以降**
- **拡張パーティション**（論理パーティションを格納するための枠）：通常 `/dev/sda4`
- **論理パーティションは `/dev/sda5` 以降の番号が割り当てられる！**

⸻

💡 **ポイント**

- **`/dev/sda5` 以降が論理パーティション**
- **`/dev/sda4` は拡張パーティションであることが多い**
- **基本パーティションは `/dev/sda1` ～ `/dev/sda4`**

✅ **「論理パーティションは `/dev/sda5` 以降！」**

## ジャーナリングファイルシステムではないもの

### **問題**

次のうち、**ジャーナリングファイルシステムではないもの** を選びなさい。

### **選択肢**

1. `JFS`
2. `ext4`
3. `ext2`
4. `ext3`
5. `XFS`

---

### **正解**

✅ **`ext2`**

---

### **解説**

#### **ジャーナリングファイルシステムとは？**

ジャーナリングファイルシステムは、**クラッシュや電源断によるデータ破損を防ぐために、変更履歴（ジャーナル）を記録する機能を持つファイルシステム** です。
ファイルの変更が発生すると、**まずジャーナル領域に変更内容を記録してから、実際のデータを書き込む** ため、データの整合性が向上します。

#### **1. `ext2`（ジャーナリングなし）**

- **`ext2` はジャーナリング機能を持たないファイルシステム。**
- シンプルでオーバーヘッドが少ないため、組み込み機器や USB メモリなどに使用されることがある。
- **クラッシュ時の復旧には `fsck`（ファイルシステムチェック）が必要で、時間がかかる。**

✅ **正解！**

⸻

#### **ジャーナリングファイルシステム（誤りの選択肢）**

❌ **`JFS`**（Journaled File System）

- **IBM が開発したジャーナリングファイルシステム。**
- 大規模なストレージ環境向けに設計され、高速なファイル処理が可能。

⸻

❌ **`ext4`**

- **`ext3` の拡張版で、ジャーナリング機能を持つ。**
- 大容量ディスク対応や `extents`（連続ブロック管理）などの改良が加えられている。

⸻

❌ **`ext3`**

- **`ext2` にジャーナリング機能を追加したファイルシステム。**
- クラッシュ時のデータ復旧が速く、Linux で長く使われた。

⸻

❌ **`XFS`**

- **高性能なジャーナリングファイルシステム。**
- **大容量ストレージ向けに最適化されており、並列処理性能が高い。**

⸻

### **まとめ**

| ファイルシステム | ジャーナリング | 特徴                             | 正解か |
| ---------------- | -------------- | -------------------------------- | ------ |
| **`ext2`**       | **なし**       | シンプルでオーバーヘッドが少ない | ✅     |
| `JFS`            | あり           | IBM 開発、大規模ストレージ向け   | ❌     |
| `ext4`           | あり           | `ext3` の改良版、大容量対応      | ❌     |
| `ext3`           | あり           | `ext2` + ジャーナリング機能      | ❌     |
| `XFS`            | あり           | 高速処理、大容量向け             | ❌     |

⸻

💡 **ポイント**

- **`ext2` はジャーナリング機能を持たない唯一の選択肢！**
- **ジャーナリングがないため `fsck`（チェック＆修復）が必要になる。**
- **`ext3` 以降はすべてジャーナリングをサポート！**

✅ **「ジャーナリングなし＝`ext2`！」**

## 次世代のLinux標準ファイルシステム

### **問題**

次世代の **Linux標準ファイルシステム** として開発され、
**ディレクトリの一部をサブボリュームとして個別のファイルシステムのように扱える** ファイルシステムはどれか。

### **選択肢**

1. `ext5`
2. `ZFS`
3. `Btrfs`
4. `XFS`

---

### **正解**

✅ **`Btrfs`**

---

### **解説**

#### **1. `Btrfs`（バターFS）**

- **「B-tree filesystem」** の略で、Linuxの次世代標準ファイルシステムとして開発された。
- **スナップショット、サブボリューム、データ圧縮、自己修復機能などをサポート**。
- **サブボリューム（subvolume）を作成し、個別のファイルシステムのように扱うことが可能**。
- **Red Hat は RHEL 8 以降でサポートを終了したが、openSUSE や Fedora では標準採用されている**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`ext5`**

- **存在しないファイルシステム**。
- `ext4` の次のバージョンとして `ext5` が開発される予定はない。
- **`ext4` は安定しているが、次世代ファイルシステムとしては Btrfs の方が高機能**。

⸻

❌ **`ZFS`**

- **Oracle（旧Sun Microsystems）が開発したファイルシステム**。
- **スナップショットやプール管理などの高機能を持つが、GPL ライセンスとの互換性の問題がある**。
- **Linux カーネルには直接統合されていない**（Ubuntu では公式に ZFS をサポート）。

⸻

❌ **`XFS`**

- **高性能なジャーナリングファイルシステム**。
- **大容量のデータ処理に適しているが、Btrfs のようなスナップショットやサブボリュームの概念はない**。

⸻

### **まとめ**

| ファイルシステム | 特徴                                                       | サブボリューム対応 | 次世代Linux標準 | 正解か |
| ---------------- | ---------------------------------------------------------- | ------------------ | --------------- | ------ |
| **`Btrfs`**      | **スナップショット、サブボリューム、自己修復対応**         | ✅                 | ✅              | ✅     |
| `ext5`           | **存在しない**                                             | ❌                 | ❌              | ❌     |
| `ZFS`            | **スナップショット、プール管理対応（Linux 公式統合なし）** | ✅                 | ❌              | ❌     |
| `XFS`            | **大規模データ向け高性能FS（サブボリュームなし）**         | ❌                 | ❌              | ❌     |

⸻

💡 **ポイント**

- **Btrfs は Linux の次世代標準ファイルシステムとして開発されている！**
- **サブボリューム機能により、一部のディレクトリを独立したファイルシステムのように扱える！**
- **ZFS も高機能だが、ライセンスの問題で Linux に標準統合されていない！**

✅ **「次世代 Linux 標準ファイルシステムは Btrfs！」**

## GPT に存在しない制約

### **問題**

GPT（GUID Partition Table）に **存在しない制約** を **3つ選択** しなさい。

### **選択肢**

1. **起動用システムファームウェア：UEFI**
2. **最大ハードディスク容量：2.2TB（2TiB）**
3. **起動用システムファームウェア：BIOS**
4. **基本パーティション数：128**
5. **最大ハードディスク容量：9.4ZB（8ZiB）**
6. **基本パーティション数：4**

---

### **正解**

✅ **基本パーティション数：4**
✅ **最大ハードディスク容量：2.2TB（2TiB）**
✅ **起動用システムファームウェア：BIOS**

---

### **解説**

#### **GPTとは？**

GPT（GUID Partition Table）は、従来の **MBR（Master Boot Record）** に代わる **次世代のパーティションテーブルフォーマット** です。
MBR の制約を克服し、**大容量ディスクや多数のパーティションをサポート** します。

⸻

### **存在しない制約（正解）**

#### **1. 基本パーティション数：4**

- **MBR では基本パーティションは最大4つまで** だが、GPT では **128個以上のパーティションを作成可能**（UEFI仕様では128個が一般的）。
- **GPT には「基本パーティション」という概念がなく、すべてのパーティションが等しく扱われる**。

✅ **正解！**

⸻

#### **2. 最大ハードディスク容量：2.2TB（2TiB）**

- **MBR では 2.2TB（2TiB）が上限** だったが、GPT では **最大 9.4ZB（8ZiB）まで対応可能**。
- **GPT の 64bit LBA により、非常に大きなディスク容量を扱える**。

✅ **正解！**

⸻

#### **3. 起動用システムファームウェア：BIOS**

- **GPT は UEFI に対応** しているが、**従来の BIOS とは互換性がない**。
- BIOS で GPT ディスクからのブートは **基本的に不可**（特殊な方法を除く）。
- **BIOS でブートする場合は MBR を使用するのが一般的**。

✅ **正解！**

⸻

### **GPT に存在する仕様（誤りの選択肢）**

❌ **起動用システムファームウェア：UEFI**

- **GPT は UEFI に対応** しており、GPT ディスクからの起動には UEFI が必要。
- **正しい仕様なので不正解！**

⸻

❌ **基本パーティション数：128**

- **GPT では UEFI 仕様で最大128個のパーティションを作成可能**。
- **実際の最大数はディスクのサイズと OS に依存**。

⸻

❌ **最大ハードディスク容量：9.4ZB（8ZiB）**

- **GPT の仕様では 64bit LBA により最大 9.4ZB（8ZiB）まで対応**。
- **正しい仕様なので不正解！**

⸻

### **まとめ**

| 制約                                            | MBR                                         | GPT                 | 存在しない制約か |
| ----------------------------------------------- | ------------------------------------------- | ------------------- | ---------------- |
| **基本パーティション数**                        | **最大4つ**（拡張パーティションで増やせる） | **128個以上**       | ✅               |
| **最大ハードディスク容量**                      | **2.2TB（2TiB）**                           | **9.4ZB（8ZiB）**   | ✅               |
| **起動用システムファームウェア**                | **BIOS**                                    | **UEFI**            | ✅               |
| **GPT の基本パーティション数：128**             | ❌（MBR では4つ）                           | ✅（一般的に128個） | ❌               |
| **GPT の最大ハードディスク容量：9.4ZB（8ZiB）** | ❌（MBR は 2.2TB）                          | ✅                  | ❌               |
| **GPT の起動ファームウェア：UEFI**              | ❌（MBR は BIOS）                           | ✅                  | ❌               |

⸻

💡 **ポイント**

- **GPT では 128個以上のパーティションを作成可能（MBR は最大4つ）**
- **GPT のディスクサイズ上限は 9.4ZB（MBR は 2.2TB 制限あり）**
- **GPT は UEFI 対応、BIOS ではブート不可**
- **「MBR の制約 = GPT では解決されている」と考えると分かりやすい！**

✅ **「GPT にない制約は『パーティション数4』『2.2TB上限』『BIOSブート』！」**

## `fdisk` コマンドのサブコマンドとその説明

### **問題**

`fdisk` コマンドの **サブコマンドとその説明の組み合わせとして正しいもの** を **2つ選択** しなさい。

### **選択肢**

1. `m`：パーティションタイプ（システムID）の変更
2. `t`：パーティションタイプ（システムID）の変更
3. `q`：パーティションテーブルの変更を保存して終了
4. `p`：パーティションテーブルの表示
5. `d`：パーティションの作成

---

### **正解**

✅ **`p`：パーティションテーブルの表示**
✅ **`t`：パーティションタイプ（システムID）の変更**

---

### **解説**

#### **1. `p`：パーティションテーブルの表示**

- **現在のパーティション情報を表示するコマンド**。
- **ディスク上のパーティションのリスト、サイズ、ファイルシステムタイプなどを確認可能**。
- 実行例：
  ```bash
  Command (m for help): p
  ```
  - 出力例：

```
Disk /dev/sda: 500GB
Sector size: 512 bytes
Device Boot  Start     End      Blocks   Id  System
/dev/sda1    *        1        1024    102400  83  Linux
```

✅ 正解！

⸻

2. t：パーティションタイプ（システムID）の変更
   - パーティションのファイルシステムタイプ（システムID）を変更するコマンド。
   - 例えば、ext4（ID: 83）から Linux Swap（ID: 82）に変更する際に使用。
   - 実行例：

```
Command (m for help): t
Partition number (1-4): 1
Hex code (type L to list codes): 82
```

- l を押すと、利用可能なパーティションタイプの一覧が表示される。

✅ 正解！

⸻

誤った選択肢の解説

❌ m：パーティションタイプ（システムID）の変更 - m は fdisk のヘルプメニューを表示するコマンド であり、パーティションタイプの変更は t を使用 する。

⸻

❌ q：パーティションテーブルの変更を保存して終了 - q は 変更を保存せずに終了するコマンド。- 変更を保存して終了するには w を使用する。

⸻

❌ d：パーティションの作成 - d は パーティションの削除を行うコマンド であり、作成には n を使用する。

⸻

### まとめ

```
サブコマンド	説明	正解か
p	パーティションテーブルの表示	✅
t	パーティションタイプ（システムID）の変更	✅
m	fdisk のサブコマンド一覧を表示（ヘルプ）	❌
q	変更を保存せずに終了（保存して終了ではない）	❌
d	パーティションを削除（作成ではない）	❌
```

⸻

💡 ポイント - p：現在のパーティション情報を確認 - t：パーティションタイプ（システムID）の変更 - m はヘルプ、q は保存せず終了、d は削除 - パーティションを作成する場合は n を使用

✅ 「p でパーティション情報確認、t でタイプ変更！」

## `parted` を使用してパーティションテーブルの方式を GPT に設定する方法

### **問題**

新しいハードディスクの **パーティションテーブルの方式を GPT に設定** したい。
正しいコマンドを **2つ選択** しなさい。

### **選択肢**

1.  parted /dev/sdb -s mklabel gpt
2.  parted /dev/sdb -t gpt
3.  parted /dev/sdb
    (parted) parttbl gpt
    (parted) q
4.  parted /dev/sdb -s parttbl gpt

5.  parted /dev/sdb
    (parted) gpt
    (parted) q
6.  parted /dev/sdb
    (parted) mklabel gpt
    (parted) q

⸻

### 正解

✅ parted /dev/sdb -s mklabel gpt
✅ parted /dev/sdb → (parted) mklabel gpt → (parted) q

⸻

解説

1.  parted /dev/sdb -s mklabel gpt

- -s オプションは スクリプトモード で実行するためのもので、対話モードなしで mklabel gpt を実行できる。
- 短縮形のコマンドで GPT に設定するのに適切。

✅ 正解！

⸻

2.  parted /dev/sdb → (parted) mklabel gpt → (parted) q

- parted を 対話モード で実行し、手動で mklabel gpt を入力して GPT に設定する方法。
- q を入力することで parted を終了 する。

✅ 正解！

⸻

誤った選択肢の解説

❌ parted /dev/sdb -t gpt - -t オプションは parted には存在しない。- パーティションテーブルの作成には mklabel を使用する必要がある。

⸻

❌ parted /dev/sdb -s parttbl gpt - parttbl というコマンドは 存在しない。- mklabel gpt を使用するのが正しい方法。

⸻

❌ parted /dev/sdb → (parted) parttbl gpt → (parted) q - parttbl というサブコマンドは 存在しない。- mklabel gpt が正しいコマンド。

⸻

❌ # parted /dev/sdb → (parted) gpt → (parted) q - gpt というコマンドは parted には存在しない。- 正しくは mklabel gpt を使う。

⸻

### まとめ

```
コマンド	説明	正解か
 parted /dev/sdb -s mklabel gpt	スクリプトモードで GPT を設定	✅
 parted /dev/sdb → (parted) mklabel gpt → (parted) q	対話モードで GPT を設定	✅
 parted /dev/sdb -t gpt	-t オプションは無効	❌
 parted /dev/sdb -s parttbl gpt	parttbl というコマンドは存在しない	❌
 parted /dev/sdb → (parted) parttbl gpt → (parted) q	parttbl コマンドは存在しない	❌
 parted /dev/sdb → (parted) gpt → (parted) q	gpt というコマンドは存在しない	❌
```

⸻

💡 ポイント - mklabel gpt を使うと GPT のパーティションテーブルを作成できる！- parted -s mklabel gpt なら対話なしで一発設定！- 対話モードで実行するなら parted を開いて mklabel gpt を入力！

✅ 「GPT の設定には mklabel gpt を使おう！」

## GRUB（GRUB Legacy / GRUB2）のインストールコマンドの説明

### **問題**

デバイスファイルを指定して **GRUB（GRUB LegacyまたはGRUB2）** をインストールするコマンドについて、**正しい説明** を **2つ選択** しなさい。

### **選択肢**

1. **`grub-install /dev/sdd`** は、4番目のディスクにインストールする
2. **`grub-install /dev/hdd0`** は、1番目のパーティションにインストールする
3. **`grub-install /dev/sdd`** は、1番目のパーティションにインストールする
4. **`grub-install /dev/hdd2`** は、2番目のパーティションにインストールする

---

### **正解**

✅ **`grub-install /dev/sdd` は、4番目のディスクにインストールする**
✅ **`grub-install /dev/hdd2` は、2番目のパーティションにインストールする**

---

### **解説**

#### **1. `grub-install /dev/sdd` は、4番目のディスクにインストールする**

- **SATA（SCSI）デバイスの場合**、Linux では `/dev/sda` が **1番目のディスク**、`/dev/sdb` が **2番目のディスク**...と続く。
- **`/dev/sdd` は 4 番目のディスクを指す**。
- **パーティション指定がない場合はディスク全体の MBR / GPT に GRUB をインストールする**。

✅ **正解！**

⸻

#### **2. `grub-install /dev/hdd2` は、2番目のパーティションにインストールする**

- **IDE（PATA）デバイスの場合**、Linux では `/dev/hda` が **1番目のディスク**、`/dev/hdb` が **2番目のディスク**...と続く。
- **`/dev/hdd` は 4 番目のディスク** なので、`/dev/hdd2` は **4番目のディスクの2番目のパーティション** を指す。
- **GRUB を MBR ではなく特定のパーティションにインストールする場合は、`grub-install /dev/hdd2` のようにパーティションを指定する**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`grub-install /dev/hdd0` は、1番目のパーティションにインストールする**

- **誤り！**
- **Linux では `hdd0` というデバイスファイルは存在しない**。
- **1番目のパーティションは `/dev/hdd1` になるため、`/dev/hdd0` は無効**。

⸻

❌ **`grub-install /dev/sdd` は、1番目のパーティションにインストールする**

- **誤り！**
- **パーティション指定がない場合、GRUB はディスク全体（MBR または GPT）にインストールされる**。
- **1番目のパーティションなら `/dev/sdd1` を指定する必要がある**。

⸻

### **まとめ**

| コマンド                                         | 説明                                                     | 正解か |
| ------------------------------------------------ | -------------------------------------------------------- | ------ |
| **`grub-install /dev/sdd`**                      | **4番目のディスク全体にインストール**                    | ✅     |
| **`grub-install /dev/hdd2`**                     | **4番目のディスクの2番目のパーティションにインストール** | ✅     |
| `grub-install /dev/hdd0`                         | **無効なデバイス名（`/dev/hdd1` が正しい）**             | ❌     |
| `grub-install /dev/sdd`（1番目のパーティション） | **ディスク全体にインストールされるため誤り**             | ❌     |

⸻

💡 **ポイント**

- **`/dev/sda`, `/dev/sdb`, `/dev/sdc`, `/dev/sdd`... はそれぞれ1番目、2番目、3番目、4番目のディスク**
- **GRUB をディスク全体（MBR / GPT）にインストールする場合は `/dev/sdX`**
- **特定のパーティションにインストールする場合は `/dev/sdX1` のように指定**
- **`/dev/hdd2` は IDE の4番目のディスクの2番目のパーティション**

✅ **「GRUB のインストール先を正しく指定しよう！」**

## inode の数が制限されるファイルシステム

### **問題**

inode の数が制限されるファイルシステムは次のうちどれか。（**全て選択**）

### **選択肢**

1. `ext2`
2. `ext4`
3. `XFS`
4. `ext3`
5. `JFS`

---

### **正解**

✅ **`ext2`**
✅ **`ext3`**
✅ **`ext4`**

---

### **解説**

#### **inode とは？**

- **inode（インノード）** は、ファイルのメタデータ（所有者、パーミッション、サイズ、格納場所 など）を管理するデータ構造。
- **Linux の `ext` 系ファイルシステムでは、ファイルシステム作成時に inode の総数が決まるため、後から増やすことはできない**。

⸻

#### **1. `ext2`, `ext3`, `ext4`（inode 数の制限あり）**

- **`ext2`、`ext3`、`ext4` は、ファイルシステム作成時に inode 数が決まる**。
- そのため、**inode を使い切ると、ディスクの空き容量があっても新しいファイルを作成できない**。
- `ext4` では **inode サイズの柔軟な設定** や **拡張機能** が追加されたが、基本的な制限は変わらない。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`XFS`（inode 数の制限なし）**

- **`XFS` は動的 inode を採用** しているため、必要に応じて inode を増やせる。
- **ファイルシステム作成時に inode 数を事前に決める必要がない**。

⸻

❌ **`JFS`（inode 数の制限なし）**

- **`JFS` も動的 inode を採用** しており、`ext` 系のような inode 数の制限はない。

⸻

### **まとめ**

| ファイルシステム | inode 数の制限 | 説明                                   | 正解か |
| ---------------- | -------------- | -------------------------------------- | ------ |
| **`ext2`**       | **あり**       | 作成時に inode 数が固定                | ✅     |
| **`ext3`**       | **あり**       | `ext2` にジャーナリングを追加          | ✅     |
| **`ext4`**       | **あり**       | `ext3` の改良版だが inode 数の制限あり | ✅     |
| `XFS`            | なし           | 動的 inode を採用                      | ❌     |
| `JFS`            | なし           | 動的 inode を採用                      | ❌     |

⸻

💡 **ポイント**

- **`ext2`、`ext3`、`ext4` は inode の数が固定で、後から増やせない！**
- **`XFS` や `JFS` は動的 inode なので、inode 数の制限なし！**
- **inode 数が足りなくなると、ディスクの空き容量があってもファイルが作成できなくなる！**

✅ **「inode の数が制限されるのは `ext2` `ext3` `ext4`！」**

## MBR 方式のハードディスクに作成できる基本パーティションの最大数

### **問題**

MBR（Master Boot Record）方式のハードディスクに **基本パーティションは最大何個作成できるか**。

### **選択肢**

1. **4**
2. **7**
3. **6**
4. **5**
5. **無限**

---

### **正解**

✅ **4**

---

### **解説**

#### **MBR（Master Boot Record）とは**

MBR（Master Boot Record）は、**従来のパーティション管理方式** であり、
ディスクの先頭に **パーティション情報** を格納する **パーティションテーブル** を持っています。

⸻

#### **1. MBR で作成可能な基本パーティションの最大数**

- **MBR のパーティションテーブルには最大 4 つのエントリしか存在しない**。
- そのため、**基本パーティション（プライマリパーティション）は最大 4 つまでしか作成できない**。

✅ **正解！**

⸻

#### **2. 拡張パーティションと論理パーティション**

- **MBR では 4 つ以上のパーティションを作成したい場合、拡張パーティションを利用する**。
- **基本パーティション 4 つのうち 1 つを拡張パーティションにすると、その中に無制限に論理パーティションを作成できる**。
- **論理パーティションは `/dev/sda5` 以降の番号で作成される**（`/dev/sda1` ～ `/dev/sda4` は基本パーティション）。

⸻

### **誤った選択肢の解説**

❌ **7 / 6 / 5**

- **MBR では基本パーティションは最大 4 つまでしか作成できない**。
- 5 個以上作成したい場合は、**1 つを拡張パーティションにし、その中に論理パーティションを作成する必要がある**。

⸻

❌ **無限**

- **MBR では基本パーティションは 4 つまでという制限があるため無限には作成できない**。
- GPT（GUID Partition Table）を使用すれば、**128個以上のパーティションを作成できる**。

⸻

### **まとめ**

| パーティションの種類           | MBR                                          | GPT                             |
| ------------------------------ | -------------------------------------------- | ------------------------------- |
| **基本パーティションの最大数** | **4 つ**                                     | **制限なし（一般的に 128 個）** |
| **拡張パーティションの数**     | **1 つ**（基本パーティションとしてカウント） | **不要**                        |
| **論理パーティションの数**     | **無制限（拡張パーティション内）**           | **不要**                        |

⸻

💡 **ポイント**

- **MBR では基本パーティションは最大 4 つ！**
- **5 個以上のパーティションを作成するには、拡張パーティションを作り、その中に論理パーティションを作成する**
- **制限なしで多くのパーティションを作りたいなら GPT を使う**

✅ **「MBR では基本パーティションは 4 つまで！」**

## `fdisk` コマンドで作成したパーティションにファイルシステムを作成するコマンド

### **問題**

`fdisk` コマンドで作成したパーティションに **ファイルシステムを作成** できるコマンドを **2つ選択** しなさい。

### **選択肢**

1. `mkfdisk`
2. `mkfs`
3. `mke2fs`
4. `mk2fs`
5. `make2fs`

---

### **正解**

✅ **`mkfs`**
✅ **`mke2fs`**

---

### **解説**

#### **1. `mkfs`（汎用的なファイルシステム作成コマンド）**

- **`mkfs`（Make File System）は、任意のファイルシステムを作成できる汎用コマンド**。
- `-t` オプションを使って **ファイルシステムの種類を指定可能**。
- 例（`ext4` ファイルシステムを作成）：
  ```bash
  mkfs -t ext4 /dev/sda1
  ```
  - mkfs.ext4 や mkfs.xfs など、特定のファイルシステム向けのバージョンもある。

✅ 正解！

⸻

2. mke2fs（ext 系ファイルシステム専用コマンド）
   - mke2fs は ext2、ext3、ext4 ファイルシステムを作成できる専用コマンド。
   - -t オプションを指定することで、ext2 以外も作成可能。
   - 例（ext4 ファイルシステムを作成）：

```
mke2fs -t ext4 /dev/sda1

```

- 例（ext3 ファイルシステムを作成）：

```
mke2fs -j /dev/sda1

```

✅ 正解！

⸻

誤った選択肢の解説

❌ mkfdisk - 存在しないコマンド。- パーティションを作成する fdisk とは無関係。

⸻

❌ mk2fs - 存在しないコマンド。- 正しくは mke2fs。

⸻

❌ make2fs - 存在しないコマンド。- 正しくは mke2fs。

⸻

### まとめ

```
コマンド 説明 正解か
mkfs 汎用的なファイルシステム作成コマンド ✅
mke2fs ext2/ext3/ext4 専用のファイルシステム作成コマンド ✅
mkfdisk 存在しないコマンド ❌
mk2fs 存在しないコマンド ❌
make2fs 存在しないコマンド ❌

```

⸻

💡 ポイント - mkfs は汎用的なファイルシステム作成コマンド - mke2fs は ext2 / ext3 / ext4 用のファイルシステム作成コマンド - mkfdisk や make2fs などは存在しない！

✅ 「パーティションにファイルシステムを作成するなら mkfs または mke2fs！」

## MBR 形式のハードディスクにおけるパーティションタイプの組み合わせ

### **問題**

MBR 形式のハードディスクにおける **パーティションタイプの組み合わせとして正しいもの** はどれか。

### **選択肢**

1. **`e0`：空**
2. **`82`：Linux swap**
3. **`0`：Linux LVM**
4. **`83`：FAT**
5. **`8e`：Linux**

---

### **正解**

✅ **`82`：Linux swap**

---

### **解説**

MBR（Master Boot Record）では、**各パーティションに対して「パーティションタイプ ID（16進数）」が割り当てられる**。
この ID により、OS はパーティションの種類を判別します。

⸻

#### **1. `82`：Linux swap（正解）**

- **Linux のスワップ領域を表すパーティションタイプ**。
- スワップ領域は、**物理メモリ（RAM）が不足したときに仮想メモリとして使用される**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`e0`：空**

- **`e0` というパーティションタイプは存在しない**。
- **未使用の領域（未割り当てパーティション）には特定のパーティションタイプは設定されない**。

⸻

❌ **`0`：Linux LVM**

- **`0` は「未使用」のパーティションタイプ ID であり、LVM とは無関係**。
- **Linux LVM（Logical Volume Manager）の ID は `8e`**。

⸻

❌ **`83`：FAT**

- **`83` は「Linux ファイルシステム（ext2/ext3/ext4 など）」を表す ID**。
- **FAT のパーティションタイプ ID は `0b`（FAT32）、`0c`（FAT32（LBA））など**。

⸻

❌ **`8e`：Linux**

- **`8e` は「Linux LVM（Logical Volume Manager）」の ID** であり、**通常の Linux ファイルシステムを指すわけではない**。
- **Linux の標準的なファイルシステム（ext2/ext3/ext4 など）の ID は `83`**。

⸻

### **正しいパーティションタイプ ID 一覧（MBR）**

| パーティションタイプ ID | 説明                                    |
| ----------------------- | --------------------------------------- |
| **`82`**                | **Linux swap**                          |
| **`83`**                | **Linux（ext2/ext3/ext4 など）**        |
| **`8e`**                | **Linux LVM（Logical Volume Manager）** |
| **`0b`**                | **FAT32**                               |
| **`0c`**                | **FAT32（LBA）**                        |
| **`07`**                | **NTFS/exFAT**                          |
| **`05`**                | **拡張パーティション**                  |

⸻

### **まとめ**

| 選択肢               | 正しいパーティションタイプか | 説明                                           |
| -------------------- | ---------------------------- | ---------------------------------------------- |
| **`82`：Linux swap** | ✅                           | **スワップ領域を表す**                         |
| `e0`：空             | ❌                           | **存在しないパーティションタイプ ID**          |
| `0`：Linux LVM       | ❌                           | **`0` は未使用、LVM は `8e`**                  |
| `83`：FAT            | ❌                           | **`83` は Linux（FAT ではない）**              |
| `8e`：Linux          | ❌                           | **`8e` は Linux LVM（通常の Linux ではない）** |

⸻

💡 **ポイント**

- **`82` は Linux swap！**
- **Linux の標準的なファイルシステム（ext2/ext3/ext4 など）は `83`！**
- **Linux LVM は `8e`！**
- **FAT32 は `0b` または `0c`！**

✅ **「Linux swap のパーティションタイプは `82`！」**

## `fdisk` コマンドのサブコマンドとその説明の間違い

### **問題**

次の `fdisk` コマンドのサブコマンドとその説明の組み合わせのうち、**間違っているもの** はどれか。

### **選択肢**

1. **`n`：パーティションの作成**
2. **`t`：パーティションテーブルの表示**
3. **`q`：パーティションテーブルの変更を保存せずに終了**
4. **`d`：パーティションの削除**
5. **`w`：パーティションテーブルの変更を保存して終了**

---

### **正解**

✅ **`t`：パーティションテーブルの表示（間違い）**

---

### **解説**

#### **1. `t`：パーティションテーブルの表示（間違い）**

- **`t` はパーティションのファイルシステムタイプ（システム ID）を変更するコマンド**。
- **パーティションテーブルを表示するコマンドではない！**
- **パーティションテーブルの表示には `p` を使用する**。

❌ **誤り！**

⸻

### **正しい選択肢の解説**

✅ **`n`：パーティションの作成**

- **新しいパーティションを作成するコマンド**。
- `fdisk` 内で **`n` を入力し、パーティションの種類（基本 or 拡張）やサイズを指定** する。

✅ **正しい！**

⸻

✅ **`q`：パーティションテーブルの変更を保存せずに終了**

- **変更を破棄し、`fdisk` を終了するコマンド**。
- **パーティションの変更を保存せずに抜けたい場合に使用**。

✅ **正しい！**

⸻

✅ **`d`：パーティションの削除**

- **指定したパーティションを削除するコマンド**。
- **削除を確定するには `w`（保存）を実行する必要がある**。

✅ **正しい！**

⸻

✅ **`w`：パーティションテーブルの変更を保存して終了**

- **変更をディスクに書き込み（保存し）、`fdisk` を終了するコマンド**。
- **この操作を行うと、変更が確定し、取り消せなくなるので注意！**

✅ **正しい！**

⸻

### **まとめ**

| サブコマンド | 説明                                                                   | 正しいか |
| ------------ | ---------------------------------------------------------------------- | -------- |
| **`n`**      | **パーティションの作成**                                               | ✅       |
| **`t`**      | **パーティションのファイルシステムタイプ（ID）の変更**（表示ではない） | ❌       |
| **`q`**      | **変更を保存せずに終了**                                               | ✅       |
| **`d`**      | **パーティションの削除**                                               | ✅       |
| **`w`**      | **パーティションテーブルの変更を保存して終了**                         | ✅       |

⸻

💡 **ポイント**

- **パーティションテーブルの表示は `p`！**
- **`t` はパーティションのタイプ（システム ID）を変更するコマンド！**
- **変更を保存せずに終了するなら `q`、保存して終了するなら `w`！**

✅ **「`t` はパーティションタイプ変更！パーティションテーブルの表示は `p`！」**

## MBR 方式のハードディスク `/dev/sda` のパーティションテーブルを確認する方法

### **問題**

MBR 方式のハードディスク **`/dev/sda`** のパーティションテーブルを確認したい。
適切なコマンドを選びなさい。

### **選択肢**

1. **`fdisk --table /dev/sda`**
2. **`fdisk -p /dev/sda`**
3. **`fdisk -l /dev/sda`**
4. **`fdisk -t /dev/sda`**
5. **`fdisk --library /dev/sda`**

---

### **正解**

✅ **`fdisk -l /dev/sda`**

---

### **解説**

#### **1. `fdisk -l /dev/sda`（正解）**

- `fdisk -l` は **指定したデバイスのパーティションテーブルを一覧表示するコマンド**。
- MBR のパーティション情報を確認する際に使用される。
- 実行例：
  ```bash
  sudo fdisk -l /dev/sda
  ```
  - 出力例：

```
Disk /dev/sda: 500GB
Sector size: 512 bytes
Device      Boot Start    End      Blocks   Id  System
/dev/sda1   *     2048    4096     102400   83  Linux
```

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk --table /dev/sda - --table というオプションは存在しない。

⸻

❌ fdisk -p /dev/sda - -p というオプションは fdisk には存在しない。- パーティション情報を表示するなら -l を使用する。

⸻

❌ fdisk -t /dev/sda - -t は fdisk には存在しないオプション（mkfs -t のような形式でファイルシステムを指定するコマンドには存在）。

⸻

❌ fdisk --library /dev/sda - --library というオプションは fdisk には存在しない。

⸻

### まとめ

```
コマンド	説明	正解か
fdisk -l /dev/sda	パーティションテーブルを一覧表示	✅
fdisk --table /dev/sda	無効なオプション	❌
fdisk -p /dev/sda	無効なオプション	❌
fdisk -t /dev/sda	無効なオプション	❌
fdisk --library /dev/sda	無効なオプション	❌
```

⸻

💡 ポイント - fdisk -l /dev/sda で MBR のパーティションテーブルを表示 - -l は「list」の意味 - 無効なオプション（--table -p -t --library）に注意！

✅ 「MBR のパーティションを確認するなら fdisk -l /dev/sda！」

## GPT 形式のハードディスクでパーティションの作成・削除・変更・情報表示を行うコマンド

### **問題**

GPT 形式のハードディスクにおいて、**パーティションの作成、削除、変更、および情報表示** を行うことができるコマンドはどれか。

### **選択肢**

1. **`fdisk`**
2. **`gptedit`**
3. **`gdisk`**
4. **`partition`**
5. **`gptdisk`**

---

### **正解**

✅ **`gdisk`**

---

### **解説**

#### **1. `gdisk`（正解）**

- **GPT（GUID Partition Table）専用のパーティション操作ツール**。
- `fdisk` の **GPT 版** であり、**MBR ではなく GPT を扱うために設計されたコマンド**。
- **パーティションの作成、削除、変更、表示** などが可能。
- 実行例：

  ```bash
  sudo gdisk /dev/sda
  ```

  - 対話モードでパーティション操作を実行可能。

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk - fdisk は MBR（Master Boot Record）専用 のコマンド。- GPT には対応していない（fdisk で GPT ディスクを扱うと、警告が出ることがある）。

⸻

❌ gptedit - 実在しないコマンド。

⸻

❌ partition - Linux にこの名前のパーティション管理コマンドは存在しない。

⸻

❌ gptdisk - 実在しないコマンド。- GPT を操作するには gdisk を使用する。

⸻

### まとめ

```
コマンド 説明 正解か
gdisk GPT 形式のパーティションを作成・削除・変更・表示するコマンド ✅
fdisk MBR 専用のパーティション管理ツール（GPT には非対応） ❌
gptedit 実在しないコマンド ❌
partition 実在しないコマンド ❌
gptdisk 実在しないコマンド ❌
```

⸻

💡 ポイント - GPT のパーティション管理には gdisk を使用する！- fdisk は MBR 専用であり、GPT には適用できない！- gptedit partition gptdisk などのコマンドは存在しない！

✅ 「GPT のパーティションを管理するなら gdisk！」

## MBR 形式のハードディスク `/dev/sda` のパーティションを操作するコマンド

### **問題**

MBR 形式のハードディスク **`/dev/sda`** の **パーティションを操作** したい。
適切なコマンドを選びなさい。

### **選択肢**

1. **`fdisk -l /dev/sda`**
2. **`fdisk -n /dev/sda`**
3. **`fdisk -c /dev/sda`**
4. **`fdisk /dev/sda`**
5. **`fdisk -p /dev/sda`**

---

### **正解**

✅ **`fdisk /dev/sda`**

---

### **解説**

#### **1. `fdisk /dev/sda`（正解）**

- **MBR 形式のパーティションを作成・削除・変更するための対話モードを開始するコマンド**。
- `fdisk` を実行すると、`Command (m for help):` のプロンプトが表示され、**対話モードでパーティションを操作できる**。
- 実行例：
  ```bash
  sudo fdisk /dev/sda
  ```
  - このモードで n（パーティション作成）、d（削除）、w（変更を保存） などのサブコマンドを使用可能。

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk -l /dev/sda - -l はパーティションテーブルを一覧表示するだけで、操作はできない。- パーティション情報の確認には便利だが、作成・削除・変更はできない。

⸻

❌ fdisk -n /dev/sda - -n というオプションは fdisk には存在しない。- パーティションを作成する場合は、fdisk の対話モードで n を入力する。

⸻

❌ fdisk -c /dev/sda - -c は古いバージョンの fdisk で互換モードを変更するオプション（現在はほぼ不要）。- パーティションの作成・削除・変更はできない。

⸻

❌ fdisk -p /dev/sda - -p というオプションは fdisk には存在しない。- パーティション情報を表示するなら fdisk -l を使用する。

⸻

### まとめ

```
コマンド	説明	正解か
fdisk /dev/sda	MBR 形式のパーティションを作成・削除・変更するための対話モードを開始	✅
fdisk -l /dev/sda	パーティションテーブルを表示する（操作は不可）	❌
fdisk -n /dev/sda	無効なオプション（存在しない）	❌
fdisk -c /dev/sda	互換モードを変更するオプション（パーティション操作は不可）	❌
fdisk -p /dev/sda	無効なオプション（存在しない）	❌
```

⸻

💡 ポイント - パーティションの作成・削除・変更を行うには fdisk /dev/sda を使う！- パーティションテーブルの表示だけなら fdisk -l /dev/sda！- -n や -p のようなオプションは存在しない！

✅ 「MBR のパーティションを操作するなら fdisk /dev/sda！」

## Btrfs ファイルシステムの特徴

### **問題**

Btrfs ファイルシステムの特徴として **正しいものを 2 つ選択** しなさい。

### **選択肢**

1. **ファイルの圧縮はサポートしていない**
2. **マルチデバイスに対応している**
3. **inode の数が制限される**
4. **ext3 の後継である**
5. **サブボリューム単位でのスナップショット機能がある**

---

### **正解**

✅ **マルチデバイスに対応している**
✅ **サブボリューム単位でのスナップショット機能がある**

---

### **解説**

#### **1. マルチデバイスに対応している（正解）**

- **Btrfs は複数のデバイスを 1 つのストレージプールとして管理できる**。
- **RAID 機能（RAID 0, 1, 10, 5, 6）を内蔵し、複数のストレージデバイスを統合可能**。
- 例：
  ```bash
  mkfs.btrfs -m raid1 -d raid1 /dev/sdb /dev/sdc
  ```
  - マルチデバイス管理機能が組み込まれているため、LVM を使わなくてもストレージ管理が柔軟にできる。

✅ 正解！

⸻

2. サブボリューム単位でのスナップショット機能がある（正解）
   - Btrfs は「サブボリューム」機能を持ち、これを単位としてスナップショットを作成できる。
   - サブボリュームごとにデータのスナップショットを取ることができるため、バックアップやシステムの復元に便利。
   - 例：

btrfs subvolume snapshot /mnt/data /mnt/snapshots/data-20240317

    -	スナップショットは差分で保存されるため、ディスク使用量が最小限に抑えられる。

✅ 正解！

⸻

誤った選択肢の解説

❌ ファイルの圧縮はサポートしていない - Btrfs はファイルの圧縮（zlib、lzo、zstd）をサポートしている。- 圧縮を有効にする例：

mount -o compress=zstd /dev/sda1 /mnt

    -	「ファイルの圧縮はサポートしていない」は誤り！

⸻

❌ inode の数が制限される - Btrfs は動的に inode を割り当てるため、inode の数に制限はない。- ext2/ext3/ext4 のようにファイルシステム作成時に inode 数を固定する方式ではない。

⸻

❌ ext3 の後継である - Btrfs は ext3 の後継ではなく、新しい設計の CoW（Copy-on-Write）ファイルシステム。- ext3 の後継は ext4 であり、Btrfs とは別系統のファイルシステム。

⸻

### まとめ

```

特徴 Btrfs の対応 正解か
マルチデバイスに対応している ✅（RAID 0, 1, 10, 5, 6 をサポート） ✅
サブボリューム単位でのスナップショット機能がある ✅（サブボリュームごとにスナップショットが可能） ✅
ファイルの圧縮はサポートしていない ❌（zlib、lzo、zstd 圧縮をサポート） ❌
inode の数が制限される ❌（動的に inode を割り当てる） ❌
ext3 の後継である ❌（ext3 の後継は ext4、Btrfs は別系統） ❌

```

⸻

💡 ポイント - Btrfs はマルチデバイス対応！ RAID 機能を内蔵！- サブボリュームとスナップショット機能がある！- 動的 inode 割り当てなので inode 数の制限なし！- ext3 の後継ではなく、新しい CoW（Copy-on-Write）ファイルシステム！

✅ 「Btrfs はマルチデバイス & スナップショット対応！」

## Linuxのルートファイルシステムに使用できるファイルシステム

### **問題**

Linuxの **ルートファイルシステム（/）** に使用できるファイルシステムは次のうちどれか。
（**3つ選択**）

### **選択肢**

1. `ext4`
2. `iso9660`
3. `XFS`
4. `NTFS`
5. `ext3`

---

### **正解**

✅ **`ext3`**
✅ **`ext4`**
✅ **`XFS`**

---

### **解説**

#### **ルートファイルシステムとは？**

- Linux システムの中核を担う **`/`（ルート）ディレクトリを保持するファイルシステム**。
- 起動に必要なすべてのファイル、ライブラリ、設定ファイルが含まれるため、**信頼性とLinuxカーネルの互換性が必要**。

⸻

### **正解のファイルシステム**

#### **1. `ext3`**

- **古くから使用されているジャーナリングファイルシステム**。
- 信頼性が高く、現在でも多くのディストリビューションが対応。
- **ルートファイルシステムとして使用可能**。

✅ **正解！**

⸻

#### **2. `ext4`**

- **ext3 の後継で、現在の Linux で最も一般的なファイルシステム**。
- **大容量対応、高速化、信頼性向上などの機能が追加されている**。
- **多くの Linux ディストリビューションでルートファイルシステムとして標準使用されている**。

✅ **正解！**

⸻

#### **3. `XFS`**

- **高性能でスケーラブルなジャーナリングファイルシステム**。
- **Red Hat 系のディストリビューション（例：RHEL、CentOS、Rocky）でルートファイルシステムとして採用されていることが多い**。
- 大量ファイルや大規模データに強い。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`iso9660`**

- **CD-ROM や DVD-ROM などの読み取り専用メディア向けのファイルシステム**。
- 読み取り専用のため、**ルートファイルシステムとして使用不可**。

⸻

❌ **`NTFS`**

- **Windows のファイルシステム**。
- Linux でも読み書き可能だが、**完全な互換性や安定性が保証されない**。
- **カーネルレベルでの公式サポートが限定的で、ルートファイルシステムとしては推奨されない**。

⸻

### **まとめ**

| ファイルシステム | ルートに使用可否 | 理由                               | 正解か |
| ---------------- | ---------------- | ---------------------------------- | ------ |
| **`ext3`**       | ✅ 使用可能      | 古くから安定して使用されている     | ✅     |
| **`ext4`**       | ✅ 使用可能      | 現在の主流、信頼性と高速性         | ✅     |
| **`XFS`**        | ✅ 使用可能      | 大容量、高性能な FS、RHEL 系で採用 | ✅     |
| `iso9660`        | ❌ 使用不可      | 読み取り専用（CD/DVD 向け）        | ❌     |
| `NTFS`           | ❌ 使用非推奨    | Windows 用、完全な互換性なし       | ❌     |

⸻

💡 **ポイント**

- **ルートファイルシステムは「読み書き可能」で「信頼性のある Linux ネイティブ FS」が条件！**
- **主に使われるのは `ext4`、次いで `ext3` や `XFS`！**

✅ **「Linux のルートファイルシステムには `ext4`、`ext3`、`XFS` が使える！」**

## ディレクトリと配下の容量を単位付きで表示するコマンド

### **問題**

`dir` ディレクトリと、その配下にある **ディレクトリおよびファイルの容量を、分かりやすい単位（KB/MB/GB など）付きで表示したい**。
適切なコマンドを選びなさい。

### **選択肢**

1. `du -a dir`
2. `du -ah dir`
3. `du -c dir`
4. `du -s dir`
5. `du -sh dir`

---

### **正解**

✅ **`du -ah dir`**

---

### **解説**

#### **`du` コマンドとは？**

- **`du`（Disk Usage）コマンド**は、ファイルやディレクトリのディスク使用量を表示するためのコマンド。
- **`-h` オプションで「人間に読みやすい」形式（KB/MB/GBなど）で表示**される。

---

### **正解のコマンド**

#### **`du -ah dir`**

- `-a`（all）：**すべてのファイルとディレクトリの使用量を表示**
- `-h`（human-readable）：**サイズを KB/MB/GB 単位で見やすく表示**
- **目的に完全に一致するオプションの組み合わせ！**

✅ **正解！**

---

### **誤った選択肢の解説**

❌ **`du -a dir`**

- ファイルとディレクトリのサイズは表示されるが、**単位が付かない（バイト数）**。

⸻

❌ **`du -c dir`**

- `-c` は **合計を表示**するオプションであり、**単位表示や全ファイルのサイズ表示はしない**。

⸻

❌ **`du -s dir`**

- `-s` は **合計のみ（dir の総量）を表示**。
- **中のファイルやサブディレクトリのサイズは表示されない**。

⸻

❌ **`du -sh dir`**

- **`dir` 自体の合計サイズのみを単位付きで表示**する。
- **中の個別ファイルやディレクトリのサイズは表示されない**。

---

### **まとめ**

| コマンド         | 内容                                                   | 単位付き | 全ファイル表示 | 正解か |
| ---------------- | ------------------------------------------------------ | -------- | -------------- | ------ |
| **`du -ah dir`** | すべてのファイルとディレクトリのサイズを単位付きで表示 | ✅       | ✅             | ✅     |
| `du -a dir`      | 単位なしで全ファイル表示                               | ❌       | ✅             | ❌     |
| `du -c dir`      | 合計表示のみ（全ファイル不可）                         | ❌       | ❌             | ❌     |
| `du -s dir`      | 合計サイズのみ表示                                     | ❌       | ❌             | ❌     |
| `du -sh dir`     | 合計サイズのみを単位付きで表示                         | ✅       | ❌             | ❌     |

---

💡 **ポイント**

- **すべてのファイル・ディレクトリのサイズを確認したいなら `-a`！**
- **人間に読みやすい単位（KB/MB/GBなど）で見たいなら `-h`！**
- **`-ah` の組み合わせで、詳細＋単位表示を両立！**

✅ **「`du -ah dir` で、すべての容量を単位付きで見やすく表示！」**

## `e2fsck` コマンドで全ての問題を自動修復する方法

### **問題**

`e2fsck` コマンドで `/dev/sda4` をチェックする際に、
**ユーザーに確認せず、すべての問題を自動的に修復したい**。
適切なコマンドはどれか。

### **選択肢**

1. `e2fsck -auto /dev/sda4`
2. `e2fsck -n /dev/sda4`
3. `e2fsck -P /dev/sda4`
4. `e2fsck -p /dev/sda4`
5. `e2fsck -y /dev/sda4`

---

### **正解**

✅ **`e2fsck -p /dev/sda4`**

---

### **解説**

#### **`e2fsck` コマンドとは**

- **ext2/ext3/ext4 ファイルシステムの整合性チェックと修復を行うコマンド**。
- ファイルシステムに破損があった場合、問題点を報告し、必要であれば修復を試みる。

---

### **正解のオプション**

#### **`-p`（または `--preen`）**

- **ユーザーへの確認なしに、安全と思われる修復を自動的に実行する**。
- 通常は **システム起動時に自動チェック用として使用される**。
- 危険な修復操作（ファイルの削除など）は行わず、基本的な修復のみに限定。

✅ **正解！**

---

### **他の選択肢の解説**

❌ **`-auto`**

- **存在しないオプション**。
- `e2fsck` には `-auto` というオプションは定義されていない。

⸻

❌ **`-n`**

- **読み取り専用チェックを行う（変更はしない）**。
- どのような問題があるかを確認する用途には便利だが、**修復は行わない**。

⸻

❌ **`-P`**

- **複数のデバイスを並列でチェックする時の制御用**（複数デバイスを扱うスクリプト向け）。
- **単体のデバイスチェックで自動修復には関係なし**。

⸻

❌ **`-y`**

- **すべての質問に「yes」で自動応答する**。
- `-p` よりも強力で、**すべての修復操作を強制的に実行する**ため、**危険な修復も行われる可能性がある**。
- 完全自動化には便利だが、安全性を重視するなら `-p` の方が推奨される。

---

### **まとめ**

| オプション | 内容                               | 自動修復 | 安全性               | 正解か |
| ---------- | ---------------------------------- | -------- | -------------------- | ------ |
| **`-p`**   | 基本的な修復を自動実行（確認なし） | ✅       | 高い                 | ✅     |
| `-y`       | すべての操作に「yes」で応答        | ✅       | やや低い（強制修復） | ❌     |
| `-n`       | 読み取り専用で確認のみ             | ❌       | 高い                 | ❌     |
| `-P`       | 並列チェック制御用                 | ❌       | ―                    | ❌     |
| `-auto`    | 存在しないオプション               | ❌       | ―                    | ❌     |

---

💡 **ポイント**

- **安全に自動修復したい場合は `-p` オプション**
- **強制的にすべて修復したい場合は `-y` も使えるが、注意が必要**
- **チェックのみなら `-n`、情報だけ確認できる**

✅ **「基本的な自動修復を行いたいなら `e2fsck -p /dev/sda4`！」**

## ファイルやディレクトリが占めている容量を確認するコマンド

### **問題**

**ファイルやディレクトリが占めている容量** を確認できるコマンドは次のうちどれか。

### **選択肢**

1. `du`
2. `df`
3. `mkfs`
4. `ps`
5. `fdisk`

---

### **正解**

✅ **`du`**

---

### **解説**

#### **`du`（Disk Usage）**

- **ファイルやディレクトリ単位でディスクの使用量を表示するコマンド**。
- 指定したディレクトリ以下の各ファイル・ディレクトリが**どれだけのディスク容量を使用しているかを確認できる**。
- オプション例：
  ```bash
  du -sh /path/to/dir
  ```
  - -s: 合計のみ表示
  - -h: 人間に読みやすい単位で表示（KB/MB/GB）

✅ 正解！

⸻

誤った選択肢の解説

❌ df - ファイルシステム全体の使用量を確認するコマンド。- 各ファイルやディレクトリ単位の容量はわからない。- 使用例：

df -h

⸻

❌ mkfs - 新しくファイルシステムを作成するコマンド。- 使用量の確認には使えない。

⸻

❌ ps - プロセスの一覧を表示するコマンド。- ディスク容量とは無関係。

⸻

❌ fdisk - パーティションテーブルを操作するコマンド。- ファイルやディレクトリの容量確認には使えない。

⸻

### まとめ

```
コマンド	用途	容量確認	正解か
du	ファイル・ディレクトリごとの使用量表示	✅	✅
df	ファイルシステム全体の使用状況確認	❌	❌
mkfs	ファイルシステムの作成	❌	❌
ps	プロセスの表示	❌	❌
fdisk	パーティション操作	❌	❌
```

⸻

💡 ポイント - 個別のファイルやフォルダのサイズを見るなら du - ディスク全体の空き容量を確認するなら df - 用途に応じて使い分けよう！

✅ 「ファイルやディレクトリの容量を知りたいなら du！」

## XFSファイルシステムをチェックするコマンド

### **問題**

**XFSファイルシステムのチェック**を行うための適切なコマンドはどれか。

### **選択肢**

1. `xfs_check`
2. `xfs_fsck`
3. `xfs_db`
4. `xfs_info`
5. `mkfs.xfs`

---

### **正解**

✅ **`xfs_check`**

---

### **解説**

#### **`xfs_check`**

- **XFSファイルシステムの整合性をチェックするためのコマンド**。
- **読み取り専用でメタデータのチェックを行う**。
- 実行例：
  ```bash
  sudo xfs_check /dev/sdXn
  ```
  - 注意：マウントされていない状態で使う必要がある。

✅ 正解！

⸻

他の選択肢の解説

❌ xfs*fsck - 存在しないコマンド。- XFS では fsck の代わりに専用の xfs*\* 系ツールを使う。

⸻

❌ xfs_db - XFSのメタデータに対して対話的なアクセスやデバッグを行うツール。- チェック用ではなく、内部構造を調査・修復に使う低レベルツール。

⸻

❌ xfs_info - XFSファイルシステムの情報（ブロックサイズやinodeサイズなど）を表示するコマンド。- チェックではない。

⸻

❌ mkfs.xfs - XFSファイルシステムを新規に作成するためのコマンド。- チェックとは関係ない。

⸻

### まとめ

```

コマンド 用途 正解か
xfs_check XFSファイルシステムの整合性チェック ✅
xfs_fsck 存在しないコマンド ❌
xfs_db メタデータの調査・デバッグ用 ❌
xfs_info XFSの情報表示（構成確認） ❌
mkfs.xfs XFSファイルシステムの作成 ❌

```

⸻

💡 ポイント - xfs_check は XFS 専用のファイルシステムチェックツール！- マウントされていない状態で使うこと！- 最近では xfs_repair -n が推奨されることもあるが、選択肢にない場合は xfs_check が正解！

✅ 「XFS のチェックには xfs_check！」

## ext2/ext3/ext4 ファイルシステムのボリュームラベルを設定するオプション

### **問題**

ext2/ext3/ext4 ファイルシステムのボリュームラベルを設定する
`tune2fs` コマンドの適切なオプションはどれか。

### **選択肢**

1. `-L`
2. `-a`
3. `-j`
4. `-i`
5. `-c`

---

### **正解**

✅ **`-L`**

---

### **解説**

#### **`-L` オプション**

- **`tune2fs` コマンドでファイルシステムにラベル（名前）を設定・変更するためのオプション**。
- 対象は ext2/ext3/ext4 ファイルシステム。
- 使用例：

```bash
sudo tune2fs -L MyVolume /dev/sdXn
```

    -	この例では /dev/sdXn に MyVolume というラベルを設定。

✅ 正解！

⸻

誤った選択肢の解説

❌ -a - tune2fs には -a オプションは存在しない。

⸻

❌ -j - ext2 を ext3 に変換するための mke2fs コマンド用オプションであり、tune2fs のラベル設定とは無関係。

⸻

❌ -i - 自動チェックの間隔（日数）を設定するオプション。- 例：tune2fs -i 10 /dev/sda1 は10日ごとに自動チェック。

⸻

❌ -c - マウント回数によるチェックの設定。- 例：tune2fs -c 20 /dev/sda1 は20回マウントごとにチェック。

⸻

### まとめ

```
オプション	説明	正解か
-L	ボリュームラベルの設定	✅
-a	無効なオプション（存在しない）	❌
-j	mke2fs 用：ext2→ext3 変換	❌
-i	自動チェックの間隔（日数）	❌
-c	マウント回数によるチェック設定	❌
```

⸻

💡 ポイント - ボリュームラベルの設定は tune2fs -L ラベル名 デバイス名 - ラベルは e2label コマンドでも確認・設定できる

✅ 「ボリュームラベルの設定は -L オプション！」

## ext2/ext3/ext4ファイルシステム作成時に予約される領域

### **問題**

ext2/ext3/ext4 ファイルシステムを作成した時に、**rootユーザ用に予約される領域**として正しいものはどれか。

### **選択肢**

1. 200MB
2. ファイルシステム全体の5%
3. 1GB
4. ファイルシステム全体の1%
5. デフォルトでは予約されない

---

### **正解**

✅ **ファイルシステム全体の5%**

---

### **解説**

#### **予約領域とは？**

- ext2/ext3/ext4 ファイルシステムでは、**システムの安定性や緊急時の復旧を目的として、ファイルシステムの一部を root ユーザ専用に予約**する。
- この予約領域により、一般ユーザがディスクを100%使い切っても、**root ユーザはログインして復旧作業ができる**ように設計されている。

#### **デフォルト値**デバイス名 / マウントポイント / FSタイプ / オプション / dump / fsck

- `mke2fs` または `mkfs.ext4` などでファイルシステムを作成する際、**デフォルトで 5% の領域が root 用に予約される**。

✅ **正解！**

---

### **確認・変更方法**

#### **確認**

```bash
sudo tune2fs -l /dev/sdXn | grep 'Reserved block count'
```

変更（例：1%に変更）

sudo tune2fs -m 1 /dev/sdXn

    -	-m は予約領域の割合（%）を指定するオプション。

⸻

誤った選択肢の解説

❌ 200MB / 1GB - 固定サイズではなく、全体容量に対するパーセンテージで指定される。

❌ ファイルシステム全体の1% - 変更すれば1%に設定可能だが、デフォルトは5%。

❌ デフォルトでは予約されない - ext2/ext3/ext4 の初期設定では 5% が予約されるため誤り。

⸻

### まとめ

```
選択肢	内容	正解か
200MB	固定サイズ → 誤り	❌
ファイルシステム全体の5%	デフォルト設定	✅
1GB	固定サイズ → 誤り	❌
ファイルシステム全体の1%	設定変更は可能だがデフォルトではない	❌
デフォルトでは予約されない	ext系では予約されるため誤り	❌
```

⸻

💡 ポイント - ext2/ext3/ext4 のファイルシステムは、デフォルトで5%の容量を root のために予約！- tune2fs -m を使って変更可能！

✅ 「予約領域はファイルシステム全体の 5%！」

## fsckコマンドでファイルシステムの整合性を自動修復するオプション

### **問題**

`fsck` コマンドでファイルシステムの整合性をチェックする際、
**障害箇所を自動的に修復したい**。
適切なオプションはどれか。

### **選択肢**

1. `-a`
2. `-N`
3. `-auto`
4. `-r`
5. `-A`

---

### **正解**

✅ **`-a`**

---

### **解説**

#### **`-a` オプション**

- **自動修復（非対話モード）**で整合性を修復するためのオプション。
- **fsck が見つけたエラーに対して、自動的に「yes」で修復を進める**。
- **一部のファイルシステム（特に ext 系）でのみ有効**。
- 使用例：
  ```bash
  sudo fsck -a /dev/sdXn
  ```

✅ 正解！

⸻

誤った選択肢の解説

❌ -N - 実行されるコマンドを表示するだけで実行しないオプション（dry-run的な用途）。

❌ -auto - 存在しないオプション。- 自動修復には -a または -y を使う。

❌ -r - 対話式モード。ユーザーに修復の確認を求めるオプション。- 自動ではないため、誤り。

❌ -A - /etc/fstab にあるすべてのファイルシステムをチェック対象にするオプション。- 修復の自動化とは直接関係しない。

⸻

### まとめ

```
オプション 内容 自動修復 正解か
-a 自動修復（yesで進行） ✅ ✅
-N 実行内容を表示するだけ（実行しない） ❌ ❌
-auto 存在しないオプション ❌ ❌
-r 対話式修復（確認あり） ❌ ❌
-A 全ファイルシステムチェック（fstab） ❌ ❌
```

⸻

💡 ポイント - fsck -a でエラーを自動修復！（一部ファイルシステムのみ対応）- 対話なしで完全自動なら -y も使用可能（-a より強力）

✅ 「自動で修復したいなら fsck -a を使おう！」

## ファイルシステムのチェック間隔を3日間に変更するコマンド

### **問題**

`/dev/sda2` の **ファイルシステムをチェックする間隔** を **3日ごと** に設定したい。
適切なコマンドを **2つ選択**しなさい。

### **選択肢**

1. `tune2fs -D 3i /dev/sda2`
2. `tune2fs -i 3d /dev/sda2`
3. `tune2fs -i 3 /dev/sda2`
4. `tune2fs -day 3 /dev/sda2`

---

### **正解**

✅ **`tune2fs -i 3d /dev/sda2`**
✅ **`tune2fs -i 3 /dev/sda2`**

---

### **解説**

#### **`tune2fs` コマンド**

- `tune2fs` は **ext2/ext3/ext4 ファイルシステムの設定を調整するコマンド**。
- `-i` オプションは **fsck による自動チェックの間隔（days/weeks/months）を指定**する。

---

### **正しいコマンド**

#### **1. `tune2fs -i 3d /dev/sda2`**

- **3日ごとに自動チェックする**ように設定。
- `3d` は「3 days（3日）」を意味する。

✅ **正解！**

⸻

#### **2. `tune2fs -i 3 /dev/sda2`**

- デフォルトでは単位なしの数字は「日（days）」と解釈されるため、**これも「3日間隔」を意味する**。

✅ **正解！**

---

### **誤った選択肢の解説**

❌ **`tune2fs -D 3i /dev/sda2`**

- 存在しないオプションと無効な構文。
- `-D` も `3i` も不正。

⸻

❌ **`tune2fs -day 3 /dev/sda2`**

- `-day` というオプションは存在しない。

---

### **まとめ**

| コマンド                      | 説明                            | 正解か |
| ----------------------------- | ------------------------------- | ------ |
| **`tune2fs -i 3d /dev/sda2`** | **3日間隔で自動チェック**       | ✅     |
| **`tune2fs -i 3 /dev/sda2`**  | **単位なしでも3日と解釈される** | ✅     |
| `tune2fs -D 3i /dev/sda2`     | 存在しないオプション            | ❌     |
| `tune2fs -day 3 /dev/sda2`    | 無効なオプション                | ❌     |

---

💡 **ポイント**

- **`tune2fs -i` オプションで自動fsckの実行間隔（日数・週・月）を設定可能！**
- 単位は `d`（days）、`w`（weeks）、`m`（months）

✅ **「`tune2fs -i 3d /dev/sda2` または `-i 3` で3日間隔に設定！」**

## ファイルシステムをチェックせずにマウントできる回数を変更するコマンド

### **問題**

ファイルシステムをチェックせずに「/dev/sda2」が**マウントできる回数**を **10回** に変更したい。
適切なコマンドはどれか。

### **選択肢**

1. `tune2fs -c 10 /dev/sda2`
2. `tune2fs -L 10 /dev/sda2`
3. `tune2fs -j 10 /dev/sda2`
4. `tune2fs -mount 10 /dev/sda2`
5. `tune2fs -i 10 /dev/sda2`

---

### **正解**

✅ **`tune2fs -c 10 /dev/sda2`**

---

### **解説**

#### **`-c` オプション**

- `-c` は **fsck（ファイルシステムチェック）が実行されるまでの最大マウント回数**を設定するオプション。
- **指定回数マウントされたら、自動的に fsck によるチェックが実行される**。
- 使用例：

```bash
sudo tune2fs -c 10 /dev/sda2
```

    -	このコマンドにより、「10回マウントされるまで fsck をスキップ」する設定になる。

✅ 正解！

⸻

誤った選択肢の解説

❌ -L - ファイルシステムのラベル（名前）を設定するオプション。マウント回数とは無関係。

❌ -j - ext2 を ext3 に変換するためのジャーナリング機能を追加するオプション（mke2fs用）。

❌ -mount - 存在しないオプション。誤記。

❌ -i - 日数ベースでチェック間隔を指定するオプション（例：-i 10d = 10日ごとにチェック）。- マウント回数ではなく、時間ベースのチェック設定。

⸻

### まとめ

```
オプション	説明	正解か
-c	マウント回数でチェックを行う条件を設定	✅
-L	ラベル（名前）を設定	❌
-j	ジャーナリング機能を追加（ext2→ext3）	❌
-mount	存在しないオプション	❌
-i	チェック実行間隔（日数）を設定	❌
```

⸻

💡 ポイント - マウント回数ベースでチェックを制御するには -c オプション！- 時間間隔ベースなら -i、ラベル変更なら -L を使う！

✅ 「tune2fs -c 10 /dev/sda2 で、10回マウントするまで fsck をスキップ！」

## `fsck`コマンドで実行せずに内容だけ表示する方法（ext3の例）

### **問題**

`fsck` コマンドで **ext3 ファイルシステム `/dev/sda4` の整合性をチェック**する際、
**実際には実行せず、「何が行われるか」だけを表示したい**。
適切なコマンドはどれか。

### **選択肢**

1. `fsck ext3 /dev/sda4`
2. `fsck -t -A ext3 /dev/sda4`
3. `fsck -t -N ext3 /dev/sda4`
4. `fsck -t ext3 /dev/sda4`
5. `fsck -N -t ext3 /dev/sda4`

---

### **正解**

✅ **`fsck -N -t ext3 /dev/sda4`**

---

### **解説**

#### **`-N` オプション**

- **実行されるコマンドを表示するだけで、実際には何も実行しない**（dry-run）。
- スクリプトでのテストや確認に便利。

#### **`-t ext3`**

- **対象のファイルシステムタイプ（ここでは ext3）を明示的に指定**。
- `fsck` は複数のファイルシステムに対応しているため、必要に応じて明示することで適切なサブコマンド（`fsck.ext3` など）を選択する。

#### **使用例**

```bash
sudo fsck -N -t ext3 /dev/sda4
```

    -	出力例（実際の修復は行われず、内部的にどのコマンドが実行されるかを表示）：

```
Would execute command: fsck.ext3 /dev/sda4
```

✅ 正解！

⸻

誤った選択肢の解説

❌ fsck ext3 /dev/sda4 - 不正な構文。- ext3 がデバイス名のように解釈されてしまうため、正しく動作しない。

⸻

❌ fsck -t -A ext3 /dev/sda4 - -A は /etc/fstab に基づいて全ファイルシステムを処理するためのもので、単一のデバイス /dev/sda4 と併用するのは不自然。- -t の直後にファイルシステムタイプがないため構文ミスでもある。

⸻

❌ fsck -t -N ext3 /dev/sda4 - オプションの順序と構文が正しくない。- -t に続くファイルシステムタイプ ext3 が -N に割り込まれてしまっている。

⸻

❌ fsck -t ext3 /dev/sda4 - 正常に ext3 のチェックは実行されるが、実行を「表示するだけ」ではないため不正解。

⸻

### まとめ

```
コマンド 内容 実行されるか 正解か
fsck -N -t ext3 /dev/sda4 実行せず内容のみ表示 ❌ 実行されない ✅
fsck ext3 /dev/sda4 構文ミス ― ❌
fsck -t -A ext3 /dev/sda4 全体対象＋構文不正 実行される可能性あり ❌
fsck -t -N ext3 /dev/sda4 オプション順序が不正 ― ❌
fsck -t ext3 /dev/sda4 実行される（表示のみではない） ✅ 実行される ❌
```

⸻

💡 ポイント - -N：実行内容だけ表示（dry-run）- -t ファイルシステムタイプ：対象FSを明示 - fsck -N -t ext3 /dev/sda4 で実際には何もせず内容だけ表示できる！

✅ 「実行せず内容だけ確認したいなら fsck -N -t ext3 /dev/sda4！」

## XFSファイルシステムの情報を表示するコマンド

### **問題**

XFSファイルシステムの**情報を表示するための適切なコマンド**はどれか。

### **選択肢**

1. `mkfs.xfs`
2. `info.xfs`
3. `check.xfs`
4. `xfs_db`
5. `xfs_info`

---

### **正解**

✅ **`xfs_info`**

---

### **解説**

#### **`xfs_info` コマンド**

- **XFSファイルシステムの詳細情報（ブロックサイズ、セクタサイズ、ログ情報など）を表示するコマンド**。
- マウントされた XFS ファイルシステムに対して使用する。
- 使用例：

```bash
sudo xfs_info /mnt/data
```

    -	出力例：

```
meta-data=/dev/sda1              isize=512    agcount=4, agsize=327680 blks
         =                       sectsz=512   attr=2, projid32bit=1
```

...

✅ 正解！

⸻

誤った選択肢の解説

❌ mkfs.xfs - XFSファイルシステムを新しく作成するコマンド。- 情報を表示する用途ではない。

⸻

❌ info.xfs - 存在しないコマンド。

⸻

❌ check.xfs - 存在しないコマンド名。チェックは xfs_check または xfs_repair で行う。

⸻

❌ xfs_db - XFSメタデータを操作・調査するための対話的な低レベルツール。- 詳細情報の表示は可能だが、通常の情報確認には不向き。

⸻

### まとめ

```
コマンド	内容	正解か
xfs_info	XFSファイルシステムの基本情報表示	✅
mkfs.xfs	XFSファイルシステムの作成	❌
info.xfs	存在しない	❌
check.xfs	存在しない	❌
xfs_db	メタデータの調査・操作用（上級者向け）	❌
```

⸻

💡 ポイント - XFSの基本情報を確認したいなら xfs_info！- 高度な調査は xfs_db、整合性チェックは xfs_check や xfs_repair を使おう

✅ 「XFS の情報表示には xfs_info！」

## inodeの使用状況を確認するコマンド

### **問題**

inode の**使用状況（使用中/残りの数）**を確認するための適切なコマンドはどれか。

### **選択肢**

1. `df -h`
2. `df -i`
3. `df -u`
4. `df -I`
5. `df -H`

---

### **正解**

✅ **`df -i`**

---

### **解説**

#### **`df -i`**

- **ディスクの inode 使用状況（使用済み/空き）を表示するオプション**。
- 各マウントポイントごとの inode の数と使用率が確認できる。
- 使用例：

```bash
df -i
```

    -	出力例：

```
Filesystem     Inodes  IUsed   IFree IUse% Mounted on
/dev/sda1     6553600 125000 6428600    2% /
```

✅ 正解！

⸻

誤った選択肢の解説

❌ df -h - ディスク容量（サイズ・使用量）を「人間に読みやすい単位」で表示。- inode の情報は表示されない。

⸻

❌ df -u - 存在しないオプション。無効。

⸻

❌ df -I - df に -I オプションは存在しない。大文字小文字にも注意。

⸻

❌ df -H - ディスク容量を 1000バイト単位（SI単位） で表示。- inode とは無関係。

⸻

### まとめ

```
コマンド 説明 inode表示 正解か
df -i inodeの使用状況を表示 ✅ ✅
df -h 容量を人間に読みやすく表示（MB/GBなど） ❌ ❌
df -u 存在しないオプション ❌ ❌
df -I 存在しないオプション（大文字） ❌ ❌
df -H 容量をSI単位（1000バイト）で表示 ❌ ❌
```

⸻

💡 ポイント - df -i で inode の「使用中」「残り」「使用率」が確認できる！- inode を使い切ると空き容量があってもファイルが作れなくなるので注意！

✅ 「inode の使用状況を確認するには df -i！」

## ファイルシステムのチェックおよび修復を行うコマンド

### **問題**

**ファイルシステムの整合性チェック**および **問題を修復** できるコマンドは次のうちどれか。  
（**全て選択**）

### **選択肢**

1. `fdisk`
2. `tune2fs`
3. `e2fsck`
4. `mke2fs`
5. `fsck`

---

### **正解**

✅ **`fsck`**  
✅ **`e2fsck`**

---

### **解説**

#### ✅ `fsck`（File System Consistency Check）

- **多くのファイルシステムに対応した整合性チェックツールのフロントエンド**。
- 使用するファイルシステムに応じて、`e2fsck`、`xfs_repair` など適切な実行ファイルを呼び出す。
- 問題を自動的に修復するには `-a` や `-y` オプションを使う。
- 例：
  ```bash
  sudo fsck /dev/sda1
  ```
  ✅ e2fsck - ext2/ext3/ext4 専用のファイルシステムチェックツール。- fsck が内部的に呼び出すこともある。- 例：

sudo e2fsck -p /dev/sda1

⸻

❌ 誤った選択肢の解説

❌ fdisk - ディスクのパーティション操作ツール（作成・削除など）。- ファイルシステムのチェックや修復は行わない。

❌ tune2fs - ext系ファイルシステムの設定を調整するツール（予約領域やチェック間隔など）。- 修復は行わない。

❌ mke2fs - 新しい ext2/ext3/ext4 ファイルシステムを作成するツール。- 整合性チェックや修復の機能はない（フォーマットに近い操作）。

⸻

### まとめ

```

コマンド 用途 修復機能 正解か
fsck ファイルシステムのチェックと修復（汎用） ✅ ✅
e2fsck ext2/3/4用のチェックと修復 ✅ ✅
fdisk パーティションの操作 ❌ ❌
tune2fs ファイルシステム設定の調整（ラベル・間隔など） ❌ ❌
mke2fs 新しいファイルシステムを作成 ❌ ❌

```

⸻

💡 ポイント - チェック＋修復 = fsck（汎用） or e2fsck（ext系）！- fdisk や tune2fs は設定やパーティション操作用。修復はできない！

✅ 「ファイルシステムの問題を修復したいなら fsck または e2fsck！」

## ext2ファイルシステムをext3に変換するコマンド

### **問題**

ext2ファイルシステムの **「/dev/hda5」** を **ext3 に変換**したい。
適切なコマンドはどれか。

### **選択肢**

1. `tune2fs -t ext3 /dev/hda5`
2. `tune2fs -j ext3 /dev/hda5`
3. `tune2fs -j /dev/hda5`
4. `mkfs -t ext3 /dev/hda5`
5. `mke2fs -j /dev/hda5`

---

### **正解**

✅ **`tune2fs -j /dev/hda5`**

---

### **解説**

#### ✅ `tune2fs -j /dev/hda5`

- **ext2 を ext3 に変換するための正しい手順**。
- ext3 は ext2 に「ジャーナリング機能」を追加したものなので、`tune2fs` で `-j` オプションを使うことで **ジャーナルを追加＝ext3 へ変換** となる。
- 使用例：

```bash
sudo tune2fs -j /dev/hda5
```

    -	変換後は /etc/fstab のファイルシステムタイプを ext2 → ext3 に変更するのを忘れずに！

✅ 正解！

⸻

❌ 誤った選択肢の解説

❌ tune2fs -t ext3 /dev/hda5 - -t オプションは ファイルシステムの種類ではなく、エラー処理の動作を指定する用途。- ext2 → ext3 の変換には無関係。

⸻

❌ tune2fs -j ext3 /dev/hda5 - -j オプションは引数を取らず、構文ミス。

⸻

❌ mkfs -t ext3 /dev/hda5 - これは ext3 ファイルシステムを新規作成（＝フォーマット）するコマンド。- 既存データはすべて消えるため、変換ではなく破壊的な再作成になる。

⸻

❌ mke2fs -j /dev/hda5 - これも ext3 ファイルシステムを作成するコマンドであり、既存の ext2 を変換するものではない。

⸻

### まとめ

```
コマンド	内容	変換できるか	正解か
tune2fs -j /dev/hda5	ext2 にジャーナルを追加 → ext3に変換	✅	✅
tune2fs -t ext3 /dev/hda5	エラー動作の設定 → 関係なし	❌	❌
tune2fs -j ext3 /dev/hda5	-j オプションは引数不要 → 構文エラー	❌	❌
mkfs -t ext3 /dev/hda5	ext3を新規作成（フォーマット） → データ消失	❌（再作成）	❌
mke2fs -j /dev/hda5	ext3を新規作成（ジャーナル付き）	❌（再作成）	❌
```

⸻

💡 ポイント - ext2 → ext3 変換は「ジャーナル追加」だけでOK！- 非破壊的に変換できるのは tune2fs -j のみ！

✅ 「ext2 を ext3 に変換するなら tune2fs -j /dev/hda5！」

## fsckコマンドで対話的に修復を行うオプション

### **問題**

`fsck` コマンドでファイルシステムの整合性をチェックする際、  
**障害箇所をユーザーに確認しながら（対話的に）修復したい**。  
適切なオプションはどれか。

### **選択肢**

1. `-N`
2. `-r`
3. `-t`
4. `-a`
5. `-A`

---

### **正解**

✅ **`-r`**

---

### **解説**

#### ✅ `-r`（repair interactively）

- **fsck 実行時に障害箇所が見つかった場合、ユーザーに修復するかどうかを確認しながら進めるオプション**。
- 通常はデフォルトで対話モードになるが、**明示的に指定したい場合に使用**。
- 使用例：

```bash
sudo fsck -r /dev/sda1
```

    -	出力例（確認を求められる）：

```
Inode 12345 has invalid mode.
Fix<y>?
```

✅ 正解！

⸻

❌ 誤った選択肢の解説

❌ -N - 実行せずに、実際にどのコマンドが呼ばれるかを表示する（dry-run）。- 修復は行わない。

⸻

❌ -t - ファイルシステムのタイプ（例：ext3, xfs など）を指定するオプション。- 修復方法には関係しない。

⸻

❌ -a - 自動修復モード（non-interactive）。- ユーザーに確認せず自動的に修復するので、対話的ではない。

⸻

❌ -A - /etc/fstab に記載されたファイルシステムすべてをチェック対象にするオプション。- 修復の方式には無関係。

⸻

### まとめ

```
オプション	内容	対話的修復	正解か
-r	対話的に修復（修復前に確認）	✅	✅
-N	実行内容の表示のみ（dry-run）	❌	❌
-t	ファイルシステムタイプを指定	❌	❌
-a	自動修復（ユーザー確認なし）	❌	❌
-A	全ファイルシステム対象（/etc/fstab 参照）	❌	❌
```

⸻

💡 ポイント - 対話的に修復したいなら -r（repair interactively）- 一切確認せず自動修復するなら -a または -y を使う - 安全に進めたいときは -r で手動判断がおすすめ！

✅ 「fsck で確認しながら修復したいなら fsck -r /dev/sdXn！」

## XFSファイルシステムのデバッグを行うコマンド

### **問題**

XFSファイルシステムの**デバッグ（詳細な内部構造の調査や操作）**を行うための適切なコマンドはどれか。

### **選択肢**

1. `xfs_fsr`
2. `xfs_check`
3. `xfs_db`
4. `metadump.xfs`
5. `mkfs.xfs`

---

### **正解**

✅ **`xfs_db`**

---

### **解説**

#### ✅ `xfs_db`

- **XFS ファイルシステムのメタデータを直接調査・操作できる低レベルのデバッグツール**。
- 主にトラブルシューティングや詳細な内部構造の確認に使用される。
- **破損したファイルシステムの修復や状態確認**にも役立つ。
- 使用例（読み取り専用で開く）：

```bash
sudo xfs_db -r /dev/sdXn
```

    -	対話モードで操作でき、sb（スーパーブロック）、inode、block などの情報が取得できる。

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ xfs_fsr - XFS ファイルシステムのデフラグ（断片化の解消）を行うコマンド。- デバッグ用途ではない。

⸻

❌ xfs_check - XFS ファイルシステムの整合性チェックを行うツール（読み取り専用）。- デバッグではなく健全性の確認に使用される。

⸻

❌ metadump.xfs - XFS メタデータのダンプ（バックアップ）を作成するコマンド。- デバッグ作業そのものではなく、問題調査用データを抽出するために使用。

⸻

❌ mkfs.xfs - XFS ファイルシステムを新規に作成するコマンド。- デバッグやトラブル対応とは無関係。

⸻

### まとめ

```
コマンド	用途	デバッグ対応	正解か
xfs_db	XFSメタデータの調査・操作（デバッグ用）	✅	✅
xfs_fsr	デフラグ（最適化）	❌	❌
xfs_check	整合性チェック（読み取り専用）	❌	❌
metadump.xfs	メタデータのダンプ作成	❌（補助的）	❌
mkfs.xfs	ファイルシステムの新規作成	❌	❌
```

⸻

💡 ポイント - XFS の内部を詳しく調査・デバッグしたい場合は xfs_db！- 使用には十分注意が必要（特に書き込みモード）

✅ 「XFS のデバッグには xfs_db を使おう！」

## `/etc/fstab` に記載された全ファイルシステムをチェックする fsck のオプション

### **問題**

`/etc/fstab` ファイルに記述されている**すべてのファイルシステムをチェック**したい。  
そのために使う `fsck` コマンドの適切なオプションはどれか。

### **選択肢**

1. `-ALL`
2. `-A`
3. `-all`
4. `-N`
5. `-t`

---

### **正解**

✅ **`-A`**

---

### **解説**

#### ✅ `-A` オプション

- **`/etc/fstab` に記述されているすべてのファイルシステムを対象にチェックを実行する**。
- ブート時に自動でファイルシステムを検査する処理と同等の処理を手動で行える。
- `fs_passno`（fstab の第6フィールド）に基づいて優先度付きでチェックが実行される。

##### 使用例：

```bash
sudo fsck -A
```

✅ 正解！

⸻

❌ 誤った選択肢の解説

❌ -ALL / -all - 存在しないオプション。大文字・小文字を変えても無効。

⸻

❌ -N - dry-run（実行せずに実行されるコマンドを表示）するオプション。- 実際のチェックは行われない。

⸻

❌ -t - ファイルシステムの種類を指定するオプション（例：-t ext4）。- -A と組み合わせて、特定のタイプだけを対象にするために使用される補助的なオプション。

⸻

### まとめ

```
オプション	説明	チェック対象	実行されるか	正解か
-A	/etc/fstab 全体に基づいてファイルシステムをチェック	✅	✅	✅
-ALL	無効なオプション（存在しない）	❌	❌	❌
-all	無効なオプション（存在しない）	❌	❌	❌
-N	実行されるコマンドの確認だけ（dry-run）	✅	❌	❌
-t	ファイルシステムタイプ指定（補助用）	条件付き	✅	❌
```

⸻

💡 ポイント - 複数のファイルシステムを一括チェックするには -A オプション - /etc/fstab の設定に基づいて安全に順序を守ってチェックされる

✅ 「全ファイルシステムをまとめてチェックしたいなら fsck -A！」

## XFSファイルシステムの検査・修復を行うコマンド

### **問題**

XFSファイルシステムの**検査および修復**を行いたい。  
適切なコマンドはどれか。

### **選択肢**

1. `xfs_info`
2. `xfs_check`
3. `xfs_db`
4. `xfs_fsr`
5. `xfs_repair`

---

### **正解**

✅ **`xfs_repair`**

---

### **解説**

#### ✅ `xfs_repair`

- **XFS ファイルシステム専用の検査・修復ツール**。
- **メタデータの整合性を検査・修復**し、破損している構造を修復する。
- 通常、**マウントされていない状態のデバイスに対して使用**する。

##### 使用例：

```bash
sudo umount /dev/sdXn
sudo xfs_repair /dev/sdXn
```

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ xfs_info - XFSファイルシステムの情報（ブロックサイズ・セクターサイズなど）を表示するツール。- 修復には使えない。

⸻

❌ xfs_check - 古い検査専用ツール。- 現在は非推奨であり、検査も xfs_repair -n を使うのが主流。- 実際には修復機能がない。

⸻

❌ xfs_db - XFSのメタデータを手動で調査・操作する高度なデバッグツール。- 使いこなすには専門知識が必要で、一般的な修復には不向き。

⸻

❌ xfs_fsr - XFSファイルシステムのデフラグ（最適化）を行うツール。- 整合性チェックや修復とは無関係。

⸻

### まとめ

```
コマンド	用途	修復機能	正解か
xfs_repair	XFSファイルシステムの検査・修復	✅	✅
xfs_info	ファイルシステム情報の表示	❌	❌
xfs_check	検査のみ（非推奨）	❌	❌
xfs_db	メタデータのデバッグ用	❌	❌
xfs_fsr	デフラグ（断片化解消）	❌	❌
```

⸻

💡 ポイント - XFSファイルシステムの修復には xfs_repair！- 読み取り専用チェックを行いたい場合は xfs_repair -n が推奨される - 実行前にはマウント解除を忘れずに！

✅ 「XFS を修復したいなら xfs_repair を使おう！」

## ext2/ext3/ext4ファイルシステムのパラメータを設定するコマンド

### **問題**

ext2/ext3/ext4 ファイルシステムの**パラメータ（例：ラベル、チェック間隔、予約領域など）を設定**したい。  
適切なコマンドはどれか。

### **選択肢**

1. `e2fsck`
2. `df`
3. `tune2fs`
4. `du`
5. `mkfs`

---

### **正解**

✅ **`tune2fs`**

---

### **解説**

#### ✅ `tune2fs`

- **ext2/ext3/ext4 ファイルシステムの各種パラメータを設定・変更するための専用コマンド**。
- 以下のような設定が可能：
  - ボリュームラベルの変更（`-L`）
  - fsck のチェック間隔（日数 or 回数）（`-i`, `-c`）
  - 予約領域の割合（`-m`）
  - ラストマウント日時やマウント回数の表示 など

##### 使用例：

```bash
sudo tune2fs -L MyVolume /dev/sda1        # ラベルを設定
sudo tune2fs -c 10 /dev/sda1              # チェックなしでマウントできる回数を10回に設定
sudo tune2fs -i 7d /dev/sda1              # 7日ごとにチェック
```

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ e2fsck - ファイルシステムのチェック・修復を行うコマンド。- パラメータの設定は行えない。

⸻

❌ df - ディスク使用量を表示するコマンド。- 設定は一切変更できない。

⸻

❌ du - ファイルやディレクトリ単位の容量（使用量）を表示するコマンド。- ファイルシステムの設定変更とは無関係。

⸻

❌ mkfs - 新しいファイルシステムを作成（フォーマット）するコマンド。- 一度作成したファイルシステムの「パラメータの調整」には使えない。

⸻

### まとめ

```
コマンド	用途	パラメータ設定可	正解か
tune2fs	ext系ファイルシステムのパラメータ調整	✅	✅
e2fsck	チェック・修復	❌	❌
df	使用量表示	❌	❌
du	ディレクトリ・ファイル容量表示	❌	❌
mkfs	ファイルシステムの新規作成	❌	❌
```

⸻

💡 ポイント - ext2/ext3/ext4 のパラメータ調整は tune2fs で！- 安全な運用・パフォーマンス調整に不可欠なコマンド

✅ 「パラメータ設定したいなら tune2fs！」

## systemdのmountユニットに関する正しい説明

### **問題**

systemd の **mountユニット** に関する説明として**正しいものを2つ**選びなさい。

### **選択肢**

1. 「/etc/fstab」の内容から mount ユニットが自動生成される
2. 手動でマウントを行うと、マウントポイント名の mount ユニットが生成される
3. 「/etc/fstab」の内容からスワップ領域が設定される
4. mount ユニットはインストール時に生成され、「/etc/fstab」の内容は反映されない
5. 手動でマウントを行うと、mount ユニットは生成されない

---

### **正解**

✅ **1. 「/etc/fstab」の内容から mount ユニットが自動生成される**  
✅ **2. 手動でマウントを行うと、マウントポイント名の mount ユニットが生成される**

---

### **解説**

#### ✅ 1. 「/etc/fstab」の内容から mount ユニットが自動生成される

- systemd は **起動時に `/etc/fstab` を読み取り、その内容に基づいて `.mount` ユニットを動的に生成**します。
- これにより fstab を使った従来のマウント設定が systemd にも反映されます。

✅ **正解！**

---

#### ✅ 2. 手動でマウントを行うと、マウントポイント名の mount ユニットが生成される

- `mount /mnt/data` のように手動でマウントすると、systemd は内部的にそのマウント状態を管理するために、**該当する mount ユニット（例: `mnt-data.mount`）を自動でトラッキング対象にします**。
- 厳密には persistent な `.mount` ユニットファイルが生成されるわけではありませんが、**ユニットとして認識・管理されます**。

✅ **正解！**

---

### ❌ その他の選択肢

#### ❌ 3. 「/etc/fstab」の内容からスワップ領域が設定される

- これは **swap ユニット (`.swap`) に関する内容**であり、**mount ユニットとは別の概念**。

⸻

#### ❌ 4. mount ユニットはインストール時に生成され、「/etc/fstab」の内容は反映されない

- systemd は起動時に `fstab` をパースして mount ユニットを**動的に生成**するため、**インストール時に固定の mount ユニットを作成するわけではない**。

⸻

#### ❌ 5. 手動でマウントを行うと、mount ユニットは生成されない

- 手動マウントは systemd に認識され、**マウント状態を管理するユニットとして扱われます**（ユニットファイルが生成されるわけではないが、systemd はそれを管理）。

---

### **まとめ**

| 選択肢 | 内容                                              | 正誤    |
| ------ | ------------------------------------------------- | ------- |
| 1      | `/etc/fstab` から mount ユニット自動生成          | ✅ 正解 |
| 2      | 手動マウントでも mount ユニットが生成される       | ✅ 正解 |
| 3      | スワップ領域に関する内容（mountとは別）           | ❌      |
| 4      | mount ユニットはインストール時に作られる？ → 誤り | ❌      |
| 5      | 手動マウントではユニットは生成されない？ → 誤り   | ❌      |

---

💡 **ポイント**

- systemd は **従来の fstab 設定にも完全対応**しており、自動で `.mount` ユニットを生成
- 手動マウントした場合も、systemd によってその状態は**ユニットとして管理される**

✅ **「mount ユニットは fstab からも、手動マウントからも動的に扱われる！」**

## `/etc/fstab` における CD-ROM の設定に関する正しい説明

### **問題**

以下のようなエントリが `/etc/fstab` にあるとき、  
**正しい説明を3つ選びなさい。**

```fstab
/dev/cdrom /mnt/cdrom iso9660 defaults,users,noauto 0 0
```

選択肢 1. mount /mnt/cdrom コマンドでマウントできる 2. 誰でもアンマウントできる 3. マウントしたユーザしかアンマウントできない 4. 起動時に自動的にマウントされる 5. 誰でもマウントできる

⸻

正解

✅ 1. mount /mnt/cdrom コマンドでマウントできる
✅ 2. 誰でもアンマウントできる
✅ 5. 誰でもマウントできる

⸻

### 解説

/etc/fstab の構成

```
<デバイス>   <マウントポイント>  <ファイルシステム>  <マウントオプション>     <dump>  <fsck>
/dev/cdrom   /mnt/cdrom          iso9660             defaults,users,noauto  0       0
```

    -	noauto: 起動時には自動でマウントしない。
    -	users: 一般ユーザでもマウント・アンマウントが可能。
    -	defaults: 通常のデフォルトオプションを適用。

⸻

### ✅ 正解の説明

✅ 1. mount /mnt/cdrom コマンドでマウントできる - fstab に記述されていれば、マウント元・タイプが省略されても mount /mnt/cdrom でマウント可能。

✅ 2. 誰でもアンマウントできる - users オプションにより、マウントしたユーザ以外でもアンマウントが可能。

✅ 5. 誰でもマウントできる - users により、root 以外の一般ユーザもマウントが可能。

⸻

### ❌ 不正解の説明

❌ 3. マウントしたユーザしかアンマウントできない - user オプションを使用した場合はこの動作だが、
users オプションでは「誰でもアンマウント可」となる。

❌ 4. 起動時に自動的にマウントされる - noauto が指定されているため、自動マウントはされない。

⸻

### まとめ

```
選択肢	内容	正誤
mount /mnt/cdrom でマウントできる	✅ fstab 記載により可能	✅
誰でもアンマウントできる	✅ users オプションの効果	✅
マウントしたユーザしかアンマウントできない	❌ user の動作、今回は users	❌
起動時に自動マウントされる	❌ noauto により自動マウントされない	❌
誰でもマウントできる	✅ users により可能	✅
```

⸻

💡 ポイント - user → マウント/アンマウントはそのユーザのみ - users → すべての一般ユーザがマウント・アンマウント可能 - noauto → 起動時の自動マウントを無効化

✅ 「users + noauto で、誰でもマウント可能＆起動時はマウントしない設定！」

## `/etc/fstab` の第1フィールドに指定できる値

### **問題**

`/etc/fstab` の **1つ目の設定項目（第1フィールド）** に指定できる値として正しいものを **3つ** 選びなさい。

### **選択肢**

1. `defaults`
2. `/dev/sda1`
3. `ext3`
4. `UUID=3b80b96c-df15-401e-b74c-e8dcbfb68cec`
5. `LABEL=/boot`

---

### **正解**

✅ **`/dev/sda1`**  
✅ **`UUID=3b80b96c-df15-401e-b74c-e8dcbfb68cec`**  
✅ **`LABEL=/boot`**

---

### **解説**

#### ✅ `/etc/fstab` の第1フィールドとは？

- 第1フィールドは **マウントする対象（デバイスや識別子）** を指定します。
- 指定可能な値には以下が含まれます：
  - **デバイスファイル名**（例：`/dev/sda1`）
  - **UUID指定**（例：`UUID=xxxx-xxxx`）
  - **ラベル指定**（例：`LABEL=/boot`）

---

### ✅ 正しい選択肢の解説

#### ✅ `/dev/sda1`

- **直接的なデバイス名の指定**。
- 最も一般的な方法のひとつ。

#### ✅ `UUID=3b80b96c-df15-401e-b74c-e8dcbfb68cec`

- **UUID（Universal Unique Identifier）を使った指定方法**。
- `blkid` コマンドなどで確認できる。

#### ✅ `LABEL=/boot`

- **ボリュームラベルによる指定方法**。
- `tune2fs` や `e2label` で設定されたラベルを使用。

---

### ❌ 不正解の解説

#### ❌ `defaults`

- **マウントオプション**であり、**第4フィールド**に記述するもの。
- 第1フィールドには無効。

#### ❌ `ext3`

- **ファイルシステムの種類**であり、**第3フィールド**に記述される。

---

### **fstab のフィールド構成（参考）**

| フィールド番号 | 意味                   | 例                               |
| -------------- | ---------------------- | -------------------------------- |
| 第1フィールド  | デバイス名 or 識別子   | `/dev/sda1`, `UUID=`, `LABEL=`   |
| 第2フィールド  | マウントポイント       | `/`, `/boot`, `/home`            |
| 第3フィールド  | ファイルシステムの種類 | `ext4`, `xfs`, `vfat`            |
| 第4フィールド  | マウントオプション     | `defaults`, `noauto`, `ro`, など |
| 第5フィールド  | dumpバックアップ有無   | `0` または `1`                   |
| 第6フィールド  | fsck実行順序           | `0`（無効）, `1`（優先）など     |

---

### **まとめ**

| 選択肢                   | 第1フィールドとして正しいか | 説明                                    |
| ------------------------ | --------------------------- | --------------------------------------- |
| `/dev/sda1`              | ✅                          | 一般的なデバイス名                      |
| `UUID=3b80b96c-df15-...` | ✅                          | UUIDによる識別                          |
| `LABEL=/boot`            | ✅                          | ラベルによる識別                        |
| `defaults`               | ❌                          | 第4フィールド（マウントオプション）     |
| `ext3`                   | ❌                          | 第3フィールド（ファイルシステムタイプ） |

---

💡 **ポイント**

- **fstab の第1フィールドには、どのデバイスをマウントするかを記述する**
- **`/dev/～`, `UUID=～`, `LABEL=～` がよく使われる**

✅ **「fstabの第1フィールドにはデバイス指定：`/dev/sda1`, `UUID=...`, `LABEL=...`！」**

## `/etc/fstab` に関する正しい記述

### **問題**

`/etc/fstab` に関して**正しいものを2つ**選びなさい。

### **選択肢**

1. `mount -a` コマンド実行時にマウントされないマウントオプション指定は `noauto` である
2. デフォルトのマウントオプションを使用する場合は、マウントオプションの項目は記載してはいけない
3. デフォルトのマウントオプションを使用する場合は、リードオンリーでマウントされる
4. デバイス名を指定するのは、UUID と LABEL のみである
5. 項目数は 6 つである
6. 項目数は 5 つである

---

### **正解**

✅ **1. `mount -a` コマンド実行時にマウントされないマウントオプション指定は `noauto` である**  
✅ **5. 項目数は 6 つである**

---

### **解説**

#### ✅ 1. `mount -a` でマウントされない条件：`noauto`

- `noauto` オプションが指定されたエントリは、**`mount -a` 実行時でもマウントされません**。
- 明示的に `mount /マウントポイント` でマウントする必要があります。

#### ✅ 5. 項目数は 6 つである

`/etc/fstab` の各行は 6 つのフィールドで構成されます：

| フィールド番号 | 説明                                        |
| -------------- | ------------------------------------------- |
| 1              | デバイス名（例: `/dev/sda1`, `UUID=...`）   |
| 2              | マウントポイント（例: `/`, `/boot`）        |
| 3              | ファイルシステムの種類（例: `ext4`, `xfs`） |
| 4              | マウントオプション（例: `defaults`, `ro`）  |
| 5              | dump によるバックアップの有無（通常 0）     |
| 6              | fsck 実行順序（0: 実行しない, 1: ルート）   |

---

### ❌ 不正解の解説

#### ❌ 2. 「マウントオプションは記載してはいけない」

- **記載しないとマウントできないこともあるため誤り**。  
  デフォルトで良ければ `defaults` と明記する。

#### ❌ 3. 「デフォルトだとリードオンリーでマウントされる」

- **`defaults` はリード/ライト（rw）です**。リードオンリーは `ro` オプションを明示する必要があります。

#### ❌ 4. 「UUIDとLABELしか使えない」

- `/dev/sdX` などの **デバイスファイルも使用可能** なので誤り。

#### ❌ 6. 「項目数は5つ」

- 正しくは **6つ** です。

---

### **まとめ**

| 選択肢 | 内容                                  | 正誤    |
| ------ | ------------------------------------- | ------- |
| 1      | `noauto` だと `mount -a` に含まれない | ✅ 正解 |
| 2      | マウントオプションは省略不可 → 誤り   | ❌      |
| 3      | `defaults` = 読み書き可（rw） → 誤り  | ❌      |
| 4      | `/dev/sdX` なども使える → 誤り        | ❌      |
| 5      | `/etc/fstab` の項目は6つ → 正解       | ✅      |
| 6      | 項目数5つ → 誤り                      | ❌      |

---

💡 **ポイント**

- `noauto` → 明示しないとマウントされない
- `/etc/fstab` の行は必ず **6フィールド**

✅ **「`fstab` の項目数は6つ！ `noauto` は自動マウントされない！」**

## マウントされたデバイスの正しいアンマウント方法

### **問題**

次のコマンドで `/dev/sdb2` を `/data` にマウントした：

```bash
mount -t xfs /dev/sdb2 /data
```

この後、エラーを出さずに正しくアンマウントするためのコマンドを 3つ選びなさい。

選択肢1. umount -at xfs 2. umount /data /dev/sdb2 3. umount /dev/sdb2 /data 4. umount /data 5. umount /dev/sdb2

⸻

正解

✅ umount /dev/sdb2
✅ umount /data
✅ umount -at xfs

⸻

### 解説

✅ umount /dev/sdb2 - デバイス名を指定してアンマウント。- /dev/sdb2 が /data にマウントされていれば正しくアンマウントされる。

✅ umount /data - マウントポイント名を指定してアンマウント。- こちらも /dev/sdb2 を /data にマウントしていた場合、有効。

✅ umount -at xfs - -a: /etc/mtab に記載されたすべてのファイルシステムを対象 - -t xfs: ファイルシステムタイプが xfs のものだけアンマウント - この条件にマッチする /dev/sdb2 が対象となり、アンマウントされる。

⸻

### ❌ 不正解の選択肢

❌ umount /data /dev/sdb2 - 複数の引数を同時に渡すのは無効（順番の問題ではなく構文エラー）。

❌ umount /dev/sdb2 /data - 上記と同じ理由で、同時指定はエラーになる可能性がある。- 正しくは一つずつアンマウントすべき。

⸻

### まとめ

```
コマンド	内容	正解か
umount /dev/sdb2	デバイス名指定でアンマウント	✅
umount /data	マウントポイント名指定でアンマウント	✅
umount -at xfs	xfs ファイルシステム全体をアンマウント	✅
umount /data /dev/sdb2	複数指定で構文エラーの可能性	❌
umount /dev/sdb2 /data	同上	❌
```

⸻

💡 ポイント - デバイス名またはマウントポイントを個別に指定してアンマウントが安全 - umount -at xfs のようにファイルシステムタイプで一括処理も可能だが注意して使おう！

✅ 「アンマウントには /dev/sdb2, /data, -at xfs のいずれかを単独で指定！」

## `/etc/fstab` に記載されたファイルシステムをすべてマウントするコマンド

### **問題**

`/etc/fstab` ファイルに記載されている**すべてのファイルシステムをマウント**したい。  
適切な `mount` コマンドのオプションはどれか。

### **選択肢**

1. `-o`
2. `-a`
3. `-A`
4. `-ALL`
5. `-t`

---

### **正解**

✅ **`-a`**

---

### **解説**

#### ✅ `mount -a`

- **`/etc/fstab` に記載されたすべてのファイルシステムを一括でマウント**する。
- `noauto` オプションが指定されているものは除外される。
- 使用例：

```bash
sudo mount -a
```

    -	通常、起動時に行われる自動マウントと同じ動作を再現する。

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ -o - マウントオプション（rw, ro, noexec など）を指定するためのオプション。- 一括マウントの意味はない。

⸻

❌ -A - mount ではなく fsck コマンドで使用されるオプション（/etc/fstab 全体に対してファイルシステムチェックを実行）。

⸻

❌ -ALL - 無効なオプション。mount にそのような指定はない。

⸻

❌ -t - ファイルシステムの種類（ext4, xfs, vfat など）を指定するオプション。- 一括マウントではなく、タイプによるフィルタとして使う。

⸻

### まとめ

```
オプション	内容	一括マウントできるか	正解か
-a	/etc/fstab の記述に基づき全てマウント	✅	✅
-o	オプション指定（rw, roなど）	❌	❌
-A	fsck 用（fstabの全ファイルシステムチェック）	❌	❌
-ALL	存在しないオプション	❌	❌
-t	ファイルシステムタイプの指定	❌（一部対象）	❌
```

⸻

💡 ポイント - mount -a は /etc/fstab の設定に従って全てのファイルシステムをマウント！- noauto が付いているものはスキップされるので注意！

✅ 「fstab の内容を反映してマウントしたいなら mount -a！」

## デバイスの UUID を表示できるコマンド

### **問題**

デバイスの **UUID（Universal Unique Identifier）** を表示できるコマンドとして正しいものを **2つ選びなさい**。

### **選択肢**

1. `blkid`
2. `lsblk`
3. `showblk`
4. `ps`
5. `mount`

---

### **正解**

✅ **`blkid`**  
✅ **`lsblk`**

---

### **解説**

#### ✅ `blkid`

- デバイスの **UUID・LABEL・ファイルシステムの種類（TYPE）などを一覧表示**する。
- 出力例：

```bash
sudo blkid

/dev/sda1: UUID="3b80b96c-df15-401e-b74c-e8dcbfb68cec" TYPE="ext4"
/dev/sdb1: UUID="f8a9b29d-45d3-4924-a2f5-b4f0b0f0c15d" TYPE="xfs"
```

✅ UUID 表示可能！

⸻

✅ lsblk - デバイスの階層構造を表示するコマンド。- -o オプションで UUID を含めたカラム指定ができる。

```
lsblk -o NAME,UUID
```

✅ UUID 表示可能！

⸻

❌ 不正解の選択肢

❌ showblk - 存在しないコマンド。誤記。

⸻

❌ ps - プロセス一覧を表示するコマンド。- デバイス情報とは無関係。

⸻

❌ mount - マウントされたファイルシステムを表示するが、UUID は表示されない。

⸻

### まとめ

```
コマンド	UUID 表示	用途	正解か
blkid	✅	デバイスの UUID, TYPE などを表示	✅
lsblk	✅（-o指定）	デバイス構成と属性を表示（ツリー形式）	✅
showblk	❌（存在しない）	誤記	❌
ps	❌	プロセス表示	❌
mount	❌	マウント情報表示（UUIDは非表示）	❌
```

⸻

💡 ポイント - UUID の確認には blkid が王道！- lsblk -o NAME,UUID も視覚的に分かりやすくておすすめ！

✅ 「UUID を確認するなら blkid または lsblk -o NAME,UUID！」

## `/etc/fstab` に記述する SUID と SGID を有効化するマウントオプション

### **問題**

`/etc/fstab` に記述するマウントオプションで、  
**SUID（Set User ID）と SGID（Set Group ID）を有効化**するものはどれか。

### **選択肢**

1. `users`
2. `nouser`
3. `suid`
4. `exec`
5. `user`

---

### **正解**

✅ **`suid`**

---

### **解説**

#### ✅ `suid`

- **SUID（SetUID）と SGID（SetGID）を有効にするマウントオプション**。
- このオプションにより、SUID/SGID ビットが設定されたバイナリファイルは、その所有者またはグループの権限で実行されます。
- 通常はセキュリティの観点から無効にされていることもあります（特に removable メディアなどでは `nosuid` が使われる）。

##### `/etc/fstab` での例：

```fstab
/dev/sdb1  /mnt/usb  vfat  defaults,suid  0  0
```

✅ 正解！

⸻

❌ 他の選択肢の解説

❌ users - 一般ユーザがマウント/アンマウントできるようにするオプション。- SUID/SGID の有効化とは無関係。

⸻

❌ nouser - 一般ユーザがマウントできないようにするオプション（root のみ可能）。- SUIDとは関係なし。

⸻

❌ exec - バイナリ実行を許可するオプション。- スクリプトや実行ファイルの実行に関係しますが、SUID/SGID の有効化とは別です。

⸻

❌ user - users と似ているが、マウントしたユーザだけがアンマウントできるオプション。- SUID/SGID の設定には影響しません。

⸻

### まとめ

```
オプション	説明	SUID/SGID有効化	正解か
suid	SUID/SGIDを有効にする	✅	✅
users	一般ユーザのマウント許可	❌	❌
nouser	一般ユーザのマウント禁止（root のみ）	❌	❌
exec	実行可能ファイルの実行を許可	❌	❌
user	ユーザ自身がマウント・アンマウントできる	❌	❌
```

⸻

💡 ポイント - SUID/SGID を有効にしたい場合は suid オプションを使う - セキュリティ上の理由で removable メディアなどには nosuid が使われることも多い

✅ 「SUID/SGID を有効にするなら suid オプション！」

## `/etc/fstab` に記述するバイナリ実行を許可するマウントオプション

### **問題**

`/etc/fstab` に記述するマウントオプションで、  
**バイナリの実行を許可する**ものはどれか。

### **選択肢**

1. `auto`
2. `async`
3. `noauto`
4. `noexec`
5. `exec`

---

### **正解**

✅ **`exec`**

---

### **解説**

#### ✅ `exec`

- **ファイルシステム上のバイナリファイルの実行を許可するマウントオプション**。
- 通常は `defaults` に含まれるが、**USBメモリやCD-ROMなどの外部メディアではセキュリティ目的で `noexec` が使われる場合もある**。
- `exec` を明示すると、スクリプトやバイナリファイルがそのマウントポイント上で実行できるようになる。

##### `/etc/fstab` 例：

```fstab
/dev/sdb1  /mnt/usb  vfat  defaults,exec  0  0
```

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ auto - 起動時や mount -a 実行時に 自動的にマウントする オプション。- 実行可否とは無関係。

⸻

❌ async - データの読み書きを 非同期モードで処理。- 実行とは関係なし。

⸻

❌ noauto - 自動マウントをしない（手動でマウントが必要）。- auto の逆で、バイナリの実行とは関係なし。

⸻

❌ noexec - バイナリの実行を禁止するマウントオプション。- セキュリティ強化目的で使われる。

⸻

### まとめ

```
オプション	説明	バイナリ実行許可	正解か
exec	バイナリの実行を許可	✅	✅
auto	起動時の自動マウント	❌	❌
async	非同期 I/O モード	❌	❌
noauto	自動マウントを無効化	❌	❌
noexec	バイナリの実行を禁止	❌	❌
```

⸻

💡 ポイント - セキュリティ上の理由で /tmp や外部メディアには noexec が使われることが多い - 実行を許可したいなら exec、禁止したいなら noexec を使おう

✅ 「バイナリ実行を許可するには exec オプション！」

## systemd による手動マウント時の挙動

### **問題**

`/etc/fstab` に記載がなく、systemd にも認識されていないファイルシステムを  
**手動でマウントしたときの systemd の挙動**について正しいものを **2つ選びなさい**。

### **選択肢**

1. systemdは「/etc/fstab」に設定がないファイルシステムでも認識する
2. systemdが認識していないファイルシステムは、マウントユニットがないため、自動的にアンマウントされる
3. systemdは「/etc/fstab」に設定がないファイルシステムを認識せず、管理の対象外となる
4. systemdが認識していないファイルシステムは、マウントすることにより認識される

---

### **正解**

✅ **1. systemdは「/etc/fstab」に設定がないファイルシステムでも認識する**  
✅ **4. systemdが認識していないファイルシステムは、マウントすることにより認識される**

---

### **解説**

#### ✅ 1. systemdは「/etc/fstab」に設定がないファイルシステムでも認識する

- systemd は `/etc/fstab` に依存するだけでなく、**カーネルのマウント情報や `/proc/self/mountinfo` を監視**して、  
  **手動でマウントされたファイルシステムもリアルタイムで認識します**。
- そのため、`fstab` に記載されていなくても管理対象になります。

---

#### ✅ 4. systemdが認識していないファイルシステムは、マウントすることにより認識される

- **手動でマウントすると、systemd はそれを検知して管理対象に追加します**（`.mount` ユニットが動的に生成される）。
- これは `systemd` の内部的なマウント監視によるものです。

---

### ❌ 誤った選択肢

#### ❌ 2. マウントユニットがないと自動的にアンマウントされる

- **自動でアンマウントされることはありません**。  
  マウントユニットがなくても、マウント状態は保持されます。

---

#### ❌ 3. fstab に設定がないと systemd は管理しない

- **手動マウントでも systemd は動的に mount ユニットを生成して管理**します。

---

### **まとめ**

| 選択肢 | 内容                                     | 正誤 | 解説                                   |
| ------ | ---------------------------------------- | ---- | -------------------------------------- |
| 1      | fstab になくても systemd は認識する      | ✅   | カーネルやマウント状態を監視           |
| 2      | 認識されなければ自動でアンマウントされる | ❌   | 勝手にアンマウントはされない           |
| 3      | fstab にないと管理対象外                 | ❌   | 手動マウントでも systemd は管理する    |
| 4      | 手動マウントで認識されるようになる       | ✅   | mount により .mount ユニットが作られる |

---

💡 **ポイント**

- systemd は `/etc/fstab` だけでなく **動的にマウント状態を検出して管理**する。
- **`mount` コマンドでマウントされたポイントは自動的にユニットとして扱われる**。

✅ **「fstab に書かれていなくても、マウントすれば systemd は認識する！」**

## `/var/log` を `/root/systemlogs` にマウントするための適切なオプション

### **問題**

rootユーザでログイン後、すぐにログファイルのある `/var/log` にアクセスできるようにしたい。  
そのために、ログディレクトリ `/var/log` を `/root/systemlogs` にマウントしたい。

このとき使用すべき `mount` コマンドのオプションはどれか。

```bash
mount __________ /var/log /root/systemlogs
```

選択肢1. -t 2. --bind 3. -o 4. -a 5. --dir

⸻

### 正解

✅ --bind

⸻

解説

✅ --bind - mount --bind は、既存のディレクトリを別のパスに「もう一つの入り口」としてマウント（バインド）するオプション。- 実体は変わらず、同じ内容に別パスからアクセス可能になります。- 使用例：

mount --bind /var/log /root/systemlogs

    -	この状態では /root/systemlogs にアクセスすれば、実質 /var/log を参照できます。

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ -t - ファイルシステムの種類を指定するオプション（例: -t ext4）。- バインドマウントには使用しません。

⸻

❌ -o - 追加オプションを指定する際に使う（例: -o ro）。- バインドマウントに使うには -o bind とすべきだが、通常は --bind の方が明示的でわかりやすい。

⸻

❌ -a - /etc/fstab に記載されたすべてのファイルシステムをマウントするオプション。- 手動でのバインドマウントには関係ない。

⸻

❌ --dir - 無効なオプション。mount コマンドには --dir は存在しません。

⸻

### まとめ

```
オプション	説明	バインドに適切か	正解か
--bind	ディレクトリの内容を他のパスにマウント	✅	✅
-t	ファイルシステムの種類を指定	❌	❌
-o	その他のマウントオプションを指定	△（-o bindも可能）	❌
-a	/etc/fstab 全体をマウント	❌	❌
--dir	存在しないオプション	❌	❌
```

⸻

💡 ポイント - --bind で任意のディレクトリを別名アクセスできるようにする！- ログディレクトリの別パスへのマウントにも便利

✅ 「mount --bind /var/log /root/systemlogs でログにすぐアクセスできるようにしよう！」

## `/etc/fstab` による ext3 ファイルシステムの自動マウント設定

### **問題**

ext3 ファイルシステムの `/dev/sda1` を、**システム起動時に `/boot` に自動マウント**するように、  
`/etc/fstab` に記述したい。  
適切な記述はどれか（**全て選択**）。

### **選択肢**

1. `/dev/sda1 /boot ext3 defaults 1 1`
2. `/dev/sda1 /boot ext3 auto 1 1`
3. `/boot /dev/sda1 ext3 auto 1 1`
4. `/boot /dev/sda1 ext3 defaults 1 1`
5. `/dev/sda1 /boot ext3 noauto 1 1`

---

### **正解**

✅ **`/dev/sda1 /boot ext3 defaults 1 1`**  
✅ **`/dev/sda1 /boot ext3 auto 1 1`**

---

### **解説**

#### `/etc/fstab` のフィールド構成

| 項目番号 | 意味                        | 例                       |
| -------- | --------------------------- | ------------------------ |
| 1        | デバイスファイル            | `/dev/sda1`              |
| 2        | マウントポイント            | `/boot`                  |
| 3        | ファイルシステムの種類      | `ext3`                   |
| 4        | マウントオプション          | `defaults` または `auto` |
| 5        | `dump` 実行対象か（通常 0） | `1` or `0`               |
| 6        | `fsck` 実行の優先順位       | `1`（ルート）、`2`（他） |

---

### ✅ 正しい記述の理由

#### ✅ `/dev/sda1 /boot ext3 defaults 1 1`

- 一般的な形式で、**標準オプション（rw, suid, dev, exec, auto, nouser, async）**が適用される。
- 起動時に `/boot` に自動マウントされる。

#### ✅ `/dev/sda1 /boot ext3 auto 1 1`

- `auto` により、**起動時や `mount -a` 時にマウントされる**。
- 他のデフォルトオプションがない場合でも、明示的な自動マウントを指定できる。

---

### ❌ 誤った記述

#### ❌ `/boot /dev/sda1 ...`

- **フィールドの順序が間違っている**（マウントポイントとデバイス名が逆）。

#### ❌ `/dev/sda1 /boot ext3 noauto 1 1`

- `noauto` により、**起動時に自動マウントされない**ため不正解。

---

### **まとめ**

| 記述                                | 起動時に自動マウント            | フィールド順正しい | 正解か |
| ----------------------------------- | ------------------------------- | ------------------ | ------ |
| `/dev/sda1 /boot ext3 defaults 1 1` | ✅                              | ✅                 | ✅     |
| `/dev/sda1 /boot ext3 auto 1 1`     | ✅                              | ✅                 | ✅     |
| `/boot /dev/sda1 ext3 auto 1 1`     | ❌（順序誤り）                  | ❌                 | ❌     |
| `/boot /dev/sda1 ext3 defaults 1 1` | ❌（順序誤り）                  | ❌                 | ❌     |
| `/dev/sda1 /boot ext3 noauto 1 1`   | ❌（noauto = 自動マウントなし） | ✅                 | ❌     |

---

💡 **ポイント**

- **`defaults` か `auto` を使えば起動時マウント可能**
- **フィールドの順番（デバイス名 → マウントポイント）を守ることが重要**

✅ **「自動マウントしたいなら `/dev/sda1 /boot ext3 defaults 1 1` のように書こう！」**

## `/dev/hdc` を `/mnt/cdrom` にマウントするための適切なコマンド

### **問題**

CD-ROM ドライブが `/dev/hdc` として認識されており、  
それを `/mnt/cdrom` にマウントしたい。  
このエントリは **すでに `/etc/fstab` に追加済み**である。  
このとき、適切なマウントコマンドはどれか（**全て選択**）。

### **選択肢**

1. `mount`
2. `mount /mnt/cdrom`
3. `mount -t iso9660 /dev/hdc /mnt/cdrom`
4. `mount /dev/hdc`
5. `mount /mnt/cdrom /dev/hdc`

---

### **正解**

✅ **`mount -t iso9660 /dev/hdc /mnt/cdrom`**  
✅ **`mount /mnt/cdrom`**  
✅ **`mount /dev/hdc`**

---

### **解説**

#### ✅ `mount /mnt/cdrom`

- **`/etc/fstab` に該当エントリがある場合**、  
  マウントポイントを指定するだけでマウント可能。
- fstab の内容（デバイス名、ファイルシステムタイプなど）を使用してマウントされる。

---

#### ✅ `mount /dev/hdc`

- `/etc/fstab` に `/dev/hdc` のエントリがあれば、  
  その内容に基づいて適切なマウントポイント（例: `/mnt/cdrom`）にマウントされる。

---

#### ✅ `mount -t iso9660 /dev/hdc /mnt/cdrom`

- fstab に頼らず、**明示的にファイルシステムタイプとパスを指定してマウント**する方法。
- CD-ROM は通常 `iso9660` 形式のため、これが正しい指定。

---

### ❌ 誤りの選択肢

#### ❌ `mount`

- 引数なしでは単にマウント済みのファイルシステム一覧を表示するだけで、**マウント処理は実行されない**。

---

#### ❌ `mount /mnt/cdrom /dev/hdc`

- **順番が不正**。  
  正しい構文は `mount <デバイス> <マウントポイント>`  
  → `/dev/hdc` が先、`/mnt/cdrom` が後。

---

### **まとめ**

| コマンド                               | 説明                                   | 正解か |
| -------------------------------------- | -------------------------------------- | ------ |
| `mount`                                | 引数なし → マウント済みリストを表示    | ❌     |
| `mount /mnt/cdrom`                     | fstab を使ってマウント                 | ✅     |
| `mount -t iso9660 /dev/hdc /mnt/cdrom` | タイプ・パスを明示してマウント         | ✅     |
| `mount /dev/hdc`                       | fstab を使ってマウント（デバイス指定） | ✅     |
| `mount /mnt/cdrom /dev/hdc`            | **順番が逆** → 構文エラー              | ❌     |

---

💡 **ポイント**

- `/etc/fstab` にエントリがあれば、**どちらのパス（デバイス or マウントポイント）でもマウント可能**
- 明示的にマウントしたいなら `mount -t iso9660 /dev/hdc /mnt/cdrom`

✅ **「CD-ROM をマウントするなら `/mnt/cdrom` か `/dev/hdc` でOK！ `fstab` が設定されていれば簡単！」**

## 現在マウントされているファイルシステム情報が格納されているファイル

### **問題**

**現在マウントされているファイルシステムの情報**が格納されているファイルはどれか。

### **選択肢**

1. `/etc/self`
2. `/proc/mount/tab`
3. `/etc/fstab`
4. `/proc/mounts`

---

### **正解**

✅ **`/proc/mounts`**

---

### **解説**

#### ✅ `/proc/mounts`

- **現在カーネルによってマウントされているすべてのファイルシステムの一覧を表示**する仮想ファイル。
- 実際には `/proc` は仮想ファイルシステムで、`/proc/mounts` はリアルタイムなマウント情報を提供する。
- `mount` コマンドもこのファイルを参照している場合がある。

##### 内容の確認例：

```bash
cat /proc/mounts
```

✅ 正解！

⸻

❌ 不正解の選択肢の解説

❌ /etc/self - 存在しないパス。無効なファイル名。

⸻

❌ /proc/mount/tab - 存在しない仮想ファイル。正しくは /proc/mounts。

⸻

❌ /etc/fstab - 起動時や mount -a 実行時に使われる「マウント予定の定義ファイル」。- 現在のマウント状態ではなく、設定情報を持つファイル。

⸻

### まとめ

```
ファイルパス	内容	現在のマウント状態	正解か
/proc/mounts	現在マウントされている情報をカーネルから取得	✅	✅
/etc/fstab	マウントの設定定義（未来の予定）	❌	❌
/proc/mount/tab	存在しない仮想ファイル	❌	❌
/etc/self	存在しないディレクトリ	❌	❌
```

⸻

💡 ポイント - 「今」マウントされている状態を知りたいなら /proc/mounts を見よ！- cat /proc/mounts や mount コマンドで同じ情報を確認できる。

✅ 「現在のマウント情報は /proc/mounts にある！」

## 一般ユーザが USB メモリをマウントできるようにするための事前準備

### **問題**

Linux上で、一般ユーザが以下のように USB メモリをマウントしたい：

```bash
mount /mnt/usb
```

この操作を 一般ユーザが可能にするために、rootユーザとして事前に行うべき作業はどれか（2つ選択）。

選択肢 1. /etc/fstab ファイルに USB メモリのマウント設定を記述する 2. 特に事前の作業は必要ない 3. 一般ユーザでは USB メモリをマウントできない 4. USB メモリの UUID を確認し、マウント設定のデバイス名に記述する 5. USB メモリのデバイスファイルを確認し、マウント設定のデバイス名に記述する

⸻

### 正解

✅ 1. /etc/fstab ファイルに USB メモリのマウント設定を記述する
✅ 4. USB メモリの UUID を確認し、マウント設定のデバイス名に記述する

⸻

### 解説

✅ /etc/fstab にマウント設定を追加 - 一般ユーザが mount /mnt/usb を使えるようにするには、あらかじめ root が /etc/fstab に設定を記述しておく必要があります。- また、マウントオプションに user または users を指定することで、一般ユーザのマウントが許可されます。

例：

```
UUID=xxxx-xxxx  /mnt/usb  vfat  noauto,user  0  0
```

⸻

✅ UUID を使ってデバイスを正確に指定 - USB メモリは接続するたびに /dev/sdX が変わる可能性があるため、UUID を使ってデバイスを特定するのが安全。- UUID は blkid コマンドで確認可能：

sudo blkid

⸻

❌ 誤った選択肢

❌ 2. 特に事前の作業は必要ない - デフォルトでは、一般ユーザが mount コマンドを使うには権限が足りません。
/etc/fstab での設定が必要です。

⸻

❌ 3. 一般ユーザでは USB メモリをマウントできない - 適切に設定すれば 一般ユーザでもマウントは可能です。

⸻

❌ 5. デバイスファイルを直接指定するだけでは不十分 - /dev/sdX は再起動や再接続で変わる可能性があるため、UUID の方が信頼性が高い。

⸻

### まとめ

```
選択肢	内容	正誤	理由
/etc/fstab に記述する	✅	一般ユーザがマウント可能にするには必要
事前作業は不要	❌	権限エラーになる
一般ユーザはマウント不可	❌	正しく設定すれば可能
UUID を指定する	✅	再接続しても安定して識別できる
デバイス名だけ指定	❌	/dev/sdX は変更される可能性がある
```

⸻

💡 ポイント - fstab に user と noauto を指定することで、一般ユーザが明示的にマウントできるようになる - UUID を使うことで信頼性のあるマウント設定が可能

✅ 「fstab に UUID を使って記述＋user オプションを付けると一般ユーザでもマウントOK！」

## `/etc/fstab` 各項目の正しい説明

### **問題**

以下は `/etc/fstab` の内容に関する設問である。  
**各項目 (1)〜(6) の説明がすべて正しい選択肢はどれか。**

---

### **正解**

✅ **(1) デバイス名 (2) マウントポイント (3) ファイルシステムの種類 (4) マウントオプション (5) dumpフラグ (6) fsckフラグ**

---

### **解説**

#### ✅ `/etc/fstab` の各フィールドの正式な順序と説明

| フィールド番号             | 説明                                          | 例                                      |
| -------------------------- | --------------------------------------------- | --------------------------------------- |
| (1) デバイス名             | マウントするデバイスのパスまたはUUID、LABEL   | `/dev/sda1`, `UUID=xxxx`, `LABEL=home`  |
| (2) マウントポイント       | デバイスをマウントするディレクトリ            | `/`, `/boot`, `/mnt/usb`                |
| (3) ファイルシステムの種類 | 使用するファイルシステムタイプ                | `ext4`, `xfs`, `vfat`, `swap`           |
| (4) マウントオプション     | `defaults`, `noauto`, `ro`, `user` など       | `defaults`, `noexec`, `user`, etc.      |
| (5) dumpフラグ             | `dump` コマンドでバックアップするか（通常 0） | `0` or `1`                              |
| (6) fsckフラグ             | `fsck` による整合性チェックの順序             | `0`（無効）、`1`（優先）、`2`（後回し） |

---

### ❌ その他の選択肢の誤り

| 選択肢                                  | 誤っている部分                         |
| --------------------------------------- | -------------------------------------- |
| (1) マウントポイント (2) デバイス名 ... | **フィールド順が逆**                   |
| (3) マウントオプションが先に来ている    | 正しくは「ファイルシステムの種類」が先 |
| (5) fsckフラグが5番目になっている       | 正しくは6番目                          |

---

### **例：正しい `/etc/fstab` の1行**

```fstab
/dev/sda1  /boot  ext3  defaults  1  2
```

```
フィールド	値	意味
(1)	/dev/sda1	デバイス名
(2)	/boot	マウントポイント
(3)	ext3	ファイルシステムの種類
(4)	defaults	マウントオプション
(5)	1	dumpの対象（1=対象, 0=無視）
(6)	2	fsck実行順（1=ルート優先, 2=他）
```

⸻

💡 ポイント - /etc/fstab のフィールド順は固定 → 覚えておくとトラブル時に便利！- fsck の順序により、起動時のファイルシステムチェックの順番が決まる

✅ 「fstab の6項目は：デバイス名 / マウントポイント / FSタイプ / オプション / dump / fsck」！

## プログラムを所有グループの権限で実行させる方法（setgid）

### **問題**

プログラム `file` を**どのユーザが実行しても、所有グループの権限で実行**させたい。  
現在のパーミッションは `755`。  
このときに使用すべきコマンドはどれか（**全て選択**）。

---

### **正解**

✅ **`chmod g+s file`**  
✅ **`chmod 2755 file`**

---

### **解説**

#### ✅ `setgid (Set Group ID)` とは？

- **ファイルやディレクトリに対して、実行時に所有グループの権限で動作させる特殊なパーミッション**。
- 通常、プログラムは実行者のグループ権限で動作しますが、**setgid を設定すると、ファイルの所有グループで実行**されます。

---

### ✅ 正しいコマンドの説明

#### ✅ `chmod g+s file`

- **シンボリックモード**で `setgid` ビットを付加します。
- `g+s` → group に対して setgid を設定。

---

#### ✅ `chmod 2755 file`

- **数値モード**で `setgid` を付けて、他のパーミッション（`rwxr-xr-x`）を保つ。
- 先頭の `2` は **setgid ビット**を意味します。
- 結果として、パーミッションは `rwxr-sr-x` になります。

---

### ❌ 誤りの選択肢

#### ❌ `chmod u+s file`

- これは **setuid**（所有ユーザの権限で実行）です。
- 今回の目的は「**グループの権限で実行**」なので不適切。

---

#### ❌ `chmod 1755 file`

- これは **スティッキービット（sticky bit）**を設定します。
- ディレクトリのファイル削除制御などで使用され、今回の目的と無関係。

---

#### ❌ `chmod 4755 file`

- これは **setuid（ユーザIDの権限で実行）** を設定します。
- 所有ユーザで動作させる場合に使用。

---

### **まとめ**

| コマンド          | 意味                        | 正解か |
| ----------------- | --------------------------- | ------ |
| `chmod g+s file`  | グループで実行（setgid）    | ✅     |
| `chmod 2755 file` | setgid + 通常パーミッション | ✅     |
| `chmod u+s file`  | setuid（ユーザで実行）      | ❌     |
| `chmod 1755 file` | スティッキービット          | ❌     |
| `chmod 4755 file` | setuid（ユーザで実行）      | ❌     |

---

💡 **ポイント**

- グループ権限で動作させたい → **setgid（`g+s` or `2xxx`）**
- ユーザ権限で動作させたい → **setuid（`u+s` or `4xxx`）**

✅ **「グループ権限で実行させたいなら `chmod g+s` または `chmod 2xxx` を使おう！」**

## ディレクトリのパーミッションを 700 → 500 に変更する方法

### **問題**

ディレクトリ `dir` のパーミッションを  
**`700 (rwx------)` → `500 (r-x------)`** に変更したい。

このとき、適切なコマンドはどれか（**全て選択**）。

---

### **正解**

✅ **`chmod 500 dir`**  
✅ **`chmod u-w dir`**  
✅ **`chmod u=rx dir`**

---

### **解説**

#### 🎯 目標：`700` → `500`

- `700` = 所有者に **読み(r)、書き(w)、実行(x)** 権限
- `500` = 所有者に **読み(r)、実行(x)** のみ → **書き権限を外す**

---

### ✅ 各コマンドの説明

#### ✅ `chmod 500 dir`

- **数値指定で一発変更**。
- 所有者に `r-x`、その他は権限なし。
- 確実に `500` にしたいならこれがベスト。

---

#### ✅ `chmod u-w dir`

- 所有者（u）から書き権限（w）を削除。
- 元が `700`（rwx）であれば、`r-x` になり、結果的に `500` になる。

---

#### ✅ `chmod u=rx dir`

- 所有者の権限を `r` と `x` のみに明示的に設定。
- 同じく結果は `r-x`（500）になる。

---

### ❌ 誤りの選択肢

#### ❌ `chmod u=w dir`

- 所有者に **書き権限のみ（w）** を付け、読み/実行を外す → `200` になる。
- **目的と異なる動作**。

---

### **まとめ**

| コマンド         | 結果        | 意味                           | 正解か |
| ---------------- | ----------- | ------------------------------ | ------ |
| `chmod 500 dir`  | `r-x------` | 一発で目的のモードに変更       | ✅     |
| `chmod u-w dir`  | `r-x------` | 書き権限を外す                 | ✅     |
| `chmod u=rx dir` | `r-x------` | 所有者の権限を明示的に設定     | ✅     |
| `chmod u=w dir`  | `-w-------` | 書きのみ（r, x 削除） → 不正解 | ❌     |

---

💡 **ポイント**

- 書き権限を外すには `chmod u-w`
- 明示的に権限を指定したいときは `chmod u=rx`
- 数値で一発指定なら `chmod 500`

✅ **「700 → 500 にしたいなら `chmod 500 dir`, `chmod u-w dir`, `chmod u=rx dir` が使える！」**

## ファイルのパーミッションを「所有者=読み書き、他ユーザ=読みのみ」に設定する方法

### **問題**

ファイル `ping-t` のパーミッションを次のように設定したい：

- **所有者**：読み取り + 書き込み（`rw`）
- **グループ & その他のユーザ**：読み取りのみ（`r`）

このとき、適切なコマンドを **すべて選びなさい**。

---

### **正解**

✅ **`chmod 644 ping-t`**  
✅ **`chmod u=rw,go=r ping-t`**

---

### **解説**

#### 🎯 目標のパーミッション：`rw-r--r--`（= 644）

| ユーザ種別       | 権限               |
| ---------------- | ------------------ |
| 所有者 (user)    | `rw-`（読み+書き） |
| グループ (group) | `r--`（読みのみ）  |
| その他 (others)  | `r--`（読みのみ）  |

---

### ✅ 正しいコマンドの説明

#### ✅ `chmod 644 ping-t`

- 数値指定の形式。
- `6` = `rw-`（所有者）、`4` = `r--`（グループ）、`4` = `r--`（その他）
- 最も一般的な形式。

---

#### ✅ `chmod u=rw,go=r ping-t`

- シンボリックモード（記号指定）で明示的に設定。
- 所有者に `rw` を、グループ＆その他に `r` を与える。

---

### ❌ 不正解の選択肢

#### ❌ `chmod u+rw,go+r ping-t`

- 権限を**追加**するだけで、すでに他の権限がある場合はそれを**消さない**。
- 例えば、`x`（実行）権限があるとそれが**残ってしまう**ため、意図した状態と異なる可能性がある。

---

#### ❌ `chmod u-x,go-wx ping-t`

- 実行権限と書き込み権限を**削除**するだけ。
- 現在の状態が `777` のようにすべての権限がついていた場合は `644` に近づくが、正確な設定にならないことがある。

---

#### ❌ `chmod 755 ping-t`

- `755` = `rwxr-xr-x`（所有者が実行も可能、他のユーザも実行できる）
- **実行権限が含まれており、目的に反する**。

---

### **まとめ**

| コマンド                 | 結果        | 説明                                       | 正解か |
| ------------------------ | ----------- | ------------------------------------------ | ------ |
| `chmod 644 ping-t`       | `rw-r--r--` | 数値で明示的に目的の権限を指定             | ✅     |
| `chmod u=rw,go=r ping-t` | `rw-r--r--` | シンボリックモードで正確に設定             | ✅     |
| `chmod u+rw,go+r ping-t` | 状態依存    | 既存の実行権限が残る可能性あり             | ❌     |
| `chmod u-x,go-wx ping-t` | 状態依存    | `rw-r--r--` に正確に設定できないことがある | ❌     |
| `chmod 755 ping-t`       | `rwxr-xr-x` | 実行権限が不要な場合には不適切             | ❌     |

---

💡 **ポイント**

- パーミッションを**明確に指定**したいなら `chmod 644` や `chmod u=rw,go=r` を使うのが安全！
- `+` や `-` は状態に依存するため、**一貫性を保つなら `=` を使おう**

✅ **「rw-r--r-- にしたいなら `chmod 644` または `chmod u=rw,go=r` がベスト！」**

## デフォルトのパーミッションを調整する `umask` 設定

### **問題**

ファイルとディレクトリを新規作成した際のデフォルトのパーミッションを  
それぞれ以下に設定したい：

- **ファイル**：`640`（rw-r-----）
- **ディレクトリ**：`750`（rwxr-x---）

このとき、適切な `umask` の設定はどれか。

---

### **正解**

✅ **`umask 027`**

---

### **解説**

#### 🔧 `umask` とは？

- 新しいファイルやディレクトリを作成する際に、**アクセス権から引き算されるマスク値**です。
- デフォルトの**最大許可値**は以下の通り：
  - ファイル：`666`（rw-rw-rw-）
  - ディレクトリ：`777`（rwxrwxrwx）

---

### ✅ `umask 027` の意味

| マスク | 対象             | 効果                    |
| ------ | ---------------- | ----------------------- |
| 0      | 所有者 (user)    | 引かない → 全権限許可   |
| 2      | グループ (group) | 書き込み権限（w）を削除 |
| 7      | その他 (others)  | すべての権限を削除      |

- **結果的なパーミッションの例：**

| 種類         | 計算式            | 実際のパーミッション |
| ------------ | ----------------- | -------------------- |
| ファイル     | `666 - 027 = 640` | `rw-r-----`          |
| ディレクトリ | `777 - 027 = 750` | `rwxr-x---`          |

✅ **目的どおり！**

---

### ❌ その他の選択肢

| umask | ファイル | ディレクトリ | 不適切な理由                                       |
| ----- | -------- | ------------ | -------------------------------------------------- |
| `025` | 642      | 752          | グループに書き込み不可だが、その他に読み取りが残る |
| `640` | ✖︎      | ✖︎          | 不正な値（8進数ではない）                          |
| `777` | 000      | 000          | すべての権限を奪う                                 |
| `022` | 644      | 755          | その他にも読み取り実行が許可されてしまう           |

---

### **まとめ**

| 設定例      | 目的のパーミッションに合致？ | コメント                  |
| ----------- | ---------------------------- | ------------------------- |
| `umask 027` | ✅                           | 最適な設定                |
| `umask 022` | ❌                           | others にも実行権限が付く |
| `umask 025` | ❌                           | others に読み取りが残る   |
| `umask 777` | ❌                           | 全権限を剥奪する          |

---

💡 **ポイント**

- `umask` は「最大値」から「引かれる値」
- **ファイル作成時は実行権（x）は自動的に付きません！**
- 目的に応じたパーミッションを逆算して `umask` を設計するのがコツ！

✅ **「640 / 750 にしたいなら `umask 027` を使おう！」**

## 「ping-t」ファイルのパーミッションを 644 → 755 に変更する方法

### **問題**

ファイル `ping-t` のパーミッションを **644（rw-r--r--）** から  
**755（rwxr-xr-x）** に変更したい。  
このとき、適切なコマンドをすべて選びなさい。

---

### **正解**

✅ **`chmod 755 ping-t`**  
✅ **`chmod a+x ping-t`**  
✅ **`chmod a=rx,u+w ping-t`**

---

### **解説**

#### 🎯 目標：644 → 755

| 権限種別 | 644（変更前） | 755（変更後） |
| -------- | ------------- | ------------- |
| 所有者   | `rw-`         | `rwx`         |
| グループ | `r--`         | `r-x`         |
| その他   | `r--`         | `r-x`         |

つまり、「**すべてに実行権（x）を追加**」し、  
**所有者には書き込み（w）を維持**したままにします。

---

### ✅ 正しいコマンドの説明

#### ✅ `chmod 755 ping-t`

- パーミッションを一発で数値指定。
  - `7 = rwx`（所有者）
  - `5 = r-x`（グループ）
  - `5 = r-x`（その他）

✅ 一番確実で簡単な方法！

---

#### ✅ `chmod a+x ping-t`

- **すべてのユーザーに実行権（x）を追加**。
- 現在の状態（644）に `+x` を加えると `755` になる。

⚠️ ただし、**元の権限が 644 のときに限って有効**。

---

#### ✅ `chmod a=rx,u+w ping-t`

- `a=rx`: 全ユーザーの権限を一度「読み+実行」に設定（書き込み削除）
- `u+w`: 所有者に書き込み（w）を追加

→ 結果的に `u=rwx`, `g=rx`, `o=rx` → **755**

---

### ❌ 不正解のコマンド

#### ❌ `chmod a-x ping-t`

- **すべての実行権を削除する** → `644` より下がってしまう  
  ❌ 正反対の動作！

---

#### ❌ `chmod a=rx,u-w ping-t`

- 実行権を追加するが、**所有者の書き込み権を削除してしまう**
  → 所有者が `r-x` になり、目的の `rwx` にならない。

---

### **まとめ**

| コマンド                | 効果                       | 755 になるか  | 正解か |
| ----------------------- | -------------------------- | ------------- | ------ |
| `chmod 755 ping-t`      | 数値で一発指定             | ✅            | ✅     |
| `chmod a+x ping-t`      | 実行権だけ追加             | ✅（644前提） | ✅     |
| `chmod a=rx,u+w ping-t` | 読み+実行にして書き追加    | ✅            | ✅     |
| `chmod a-x ping-t`      | 実行権を削除               | ❌            | ❌     |
| `chmod a=rx,u-w ping-t` | 書き込み権を削除してしまう | ❌            | ❌     |

---

💡 **ポイント**

- **`755` = 所有者：読み・書き・実行、他ユーザ：読み・実行**
- `+x` は便利だけど、元のパーミッションに注意！

✅ **「755にしたいなら `chmod 755` が最も確実！」**

## 所有グループを `test` → `staffgroup` に変更するコマンド

### **問題**

ファイル `file.txt` の**所有者はそのままにして、所有グループのみを `test` から `staffgroup` に変更**したい。  
このとき、適切なコマンドはどれか（**すべて選択**）。

---

### **正解**

✅ **`chown :staffgroup file.txt`**  
✅ **`chgrp staffgroup file.txt`**  
✅ **`chown .staffgroup file.txt`**

---

### **解説**

### ✅ `chgrp staffgroup file.txt`

- `chgrp` は **グループのみを変更する専用コマンド**。
- 最もシンプルで直感的。

```bash
chgrp staffgroup file.txt
```

⸻

✅ chown :staffgroup file.txt - chown コマンドは通常「所有者:グループ」を変更するが、
:グループ の形式で指定すればグループのみ変更できる。

chown :staffgroup file.txt

⸻

✅ chown .staffgroup file.txt - . は古い形式（Unix系）でグループ指定。
: と同じように機能する。

chown .staffgroup file.txt

⸻

❌ 不正解の選択肢

❌ chgrp :staffgroup file.txt - chgrp において : の使用は無効。正しい構文ではありません。

⸻

❌ chgrp test staffgroup file.txt - test はファイル名の誤指定になるためエラー。
構文が間違っています（第1引数にファイル名ではなくグループ名が必要）。

⸻

❌ chown staffgroup file.txt - これは 所有者を staffgroup に変更しようとする動作。- グループではなくユーザの変更になり、目的と異なる。

⸻

### まとめ

```
コマンド	グループのみ変更	説明	正解か
chgrp staffgroup file.txt	✅	専用コマンドで明示的	✅
chown :staffgroup file.txt	✅	所有者は変更せずグループのみ変更	✅
chown .staffgroup file.txt	✅	: と同等の古い表記	✅
chgrp :staffgroup file.txt	❌	不正な構文	❌
chgrp test staffgroup file.txt	❌	引数の順序がおかしい	❌
chown staffgroup file.txt	❌	所有「ユーザ」を変更	❌
```

⸻

💡 ポイント - グループだけ変えたいときは chgrp または chown :グループ名！- . と : は一部環境では同等に扱われるが、: を使うのが現代的！

✅ 「グループ変更だけなら chgrp または chown :group！」

## `/etc/passwd` ファイルのパーミッションと所有者

### **問題**

Linux の `/etc/passwd` ファイルの**正しいパーミッションと所有者**はどれか。

---

### **正解**

✅ **`-rw-r--r--. 1 root root`**

---

### **解説**

#### ✅ `/etc/passwd` とは？

- **システム上のすべてのユーザー情報を格納しているファイル**。
- 各ユーザの名前、UID、GID、ホームディレクトリ、ログインシェルなどを記載。
- 認証情報（パスワードのハッシュなど）は `/etc/shadow` に分離されている。

---

### ✅ 正しい属性の詳細

| 属性         | 説明                                                               |
| ------------ | ------------------------------------------------------------------ |
| `-rw-r--r--` | 所有者：読み書き可、グループ＆他ユーザ：読み取りのみ               |
| `1`          | ハードリンク数（通常は 1）                                         |
| `root root`  | 所有者が `root`、グループも `root`                                 |
| `.`          | SELinux のセキュリティコンテキストが有効なことを示す（無視してOK） |

---

### ❌ 誤った選択肢の解説

#### ❌ `-rw-------. 1 root root`

- 他ユーザが読めない → システムがユーザー情報を参照できなくなる。

#### ❌ `-rw-r--r--. 1 sys sys`

- 所有者とグループが `sys` → 標準的な設定ではない。

#### ❌ `-rw-rw-rw-. 1 root root` または `1 sys sys`

- **誰でも書き込み可能** → セキュリティリスク大！

---

### ✅ `/etc/passwd` の確認コマンド

```bash
ls -l /etc/passwd
```

出力例：

```
-rw-r--r--. 1 root root 1934 Mar 20 07:20 /etc/passwd
```

⸻

💡 ポイント - /etc/passwd はシステム全体が参照できる必要がある → 読み取りは全ユーザに必要 - 書き込みは root のみに制限！

✅ 「/etc/passwd は -rw-r--r--. 1 root root が正解！」

## ディレクトリ内の他人のファイル削除を防ぐ方法（スティッキービット）

### **問題**

`dir` ディレクトリ内で、**自分以外のユーザが所有するファイルを削除できないようにしたい**。  
ディレクトリの現在のパーミッションは `755`。  
適切なコマンドはどれか（**すべて選択**）。

---

### **正解**

✅ **`chmod 1755 dir`**  
✅ **`chmod o+t dir`**

---

### **解説**

#### ✅ スティッキービット（Sticky Bit）とは？

- ディレクトリに対して設定する特殊なビット。
- **所有者以外のユーザによるファイル削除を防ぐ**ために使う。
- よく `/tmp` などの共有ディレクトリで使用される。

---

### ✅ 各コマンドの意味

#### ✅ `chmod 1755 dir`

- `1` は **スティッキービット**。
- `755`（`rwxr-xr-x`）に追加すると、**パーミッションは `rwxr-xr-t`** となる。

```bash
chmod 1755 dir
```

⸻
✅ chmod o+t dir - o+t は other ユーザに対してスティッキービットを付ける記法。- 結果として rwxr-xr-t になる。

chmod o+t dir

✅ どちらも スティッキービットを付ける正しい方法です。
⸻

❌ 誤りの選択肢の解説

❌ chmod g+s file - setgid をファイルに設定 → グループ権限で実行される - 削除制限とは関係なし

⸻

❌ chmod 2755 file - ファイルに setgid を付加 → ファイル実行におけるグループ権限制御 - 今回の目的とは無関係

⸻

❌ chmod u+s file - setuid をファイルに設定 → ユーザ権限で実行される - これも削除制限とは無関係

⸻

### まとめ

```
コマンド	効果	正解か
chmod 1755 dir	スティッキービットを追加（数値）	✅
chmod o+t dir	スティッキービットを追加（記号）	✅
chmod g+s file	ファイルに setgid（削除制限に関係なし）	❌
chmod 2755 file	ファイルに setgid	❌
chmod u+s file	ファイルに setuid	❌
```

⸻

💡 ポイント - スティッキービット（sticky bit） は 「削除制限」 に関係あり！- rwxr-xr-t の t がスティッキービットの印

✅ 「他人のファイルを削除させたくないなら chmod o+t dir または chmod 1755 dir！」

## ファイルの所有ユーザのみを変更するコマンド

### **問題**

ファイル `file.txt` の所有ユーザを `test` から `staff` に変更したい。  
ただし、**所有グループは変更しない**。

適切なコマンドはどれか。

---

### **正解**

✅ **`chown staff file.txt`**

---

### **解説**

#### ✅ 正しいコマンド

```bash
chown staff file.txt
```

    -	ユーザ名だけを指定した場合、所有グループは変更されずそのまま残ります。
    -	ファイルの所有者が staff に変更され、所有グループは以前のままです。

⸻

❌ 誤りの選択肢の解説

```
コマンド	動作・問題点	正誤
chown test staff file.txt	構文エラー（存在しない書式）	❌
chown staff test file.txt	構文エラー（存在しない書式）	❌
chown staff:test file.txt	グループを test に変更してしまう	❌
chown test:staff file.txt	ユーザを test、グループを staff に変更してしまう	❌
```

    -	ユーザとグループを同時に指定する場合は、必ず ユーザ:グループ の形式で指定します。
    -	グループを変更したくない場合は : を使わず、ユーザ名だけを指定します。

⸻

### まとめ

    -	所有ユーザのみ変更：

✅ chown staff file.txt - 所有ユーザとグループを同時に変更する場合：

chown staff:staffgroup file.txt

    -	グループのみ変更の場合：

- chown :staffgroup file.txt
  または
- chgrp staffgroup file.txt

⸻

💡 ポイント - 所有ユーザだけを変更するなら、ユーザ名のみ指定でOK。- グループ変更を避けたいなら、: は使わない！

✅ 「ユーザのみを変更するなら chown staff file.txt が正解！」

## 所有グループのみを変更できるコマンド

### **問題**

指定したファイルまたはディレクトリの**所有グループのみ**を変更するためのコマンドはどれか。  
ただし、所有ユーザは変更できないコマンドとする。

---

### **正解**

✅ **`chgrp`**

---

### **解説**

### ✅ **`chgrp` コマンド**

- **ファイルやディレクトリの所有グループを変更する専用のコマンド**。
- 所有者（ユーザ）は変更できないため、グループだけを変更したいときに便利。

#### **使い方の例**

```bash
chgrp staffgroup file.txt
```

これにより、ファイルの所有グループだけが staffgroup に変更されます。
所有者（ユーザ）はそのまま維持されます。

⸻

❌ 誤ったコマンドの説明

```
コマンド	説明	正誤
chowner	存在しないコマンド	❌
chmod	パーミッションの変更コマンド	❌
chgroup	存在しないコマンド	❌
chown	所有ユーザとグループを変更する	❌
```

    -	chown はユーザ・グループを同時に変更できますが、グループだけ変更したい場合は : を使って指定します（例：chown :staff file.txt）。
    -	グループだけを変更する専用コマンドは chgrp のみです。

⸻

### まとめ

```
コマンド	所有グループ変更	所有ユーザ変更	備考	正解か
chgrp	✅	❌	グループのみ変更可能	✅
chown	✅	✅	ユーザ・グループ変更可能	❌
chmod	❌	❌	パーミッション変更のみ	❌
chowner	❌	❌	存在しない	❌
chgroup	❌	❌	存在しない	❌
```

⸻

💡 ポイント - 所有グループのみ変更 → chgrp - 所有ユーザも変更可能 → chown

✅ 「グループ変更だけなら chgrp を使おう！」

## ディレクトリ内で作成したファイルの所有グループを自動的に設定する方法（setgid）

### **問題**

以下は「work」ディレクトリのパーミッションである。

```bash
# ls -ld work
drwxrwxr-x. 2 staff staff 4096 Mar 18 14:13 work
```

「work」ディレクトリ内に新しく作成するファイルやディレクトリの所有グループが自動的に staff になるようにしたい。

このために実行すべきコマンドを2つ選びなさい。

⸻

### 正解

- ✅ chmod g+s work
- ✅ chmod 2775 work

⸻

### 解説

✅ setgid（Set Group ID）の意味 - ディレクトリに setgid を設定すると、そのディレクトリ内で新しく作成したファイルやサブディレクトリの所有グループが親ディレクトリのグループと同じになるという動作になります。- チーム内で共有ディレクトリを管理するときに非常に便利な機能です。

⸻

✅ 正しいコマンドの説明

✅ chmod g+s work - シンボリックモードを使った setgid 設定。- グループの実行権限に加えて、グループ継承属性（setgid）を付加します。- 結果的なパーミッションは：drwxrwsr-x

実行例：

chmod g+s work

✅ chmod 2775 work - 数値モードでの設定。- 先頭の「2」が setgid ビットを表します。- 結果として、同様に drwxrwsr-x となります。

実行例：

chmod 2775 work

⸻

❌ 誤りの選択肢の解説

```
コマンド	説明	正誤
chmod o+t work	スティッキービット（所有者以外削除禁止）設定	❌
chmod 4775 work	ファイルに対するsetuidの設定	❌
chmod u+s work	setuid（所有ユーザで実行する権限）設定	❌
```

    -	今回の目的は「所有グループを継承する」ことであり、これらの選択肢は適切ではありません。

⸻

### まとめ

```
コマンド	動作内容（目的）	正解か
chmod g+s work	setgidを設定（グループ継承）	✅
chmod 2775 work	setgidを数値で設定（グループ継承）	✅
chmod o+t work	スティッキービット（削除制限）	❌
chmod 4775 work	setuid（ユーザ権限で実行）	❌
chmod u+s work	setuid（所有者権限で実行）	❌
```

⸻

💡 ポイント - ディレクトリ内の新規ファイルやディレクトリのグループを統一するには setgid！- シンボリックモードなら g+s、数値モードなら「2」で設定できます。

✅ 「グループ継承には chmod g+s または chmod 2xxx を使おう！」

## ディレクトリに適用された権限に関する正しい説明

### **問題**

ディレクトリに適用した権限について、正しい説明はどれか（**2つ選択**）。

### **選択肢**

1. 実行権限があるディレクトリ内の内容を参照できる
2. 書き込み権限があるディレクトリ内で、ファイルやディレクトリを作成・削除できる
3. 書き込み権限があるディレクトリのファイルを実行できる
4. 読み取り権限があるディレクトリに移動できる
5. 実行権限があるディレクトリに移動できる

---

### **正解**

✅ **2. 書き込み権限があるディレクトリ内で、ファイルやディレクトリを作成・削除できる**  
✅ **5. 実行権限があるディレクトリに移動できる**

---

### **解説**

#### ✅ 2. 書き込み権限があるディレクトリ内で、ファイルやディレクトリを作成・削除できる

- ディレクトリに `w`（書き込み）権限があると、
  - **新規ファイルやディレクトリの作成**
  - **既存ファイルの削除・名前変更** が可能。
- ただし、中身の一覧表示には `r` 権限が必要。

---

#### ✅ 5. 実行権限があるディレクトリに移動できる

- ディレクトリの `x`（実行）権限は、**そのディレクトリに「入る」ことを許可**します。
- つまり `cd ディレクトリ名` が可能。

---

### ❌ 不正解の選択肢

#### ❌ 1. 実行権限があるディレクトリ内の内容を参照できる

- **中のファイル一覧を表示するには `r`（読み取り）権限が必要**。
- `x` だけでは内容は参照できない。

#### ❌ 3. 書き込み権限があるディレクトリのファイルを実行できる

- **ファイルの実行可否はそのファイルのパーミッションで決まる**。
- ディレクトリの `w` 権限は関係ない。

#### ❌ 4. 読み取り権限があるディレクトリに移動できる

- **移動（`cd`）には `x`（実行）権限が必要**。
- `r` だけでは移動できない。

---

### **まとめ表**

| 選択肢 | 内容                                   | 正誤 | 解説                                      |
| ------ | -------------------------------------- | ---- | ----------------------------------------- |
| 1      | 実行権限で内容を参照できる             | ❌   | 参照には `r` が必要                       |
| 2      | 書き込み権限で作成・削除が可能         | ✅   | `w` で中のファイル/ディレクトリを操作可能 |
| 3      | 書き込み権限でファイルを実行できる     | ❌   | 実行可否はファイルのパーミッション次第    |
| 4      | 読み取り権限でディレクトリに移動できる | ❌   | 移動には `x` が必要                       |
| 5      | 実行権限でディレクトリに移動できる     | ✅   | `x` があれば `cd` が可能                  |

---

💡 **ポイント**

- `r`：中身を「見る（一覧表示）」
- `w`：中身を「編集（作成・削除）」
- `x`：中に「入る（移動する）」

✅ **「移動には `x`、操作には `w`、一覧表示には `r` が必要！」**

## ディレクトリのハードリンク作成に関する正しい理解

### **問題**

`/home/test` ディレクトリのハードリンクを  
`/home/testlink` という名前で作成したい。

適切なコマンドはどれか。

---

### **選択肢**

1. `ln /home/testlink /home/test`
2. `ln -s /home/testlink /home/test`
3. `ln /home/test /home/testlink`
4. **ディレクトリのハードリンクは作成できない**
5. `ln -s /home/test /home/testlink`

---

### **正解**

✅ **4. ディレクトリのハードリンクは作成できない**

---

### **解説**

#### ❗ ハードリンクとは？

- ハードリンクは、**同じ inode 番号を持つ別名ファイル**を作る機能です。
- 通常、**ファイルに対してのみ使用される**。
- ファイルが削除されても、他のハードリンクが存在すればデータは保持されます。

---

### 🚫 ディレクトリにハードリンクを作成できない理由

- Linux/UNIX では、**ディレクトリへのハードリンク作成は禁止**されています（特権的なシステム操作を除く）。
- 理由：**ディレクトリ構造の循環を防ぎ、ファイルシステムの整合性を保つため**。
- 通常ユーザーは **`ln /some/dir /some/other`** のようなコマンドではエラーになります。

---

### ✅ ディレクトリをリンクしたい場合

- **シンボリックリンク（ソフトリンク）を使用するのが一般的**

```bash
ln -s /home/test /home/testlink
```

このコマンドは /home/testlink を /home/test へのショートカットのように扱えるリンクとして作成します。

⸻

❌ 他の選択肢の誤り

```
選択肢	誤りの理由
ln /home/testlink /home/test	順序が逆（リンク元→リンク先）かつ対象がディレクトリ
ln -s /home/testlink /home/test	リンク元とリンク先の意味が逆
ln /home/test /home/testlink	ディレクトリへのハードリンクは作れない
ln -s /home/test /home/testlink	正しいが、シンボリックリンクの話であり、今回は「ハードリンク」が問われているため不正解
```

⸻
✅ 結論

```
項目	可否	備考
ファイルのハードリンク	✅	ln file1 file2
ディレクトリのハードリンク	❌	通常は不許可
ディレクトリのシンボリックリンク	✅	ln -s dir linkname
```

⸻
💡 ポイント - ディレクトリにハードリンクは作れない（管理上・構造上の理由）- 代わりにシンボリックリンクを使おう！

✅ 「ディレクトリにハードリンクは作れない！必要なら ln -s を使おう」

## シンボリックリンクの特徴として正しいもの

### **問題**

シンボリックリンクの説明として正しいものはどれか（**全て選択**）。

---

### **選択肢**

1. 元ファイルを削除するとリンクファイルは削除される
2. `ls` コマンドで確認するとパーミッションの先頭に「l」が表示される
3. シンボリックリンクは inode 番号が同じ
4. 異なったファイルシステム間でも作成可能
5. ディレクトリのシンボリックリンクを作成できない

---

### **正解**

✅ **2. `ls` コマンドで確認するとパーミッションの先頭に「l」が表示される**  
✅ **4. 異なったファイルシステム間でも作成可能**

---

### **解説**

#### ✅ 2. `ls` コマンドで確認するとパーミッションの先頭に「l」が表示される

- シンボリックリンクは `ls -l` で表示すると、パーミッションの先頭が `l` になります。

```bash
lrwxrwxrwx  1 user user     9 Mar 22  testlink -> /etc/hosts
```

⸻

✅ 4. 異なったファイルシステム間でも作成可能 - シンボリックリンクは パス情報を記録しているだけなので、- 異なるファイルシステム上のファイルやディレクトリにもリンク可能です。

⸻

❌ 誤りの選択肢

❌ 1. 元ファイルを削除するとリンクファイルは削除される - リンクファイル自体は削除されません。- ただし、**リンク先が存在しない「壊れたリンク」**になるだけです。

⸻

❌ 3. シンボリックリンクは inode 番号が同じ - シンボリックリンクは 別のファイルとして扱われるため、- 元ファイルと inode 番号は異なります。

⸻

❌ 5. ディレクトリのシンボリックリンクを作成できない - ディレクトリにもシンボリックリンクは作成可能です。- 実際に ln -s /etc /tmp/etc-link などで作成可能。

⸻

### まとめ

```
選択肢番号	内容	正誤	解説
1	元ファイルを削除するとリンクも削除される	❌	リンクは残るが「壊れたリンク」になる
2	lsで先頭に「l」が表示される	✅	シンボリックリンクであることを示す
3	inode 番号が同じ	❌	別ファイルなので inode は異なる
4	異なるファイルシステム間でも作成可能	✅	実体ではなく「パス」を参照しているため
5	ディレクトリのシンボリックリンクは作れない	❌	ディレクトリにも普通に作成できる
```

⸻

💡 ポイント - シンボリックリンクは「パスのショートカット」のような存在 - 異なるファイルシステム・ディレクトリでも自由に作成可能

✅ 「シンボリックリンクは柔軟！l で確認、壊れても残る」

## ハードリンクに関する正しい説明

### **問題**

ハードリンクの説明として正しいものはどれか（**全て選択**）。

---

### **選択肢**

1. 同じファイルの実体を指す全てのハードリンクは inode 番号が同じ
2. 一つしか作ることができない
3. ディレクトリのハードリンクを作成できる
4. ファイルシステムが異なると作成できない
5. 複数のハードリンクのうち 1 つを削除するとファイルの実体も削除される

---

### **正解**

✅ **1. 同じファイルの実体を指す全てのハードリンクは inode 番号が同じ**  
✅ **4. ファイルシステムが異なると作成できない**

---

### **解説**

#### ✅ 1. 同じファイルの実体を指す全てのハードリンクは inode 番号が同じ

- ハードリンクは、**元ファイルと同じ inode 番号を持つ、別名のエントリ**です。
- ファイルシステム上では、**全てが同じ「実体（inode）」を参照**しています。

```bash
ls -li file1 file2
# → 同じ inode 番号が表示される
```

⸻

✅ 4. ファイルシステムが異なると作成できない - ハードリンクは 同じファイルシステム内でのみ有効です。- 異なるファイルシステムにまたがってリンクすることはできません（カーネルが禁止しています）。

⸻

❌ 誤りの選択肢

❌ 2. 一つしか作ることができない - ハードリンクは 1 つだけでなく、複数作成可能です。- 1つのファイルに対して、**任意の数（リンク数上限まで）**作成できます。

⸻

❌ 3. ディレクトリのハードリンクを作成できる - 一般ユーザーはディレクトリに対してハードリンクを作成できません。- これは ファイルシステムの循環構造を防ぐために制限されています。

⸻

❌ 5. 複数のハードリンクのうち 1 つを削除するとファイルの実体も削除される - 実体（inode）は、すべてのハードリンクが削除されたときにのみ削除されます。- 1つ削除しても、他にリンクが残っていればデータは保持されます。

⸻

### まとめ

```
選択肢番号	内容	正誤	解説
1	同じファイルを指すハードリンクは inode 番号が同じ	✅	全てのハードリンクが同じ inode を共有
2	ハードリンクは 1 つしか作れない	❌	制限はなく、複数作成可能
3	ディレクトリのハードリンクは作成できる	❌	一般ユーザーは作成不可（セキュリティ制限）
4	異なるファイルシステム間では作成できない	✅	ファイルシステム内限定の機能
5	ハードリンクの 1 つを削除すると実体も削除される	❌	最後のリンクが削除されるまで実体は残る
```

⸻

💡 ポイント - ハードリンクは「同じファイルを別名で参照する」仕組み - 同じ inode、異なる名前 - 削除してもリンクが残っていればファイルは生き続ける！

✅ 「ハードリンク＝inode 共有、他 FS やディレクトリには NG！」

## ハードリンクを使ったファイル削除後の動作

### **問題**

`File1` というファイルが存在する状態で、以下のコマンドを実行した。  
このときの動作として**正しいもの**はどれか。

```bash
$ ln File1 File2
$ rm -f File1
```

⸻

選択肢1. File1は削除され、File2はアクセス不可となる2. File1とFile2が削除される3. File1の削除時に確認メッセージが表示される4. File1は削除され、同じ中身のFile2は残る

⸻

正解

✅ 4. File1は削除され、同じ中身のFile2は残る

⸻

解説

✅ ln File1 File2 - これは ハードリンクの作成。- File1 と File2 は 同じ inode（ファイルの実体）を指す別名になります。- つまり 中身は1つ、名前が2つ。

✅ rm -f File1 - File1 という 名前（リンク）を削除します。- しかし、File2 が同じ inode を参照しているため、ファイルの中身（実体）は削除されません。

⸻

🔎 実際の確認方法

```
$ echo "Hello" > File1
$ ln File1 File2
$ ls -li File1 File2
# → 同じ inode 番号が表示される

$ rm -f File1
$ cat File2
Hello  ← ファイルの内容が残っている！
```

⸻

❌ 他の選択肢の誤り

選択肢 誤りの理由

1. File2はアクセス不可となる ハードリンクなので File2 も実体を指しており 残る
2. 両方削除される File2 は削除していないため 残る
3. 確認メッセージが出る -f オプションにより確認なしで削除される
   ⸻

✅ ハードリンクの特性まとめ

項目 内容
node番号 元ファイルとリンクファイルは 同じ inode 番号を持つ
削除動作 すべてのハードリンクが削除されるまで実体は残る
ファイル内容 どちらから変更しても中身は同じ
⸻

💡 ポイント - ハードリンクは「同じファイルに複数の名前をつける」方法 - どれか1つを削除しても、他が残っていれば中身は消えない！

✅ 「ln File1 File2 の後に rm File1 をしても、File2 は使える！」

## `ln fileA fileB` 実行時に変化するもの・変化しないもの

### **問題**

以下のコマンドを実行した場合：

```bash
ln fileA fileB
```

変化するもの：変化しないもの の正しい組み合わせはどれか。

⸻

選択肢1. 何も変わらない2. inode番号：lsコマンドによるパーミッションの先頭表示3. lsコマンドによるパーミッションの先頭表示：inode番号4. ハードリンク数：lsコマンドによるパーミッションの先頭表示5. inode番号：ハードリンク数

⸻

### 正解

✅ 4. ハードリンク数：lsコマンドによるパーミッションの先頭表示

⸻

### 解説

✅ ln fileA fileB の意味 - これは fileA に対してハードリンク fileB を作成するコマンド。- fileA と fileB は同じ inode（ファイルの実体）を共有します。

⸻

✅ 変化するもの

✅ ハードリンク数 - 新たに別名（fileB）が inode に追加されるため、- inode のリンク数（link count）が 1 増加します。- ls -l の左から 2 番目の数字がリンク数。

⸻

❌ 変化しないもの

❌ パーミッションの先頭表示（ls -l の最左の文字列）- これはファイルの種類とアクセス権を表示している部分。- ハードリンクを作成しても アクセス権やファイル種別は変わらない。

⸻

🔍 実際の確認方法

```
$ echo "test" > fileA
$ ls -li fileA
123456 -rw-r--r-- 1 user user 5 Mar 23 10:00 fileA  ← リンク数 1

$ ln fileA fileB
$ ls -li fileA fileB
123456 -rw-r--r-- 2 user user 5 Mar 23 10:00 fileA
123456 -rw-r--r-- 2 user user 5 Mar 23 10:00 fileB  ← 同じ inode, リンク数2
```

⸻

❌ 他の誤答の理由

選択肢 誤りの理由

1. 何も変わらない ハードリンク数は変化する
2. inode番号：lsコマンドの先頭表示 inode番号は変わらない
3. lsコマンドの先頭表示：inode番号 両方変わらない
4. inode番号：ハードリンク数 inode番号は変わらず、リンク数が変わる（逆）
   ⸻

### ✅ まとめ

```
項目	変化するか？	理由
inode 番号	❌	同じ inode を共有するため変化なし
パーミッション表示	❌	内容に変更がないため変化なし
ハードリンク数	✅	新たなリンクが増えるため +1
```

⸻

💡 ポイント - ln でハードリンクを作ると inode は そのまま、リンク数は 増える - ls -li を使えば inode 番号やリンク数を確認できる！

✅ 「ln fileA fileB → ハードリンク数が増える、パーミッション表示は変わらない」

## 空白を含むファイル名を扱う `find` + `xargs` の組み合わせ

### **問題**

名称が `dir` で始まるディレクトリ（例：`dir 1`, `dir 2`）を検索し、  
その検索結果を `xargs` で `ls -R` に渡したい。

空白文字を含む名前にも対応できるように、以下のコマンドの下線部に入れるべきアクションはどれか？

```bash
find . -name "dir*" _____ | xargs -0 ls -R
```

⸻

選択肢1. -depth 2. -null0 3. -print0 4. -print

⸻

正解

✅ 3. -print0

⸻

### 解説

🔍 なぜ -print0 が必要か？- 通常の find コマンド出力は 改行区切りです。- ファイル名にスペース（空白）が含まれていると、区切りと誤認識されて正しく処理されません。

✅ -print0 は、ファイル名の出力をヌル文字（NULL：\0）で区切る - この出力は xargs -0 と組み合わせることで安全に処理できます。

find . -name "dir\*" -print0 | xargs -0 ls -R

    -	xargs -0 は ヌル文字で区切られた入力を安全に読み込む。
    -	これにより、スペースや改行を含む名前でも正しく引数として渡されます。

⸻

### ❌ その他の選択肢

```
選択肢	誤りの理由
-depth	ディレクトリを 階層の深い順に処理するオプション。文字列の区切りとは無関係。
-null0	存在しないオプション。タイポ。
-print	改行で区切られる → スペースや改行を含む名前は不適切。
```

⸻

### ✅ まとめ

```
オプション	意味	適しているか
-print0	ファイル名を NULL 文字で出力	✅
-depth	深い階層から検索処理（出力形式に無関係）	❌
-null0	無効なオプション	❌
-print	改行区切り → 空白文字や特殊文字に弱い	❌
```

⸻

💡 ポイント - スペース・改行を含むファイル名を処理する場合は -print0 + xargs -0！- シェルスクリプトや自動処理で使う際は 安全性を確保するために必須の組み合わせ

✅ 「スペースを含むファイル名も安心！ -print0 と xargs -0 のセットが鉄則」

## `updatedb` コマンドの設定ファイル

### **問題**

`updatedb` コマンドの**設定ファイル**は次のうちどれか？

---

### **選択肢**

1. `/etc/locatedb.conf`
2. `/etc/updatedb.conf`
3. `/etc/locate.conf`
4. `/etc/which.conf`
5. `/etc/update.conf`

---

### **正解**

✅ **2. `/etc/updatedb.conf`**

---

### **解説**

#### 🔍 `updatedb` とは？

- `updatedb` は `locate` コマンドで使用される **検索データベースを作成・更新するコマンド**。
- 通常は `cron` や `systemd.timer` によって定期的に実行されます。
- 作成されたデータベースは、`locate` コマンドで超高速検索を可能にします。

---

#### ✅ 設定ファイル：`/etc/updatedb.conf`

- このファイルでは以下のような設定が可能です：

| 設定項目            | 説明                                          |
| ------------------- | --------------------------------------------- |
| `PRUNEFS`           | 無視するファイルシステムの種類（例：`tmpfs`） |
| `PRUNEPATHS`        | データベース作成時に除外するディレクトリパス  |
| `PRUNE_BIND_MOUNTS` | バインドマウントの除外（yes/no）              |

#### 📌 例：

```bash
PRUNEPATHS="/tmp /var/tmp /var/cache"
```

⸻

❌ 誤った選択肢の解説

選択肢 理由
/etc/locatedb.conf 存在しないファイル名
/etc/locate.conf 存在しないファイル名
/etc/which.conf which コマンドにも設定ファイルはない
/etc/update.conf update という設定用途ではない
⸻

✅ コマンドと設定の対応

コマンド 設定ファイル
updatedb /etc/updatedb.conf
locate 設定ファイルなし（updatedb が作成したDBを使う）
⸻

💡 ポイント - updatedb は locate 用のデータベースを更新するコマンド - 設定ファイルは /etc/updatedb.conf で、除外ディレクトリなどを制御できる！

✅ 「locate の高速検索を支える裏側は updatedb、設定は /etc/updatedb.conf！」

## 所有者が特定ユーザ（test）のファイルやディレクトリを検索する方法

### **問題**

`/home` ディレクトリ配下にある、**所有者が `test` ユーザ**のファイルやディレクトリを検索したい。  
このとき、適切なコマンドはどれか。

---

### **選択肢**

1. `find /home -owner test`
2. `find -print test /home`
3. `find /home -user test`
4. `find -user test /home`
5. `find /home -name test`

---

### **正解**

✅ **3. find /home -user test**

---

### **解説**

#### ✅ `find` コマンドの基本構文

```bash
find [検索ディレクトリ] [検索条件]
```

✅ -user オプション

- 指定したユーザ名が所有者であるファイルやディレクトリを検索します。

find /home -user test

    -	/home 以下にある、所有者が test のすべてのファイル・ディレクトリが対象になります。

⸻

❌ 誤りの選択肢の解説

❌ 1. find /home -owner test

- -owner は正しいオプションではありません（実在しない）。

❌ 2. find -print test /home

- 構文が不正。-print はオプションであり、検索条件やパスではない。
- 正しい順序は find /home [条件]。

❌ 4. find -user test /home

- オプションとパスの順番が逆で構文エラーになります。
- find は 検索開始ディレクトリを先に指定する必要があります。

❌ 5. find /home -name test

- -name は「ファイル名が test に一致するもの」を探すオプション。
- 所有者とは無関係。

⸻

✅ 補足：-user の代わりに UID も使える

find /home -uid 1001

    -	上記のように UID（ユーザID）でも検索可能です。

⸻

💡 ポイント

- 所有者で検索：-user ユーザ名
- グループで検索：-group グループ名
- パスは先に、オプションは後に！

✅ 「所有者検索は find /ディレクトリ -user ユーザ名！」

## `find`コマンドで階層数を指定して検索する

### **問題**

`find` コマンドでファイルを検索する際、**検索するディレクトリの階層数を指定**したい。  
このとき、適切な検索式（オプション）はどれか。（**全て選択**）

---

### **選択肢**

- -max
- -depth
- -min
- -maxdepth
- -mindepth

---

### **正解**

- -maxdepth
- -mindepth

---

### **解説**

#### ✅ `-maxdepth`

- 検索を**指定した階層数までに制限**します。
- 例：`-maxdepth 1` → カレントディレクトリとその直下のみを検索。

#### ✅ `-mindepth`

- 検索を**指定した階層数以上から開始**します。
- 例：`-mindepth 2` → カレントディレクトリとその1階層下はスキップし、それより下を検索。

---

### ❌ その他の選択肢について

#### ❌ `-max`

- 無効なオプション。`find` には存在しません。

#### ❌ `-min`

- 無効なオプション。`find` には存在しません。

#### ❌ `-depth`

- **深い階層から順に検索**するだけで、**階層数を制限するオプションではありません**。

---

💡 **ポイント**

- **検索範囲を制御するには `-maxdepth` と `-mindepth` を使う！**
- `-depth` は削除操作などで使われる「順序制御」のオプション。

✅ **「検索階層を指定するなら `-maxdepth` / `-mindepth`！」**

## 一般ユーザ用コマンドが格納されているディレクトリ

### **問題**

システムの起動には必須ではない、**一般ユーザ用のコマンド**が格納されているディレクトリは次のうちどれか？

---

### **選択肢**

- /bin
- /usr/sbin
- /usr/bin
- /sbin
- /usr/lib

---

### **正解**

- /usr/bin

---

### **解説**

#### ✅ `/usr/bin`

- 一般ユーザが利用するアプリケーションコマンドが多数格納されているディレクトリ。
- **システム起動時には必須ではない**が、ユーザーがログイン後に使う多くのコマンド（例：`ls`, `vim`, `python`, `gcc` など）がここにある。

---

### ❌ 他の選択肢の解説

#### ❌ `/bin`

- 基本的なシステムコマンド（`cp`, `mv`, `rm`, `cat` など）が置かれる。
- **システム起動時やレスキューモードでも必要なコマンド**が含まれる。

#### ❌ `/sbin`

- 管理者向けのシステム管理用コマンド（`shutdown`, `reboot`, `fdisk` など）。
- 一般ユーザ向けではない。`root` が使うもの。

#### ❌ `/usr/sbin`

- `/sbin` と同様に **システム管理者用コマンド**を格納。
- こちらも一般ユーザ向けではなく、起動後の設定・管理に使われる。

#### ❌ `/usr/lib`

- ライブラリファイル（プログラムが利用する.soファイルなど）を格納。
- **実行ファイルではない**ため、コマンドは含まれていない。

---

### ✅ まとめ

| ディレクトリ | 用途                           | 起動必須 | 一般ユーザ用 |
| ------------ | ------------------------------ | -------- | ------------ |
| `/bin`       | 基本コマンド                   | ✅       | 一部あり     |
| `/sbin`      | システム管理コマンド（root用） | ✅       | ❌           |
| `/usr/bin`   | 一般ユーザ用アプリケーション群 | ❌       | ✅           |
| `/usr/sbin`  | root向けシステム管理コマンド   | ❌       | ❌           |
| `/usr/lib`   | ライブラリ群（.soなど）        | ❌       | ❌           |

---

💡 **ポイント**

- 一般ユーザが使うコマンドの多くは **`/usr/bin` にある**
- **起動に必須なのは `/bin`, `/sbin`**
- `/usr/bin` は、**起動後の通常利用に必要な場所**

✅ **「一般ユーザ用のコマンドは `/usr/bin`！」**

## 実行ファイルの場所を表示するコマンド（PATHに基づく）

### **問題**

環境変数 `PATH` に基づいて、  
**指定したコマンドの実行ファイルの場所を表示するコマンド**はどれか。（**2つ選択**）

---

### **選択肢**

- type
- grep
- locatedb
- which
- whereis

---

### **正解**

- type
- which

---

### **解説**

#### ✅ `which` コマンド

- `PATH` に設定されたディレクトリを順に検索し、  
  **指定されたコマンドがどのパスに存在するかを表示**します。
- 単純に「どこにあるか」を知りたいときに便利。

```bash
which ls
# /bin/ls
```

⸻

✅ type コマンド

- bash の内部コマンド。
- 指定されたコマンドが どのようなタイプか（ビルトインか、関数か、外部コマンドか） を判定。
- PATH による検索も行うため、実行ファイルのパスも表示される。

```
type ls
ls is /bin/ls
```

⸻

❌ 誤りの選択肢

❌ grep

- テキスト検索ツールであり、ファイル検索やコマンドの場所とは無関係。

❌ locatedb

- コマンドではなくファイル（locate コマンドが利用するデータベース名）。
- locate はファイル名から探すが、PATH は無関係。

❌ whereis

- which に似ているが、PATH だけでなくマニュアルやソースファイルの場所まで検索する。
- /bin, /usr/bin など固定的なパスを探索し、環境変数 PATH を使わない。

⸻

### ✅ まとめ

```
コマンド	PATH に基づく検索	その他の特徴	適切か
which	✅	実行パスのみ表示	✅
type	✅	ビルトインかどうかも判定	✅
whereis	❌（固定ディレクトリ）	マニュアル・ソースも検索	❌
grep	❌	テキスト検索	❌
locatedb	❌	locate のデータベースファイル名	❌
```

⸻

💡 ポイント

- PATH に基づいてコマンドの場所を知りたいなら which or type！
- type はシェル関数やビルトインまで判別できてより高機能！

✅ 「どこにある？→ which！どういうもの？→ type！」

## 高速なファイル検索を行うコマンド（検索用データベース使用）

### **問題**

検索用データベースを使用して、  
**高速でファイル検索を行うコマンド**は次のうちどれか？

---

### **選択肢**

- whereis
- which
- locate
- find
- updatedb

---

### **正解**

✅ **locate**

---

### **解説**

#### ✅ `locate` コマンド

- 事前に作成された **検索用データベース（`mlocate.db`など）** を使用して、  
  ファイル名に一致するパスを**超高速で検索**します。
- データベースは `updatedb` コマンドにより定期更新されます。

```bash
locate bashrc
# /home/user/.bashrc
# /etc/skel/.bashrc
```

    -	メリット：
    -	非常に速い（find のように毎回ファイルシステムをスキャンしない）
    -	デメリット：
    -	データベースが古いと、最新の状態と一致しない可能性がある

⸻

### ❌ 他の選択肢の解説

```
コマンド	用途	locate との違い
find	実際にディレクトリを再帰的に探索	正確だが遅い（リアルタイム検索）
which	PATH にあるコマンドの場所を表示	コマンドの検索専用
whereis	実行ファイル、ソース、マニュアルを検索	データベース未使用、限定された検索範囲
updatedb	locate 用のデータベースを更新	検索自体ではなく、準備を行うコマンド
```

⸻

### ✅ locate に関する補足

```
コマンド	説明
locate	データベースをもとにファイル名で高速検索
updatedb	データベース（例：/var/lib/mlocate/mlocate.db）を作成・更新
locate -i	大文字小文字を区別せずに検索
locate -c	一致件数のみを表示
```

⸻

💡 ポイント

- ファイルを 名前で高速に検索したいときは locate！
- 最新の状態で検索したいなら find、スピード重視なら locate！

✅ 「高速検索なら locate、正確検索なら find！」

## `cp` コマンドのパスを調べる方法

### **問題**

`cp` コマンドの**実行ファイルの場所（パス）**を表示したい。  
適切なコマンドはどれか。（**2つ選択**）

---

### **選択肢**

- whichis cp
- whereis cp
- where cp
- man cp
- which cp

---

### **正解**

- which cp
- whereis cp

---

### **解説**

#### ✅ `which cp`

- `PATH` 環境変数に基づいて、**最初に見つかった `cp` コマンドの絶対パス**を表示。

```bash
which cp
# /bin/cp
```

⸻

✅ whereis cp

- cp に関する情報を複数の場所から表示。
- 実行ファイル
- マニュアルファイル（man）
- ソースコード（あれば）

```
whereis cp
# cp: /bin/cp /usr/share/man/man1/cp.1.gz
```

⸻

### ❌ その他の選択肢の解説

```
コマンド	説明	理由
whichis cp	存在しないコマンド。タイポ。	❌
where cp	存在しないコマンド。PowerShell にはあるが、Linux にはない。	❌
man cp	cp のマニュアルを表示するだけで、パスは表示しない。	❌
```

⸻

### ✅ まとめ

```
コマンド	用途	結果例
which cp	PATH に基づく最初のパスを表示	/bin/cp
whereis cp	実行ファイル・manページ・ソースの場所	/bin/cp 他
man cp	cp のマニュアルを表示	説明のみ
```

⸻

💡 ポイント

- シンプルに実行パスだけなら → which
- マニュアルの場所や複数情報もほしいなら → whereis

✅ 「コマンドの場所を調べるなら which、より広く調べるなら whereis！」

## `find` コマンドで検索結果に対して処理を実行する方法

### **問題**

`find` コマンドで検索したファイルに対して、  
**コマンドを実行**したい。

このときの `find` コマンドの**適切なアクション**はどれか？

---

### **選択肢**

- -eargs
- -execute
- -exec
- -xargs
- -e

---

### **正解**

✅ **-exec**

---

### **解説**

#### ✅ `-exec` アクション

- `find` で検索されたファイルに対して、**任意のコマンドを実行**できます。
- 書式：

```bash
find [検索パス] [条件] -exec [コマンド] {} \;
```

    -	{} は見つかったファイルのパスに置き換えられます。
    -	\; は -exec の終了を示す必要があります（バックスラッシュが必要）。

例：見つかった .log ファイルを削除

```
find /var/log -name "*.log" -exec rm {} \;
```

⸻

### ❌ 他の選択肢の誤り

```
オプション	誤りの理由
-eargs	存在しないオプション
-execute	古い find に存在した場合もあるが一般的ではない
-xargs	find のオプションではない（パイプで使う別コマンド）
-e	find に存在しないオプション
```

⸻

✅ -exec vs xargs

```
方法	特徴
-exec	find だけで完結。安全性高いが遅め。
xargs	パイプと組み合わせて高速処理可能。ただしスペースや特殊文字に注意が必要。
```

⸻

💡 ポイント

- find で検索してすぐ何かを実行したいなら -exec 一択
- スペースや特殊文字にも安全に対応

✅ 「検索と処理を1つで完結するなら -exec を使おう！」

## `find` コマンドでファイルサイズを条件に検索する方法

### **問題**

`find` コマンドでファイルを検索する際に、  
**ファイルのサイズを検索条件として使用**したい。

このとき、適切な検索式はどれか？

---

### **選択肢**

- -minsize
- -msize
- -size
- -fsize
- -maxsize

---

### **正解**

✅ **-size**

---

### **解説**

#### ✅ `-size` オプション

- ファイルサイズを条件に検索できます。
- 書式：

```bash
find [検索パス] -size [+|-]サイズ単位
```

📌 使用例：

- find . -size +10M
  → 10MB より大きいファイルを検索

- find . -size -100k
  → 100KB より小さいファイルを検索

- find . -size 0
  → サイズが0のファイル（空ファイル）を検索

⸻

単位の指定方法

```
単位	意味
c	バイト数
k	キロバイト
M	メガバイト
G	ギガバイト
なし	512バイトブロック単位（デフォルト）
```

⸻

❌ 誤りの選択肢

```
オプション	誤りの理由
-minsize	存在しないオプション
-msize	存在しないオプション
-fsize	存在しないオプション
-maxsize	存在しないオプション
```

⸻

💡 ポイント

- ファイルサイズを条件にしたいときは必ず -size
- - → より大きい、- → より小さい、指定なし → ちょうど

✅ 「サイズで検索＝-size！単位付きで直感的に使える！」

## `find` コマンドの `-print0` アクションの説明

### **問題**

`find` コマンドの `-print0` アクションについて、  
**正しく説明しているもの**はどれか？

---

### **選択肢**

- 検索結果を NULL 文字で区切って表示する
- 検索結果を表示させない
- そのようなアクションは存在しない
- 省略可能なアクション

---

### **正解**

✅ **検索結果を NULL 文字で区切って表示する**

---

### **解説**

#### ✅ `-print0` とは？

- `find` の出力を **NULL 文字（`\0`）で区切って表示**するアクション。
- 通常は改行で区切られるが、ファイル名にスペースや改行が含まれていると誤動作する可能性があるため、  
  **安全なデータ処理のために `-print0` が使われます**。

#### 📌 よく一緒に使うコマンド：

```bash
find . -name "*.txt" -print0 | xargs -0 rm
```

    -	xargs -0 は NULL 区切りに対応しており、

安全にファイル名を渡すことができます。

⸻

### ❌ 誤った選択肢の解説

```
選択肢	解説
検索結果を表示させない	-print0 は出力します（NULL 区切りで）
そのようなアクションは存在しない	存在します。GNU find で広く使用されます
省略可能なアクション	明示的に書かなければ NULL 区切りにならないので省略不可
```

⸻

✅ -print vs -print0

```
オプション	区切り文字	向いている用途
-print	改行	通常の出力（シンプルだが不安定な場面も）
-print0	NULL文字	スペース・改行を含むファイル名に強い
```

⸻

💡 ポイント

- スペースや特殊文字を含むファイル名を扱うなら -print0！
- xargs -0 と セットで使うと最強！

✅ 「安全にファイル名を扱いたいなら -print0 + xargs -0 を使おう！」

## コマンド本体・マニュアル・ソースの場所を検索するコマンド

### **問題**

指定したコマンド、またそのマニュアルやソースコードが格納されている場所を検索し、  
**絶対パスで表示するコマンド**はどれか？

---

### **選択肢**

- locate
- whereis
- which
- where
- whichis

---

### **正解**

✅ **whereis**

---

### **解説**

#### ✅ `whereis` コマンド

- 指定したコマンドに関する以下の情報を**まとめて絶対パスで表示**します：
  - 実行ファイルの場所
  - man（マニュアル）ページの場所
  - ソースコードの場所（ある場合）

#### 📌 使用例

```bash
whereis ls
# ls: /bin/ls /usr/share/man/man1/ls.1.gz
```

⸻

### ❌ その他の選択肢の解説

```
コマンド	内容	誤りの理由
locate	ファイル名を検索データベースから探す	コマンドやman情報、ソースの場所は表示しない
which	PATH にある最初の実行ファイルのパスを表示	実行ファイルのみ対象
where	Linuxには存在しない（WindowsやPowerShellのコマンド）	❌
whichis	存在しないコマンド（タイポと思われる）	❌
```

⸻

### ✅ whereis のオプション例

```
オプション	説明
-b	バイナリ（実行ファイル）のみ表示
-m	マニュアルのみ表示
-s	ソースファイルのみ表示
```

⸻

💡 ポイント

- 実行ファイル・マニュアル・ソースをまとめて探すなら whereis！
- which よりも広範囲に調べてくれる

✅ 「コマンド関連のファイルを一括で調べるなら whereis！」

## PATH に依存せずコマンドの場所を検索できるコマンド

### **問題**

環境変数 `PATH` の値に関係なく、  
**指定したコマンドの実行ファイルの場所を検索できるコマンド**はどれか。（**3つ選択**）

---

### **選択肢**

- ls
- locate
- find
- which
- whereis

---

### **正解**

- locate
- whereis
- find

---

### **解説**

### ✅ `locate`

- `updatedb` コマンドによって作成された **検索用データベース**を使って、高速にファイルパスを検索します。
- `PATH` 環境変数は使わず、**ファイル名の一部で検索**します。

```bash
locate bash
# /bin/bash などが表示される可能性あり
```

⸻

✅ whereis

- コマンドの 実行ファイル / マニュアル / ソース を探すツール。
- 独自の検索パスを使っており、PATH に依存せず探せます。

whereis cp

# cp: /bin/cp /usr/share/man/man1/cp.1.gz

⸻

✅ find

- ファイルシステムを 実際にスキャンしてファイルを見つけます。
- PATH は関係なく、検索開始ディレクトリとファイル名で探索します。

find / -name cp 2>/dev/null

⸻

❌ 誤った選択肢

❌ ls

- ファイルやディレクトリの中身を一覧表示するコマンド。
- 検索機能はない。

❌ which

- PATH に登録されたディレクトリを使って検索。
- PATH に含まれていない場所には対応していない。

⸻

✅ 比較表

```
コマンド	PATH を使うか	実ファイル検索	高速	特徴
locate	❌	❌（DB使用）	✅	超高速。名前ベースの曖昧検索が得意
whereis	❌（固定ディレクトリ）	❌	✅	実行ファイル・man・ソースも探す
find	❌	✅	❌	最も正確。時間がかかる
which	✅	✅	✅	PATH にある最初の実行ファイルのみ
ls	❌	❌	—	ファイル一覧表示であり、検索機能はない
```

⸻

💡 ポイント

- PATH に依存しない検索 → locate、whereis、find
- スピード優先：locate／正確さ優先：find／広範囲探索：whereis

✅ 「PATHに依存せずコマンド探すなら → locate / whereis / find！」

## `find`コマンドで改行区切りで検索結果を表示する方法

### **問題**

`find` コマンドでファイルを検索する際、  
**検索結果を改行区切りで表示するアクション**はどれか？

---

### **選択肢**

- -printpath
- -printlf
- -p
- -print
- -print0

---

### **正解**

✅ **-print**

---

### **解説**

#### ✅ `-print` アクション

- `find` の標準的な出力方法で、**検索されたファイルやディレクトリを1行ずつ（改行区切り）で表示**します。
- 実は、検索アクションを省略した場合も `-print` がデフォルトで使われます。

```bash
find . -name "*.txt" -print
```

    -	出力例：

```
./memo.txt
./docs/report.txt
```

⸻

### ❌ 他の選択肢の解説

```
オプション	状態	理由
-printpath	❌ 無効	存在しないオプション
-printlf	❌ 無効	存在しないオプション
-p	❌ 無効	find のオプションとしては存在しない
-print0	✅ ただし改行ではない	出力を NULL 文字（\0）で区切る。xargs -0 と併用する
```

⸻

✅ 比較：-print と -print0

```
アクション	区切り	用途例
-print	改行	通常の人間向け出力。デフォルト。
-print0	NULL文字	ファイル名にスペースが含まれていても安全に処理したいとき。xargs -0 とセットで使う。
```

⸻

💡 ポイント

- 通常の検索結果表示には -print（または省略）
- スクリプト等でファイル名の特殊文字に強くしたい場合は -print0

✅ 「検索結果を改行で出すなら -print！」

## ホスト固有で全ユーザが使うプログラムの**設定ファイル**の保存場所

### **問題**

全てのユーザが使用できるプログラムを作成した。  
そのプログラムは **このホストでのみ使用**する。

このとき、**プログラムの設定ファイルを格納するディレクトリ**として適切なのはどれか？

---

### **選択肢**

- /usr/local/bin
- /usr/share/man
- /usr/local/etc
- /usr/bin
- /usr/share/doc

---

### **正解**

✅ **/usr/local/etc**

---

### **解説**

#### ✅ `/usr/local/etc`

- ホスト固有でローカルにインストールしたプログラムの**設定ファイルを格納するための標準的な場所**。
- `local` ディレクトリは「**管理者がこのマシンだけに導入したソフトウェア**」を意味する。
- `etc` は設定ファイル格納用。

---

### ❌ 他の選択肢の説明

| ディレクトリ     | 用途                                     | 理由                                          |
| ---------------- | ---------------------------------------- | --------------------------------------------- |
| `/usr/local/bin` | ローカルインストールされた実行バイナリ   | ❌ 実行ファイル用で、設定ファイル向きではない |
| `/usr/share/man` | マニュアルページ（manコマンドで使用）    | ❌ ドキュメント用                             |
| `/usr/bin`       | 一般の実行ファイル（OSやパッケージ提供） | ❌ ローカル管理のものではない                 |
| `/usr/share/doc` | ドキュメント（READMEなど）               | ❌ 設定ファイルではなく、ドキュメント向け     |

---

### ✅ 一般的なディレクトリ構成の例

| 目的         | 推奨ディレクトリ       |
| ------------ | ---------------------- |
| 実行バイナリ | `/usr/local/bin`       |
| 設定ファイル | `/usr/local/etc`       |
| ライブラリ   | `/usr/local/lib`       |
| マニュアル   | `/usr/local/share/man` |
| ドキュメント | `/usr/local/share/doc` |

---

💡 **ポイント**

- **`/usr/local/` は管理者がローカルに追加したものの置き場**
- 実行ファイル → `bin`、設定ファイル → `etc`、文書 → `doc`

✅ **「ホスト限定＆全ユーザ用プログラムの設定ファイルは `/usr/local/etc`！」**

## ホスト固有で全ユーザが使う**バイナリファイル**の格納場所

### **問題**

全てのユーザが使用できるプログラムを、**バイナリ形式の実行ファイルとして作成**した。  
そのプログラムは **このホストでのみ使用**する。

このとき、**バイナリを格納するディレクトリ**として適切なものはどれか？

---

### **選択肢**

- /usr/share/man
- /usr/local/bin
- /usr/sbin
- /usr/bin
- /usr/local/etc

---

### **正解**

✅ **/usr/local/bin**

---

### **解説**

#### ✅ `/usr/local/bin`

- **管理者がこのホスト専用にインストールしたユーザ用コマンド（実行可能ファイル）**を格納する標準的な場所。
- ここに配置したプログラムは、`PATH` にも含まれているため、全ユーザがコマンドとして実行できます。

---

### ❌ 他の選択肢の解説

| ディレクトリ     | 用途                             | 理由                                              |
| ---------------- | -------------------------------- | ------------------------------------------------- |
| `/usr/share/man` | マニュアルページの格納先         | ❌ 実行ファイル用ではない                         |
| `/usr/sbin`      | 管理者用のシステム管理コマンド   | ❌ 一般ユーザ向けバイナリの格納先ではない         |
| `/usr/bin`       | パッケージやOS付属の実行ファイル | ❌ ローカル（手動）管理用ではない                 |
| `/usr/local/etc` | ローカルな設定ファイル           | ❌ 設定ファイル用の場所で、実行ファイルは入れない |

---

### ✅ 一般的な分類まとめ

| 用途                     | ディレクトリ             |
| ------------------------ | ------------------------ |
| **ローカル実行ファイル** | `/usr/local/bin`         |
| システム実行ファイル     | `/usr/bin`               |
| 管理者用実行ファイル     | `/usr/sbin`              |
| 設定ファイル             | `/etc`, `/usr/local/etc` |
| マニュアル               | `/usr/share/man`         |

---

💡 **ポイント**

- ホスト独自＆全ユーザに公開 → **`/usr/local/bin`**
- `/usr/local/` はシステム管理者が後から追加したプログラムを管理するための領域

✅ **「ホスト限定で全ユーザが使う実行ファイルは `/usr/local/bin` に配置しよう！」**
