---
author: Taro Gray
pubDatetime: 2025-01-31T08:00:00.000Z
title: デバイス、Linuxファイルシステム、FHS (主題104)編
postSlug: lpic1-device-file-system
featured: true
ogImage: https://github.com/satnaing/astro-paper/assets/53733092/1ef0cf03-8137-4d67-ac81-84a032119e3a
tags:
  - Linux
description: デバイス、Linuxファイルシステム、FHS (主題104)編
---

## `parted` を使用して MBR 形式の新しいハードディスクにパーティションを作成する方法

### **問題**

`parted` を使用して、新しいハードディスクに以下の要件の通りパーティションを作成した。

- **先頭に 1000MB の基本パーティションを作成**
- **ファイルシステムは ext4**
- **パーティションテーブルは MBR 形式**

次のコマンドのうち、**正しくパーティションを作成するために必要なものを選びなさい**。（**全て選択**）

### **選択肢**

1. `mklabel gpt`
2. `print`
3. `mkpart primary ext4 1 1000MB`
4. `mklabel mbr`
5. `mklabel msdos`
6. `create ext4 1 1000MB`
7. `show`
8. `mkpart 1 1000MB`

---

### **正解**

✅ **`mklabel msdos`**  
✅ **`print`**  
✅ **`mkpart primary ext4 1 1000MB`**

---

### **解説**

#### **1. `mklabel msdos`**

- **MBR 形式のパーティションテーブルを作成するコマンド**。
- MBR（Master Boot Record）形式のパーティションテーブルを作成するために必要。
- `msdos` は MBR の別名。

✅ **正解！**

⸻

#### **2. `print`**

- **現在のパーティションテーブルの状態を確認するコマンド**。
- 作成したパーティションが正しく認識されているか確認するために使用。

✅ **正解！**

⸻

#### **3. `mkpart primary ext4 1 1000MB`**

- **1000MB の基本（primary）パーティションを作成するコマンド**。
- `mkpart primary <ファイルシステム> <開始位置> <終了位置>` の形式で指定。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mklabel gpt`**

- **GPT（GUID Partition Table）形式のパーティションテーブルを作成するコマンド**。
- 問題では **MBR 形式** のパーティションテーブルを作成するため **不正解**。

⸻

❌ **`create ext4 1 1000MB`**

- **`parted` にこのようなコマンドは存在しない**。
- **パーティションを作成する場合は `mkpart` を使用する**。

⸻

❌ **`mklabel mbr`**

- **`parted` では MBR 形式のパーティションテーブルを作成する場合、`mklabel msdos` を使用する**。
- `mklabel mbr` というコマンドは **存在しない**。

⸻

❌ **`show`**

- **`parted` には `show` というコマンドは存在しない**。
- パーティション情報を確認するには **`print`** を使用する。

⸻

❌ **`mkpart 1 1000MB`**

- `mkpart` コマンドの **書式が間違っている**。
- 正しくは **`mkpart primary ext4 1 1000MB`**。

⸻

### **まとめ**

| コマンド                         | 目的                                               | 正解か |
| -------------------------------- | -------------------------------------------------- | ------ |
| **mklabel msdos**                | **MBR（msdos）形式のパーティションテーブルを作成** | ✅     |
| **print**                        | **パーティションの状態を確認**                     | ✅     |
| **mkpart primary ext4 1 1000MB** | **1000MB の基本パーティションを作成**              | ✅     |
| mklabel gpt                      | GPT（GUID Partition Table）形式を作成              | ❌     |
| create ext4 1 1000MB             | 無効なコマンド                                     | ❌     |
| mklabel mbr                      | 無効なコマンド                                     | ❌     |
| show                             | 無効なコマンド                                     | ❌     |
| mkpart 1 1000MB                  | 書式が間違っている                                 | ❌     |

⸻

💡 **ポイント**

- **MBR 形式を指定するには `mklabel msdos`**
- **パーティション作成は `mkpart primary ext4 1 1000MB`**
- **パーティション確認には `print`**
- **GPT 形式（`mklabel gpt`）は今回のケースでは不適切！**

✅ **「parted で MBR のパーティションを作成するなら `mklabel msdos` → `mkpart primary ext4 1 1000MB` → `print` で確認！」**

## `fdisk -l /dev/sda` の出力からスワップ領域のパーティションを特定する

### **問題**

以下は、コマンド `fdisk -l /dev/sda` の表示結果からの抜粋である。  
**パーティションタイプがスワップ領域のパーティション** はどれか。

### **選択肢**

1. `/dev/sda1`
2. `/dev/sda5`
3. `/dev/sda2`
4. `/dev/sda6`

---

### **正解**

✅ **`/dev/sda6`**

---

### **解説**

`fdisk -l /dev/sda` コマンドは、指定したディスク `/dev/sda` のパーティションテーブルを表示します。各パーティションの詳細情報には、**パーティション番号**、**開始位置**、**終了位置**、**サイズ**、**タイプ**などが含まれます。

**スワップ領域**として使用されるパーティションは、通常、**パーティションタイプが `82`**（`Linux swap`）に設定されています。以下に、`fdisk -l /dev/sda` の出力例を示します。

```
Disk /dev/sda: 100 GB, 100000000000 bytes
255 heads, 63 sectors/track, 12158 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
```

```
Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1        1045     8385861   83  Linux
/dev/sda2            1046        2090     8385862+  83  Linux
/dev/sda3            2091        3135     8385862+  83  Linux
/dev/sda4            3136        3187      418492+   5  Extended
/dev/sda5            3136        3187      418460   82  Linux swap / Solaris
```

上記の例では、`/dev/sda5` のパーティションタイプが `82`（`Linux swap / Solaris`）となっており、**スワップ領域**として使用されることがわかります。

**注意点**：

- **パーティションタイプ `82`** は、**スワップ領域**を示します。
- **パーティションタイプ `83`** は、**Linuxファイルシステム**（`ext4` など）を示します。
- **パーティションタイプ `5`** は、**拡張パーティション**を示します。

したがって、`fdisk -l /dev/sda` の出力を確認し、**パーティションタイプが `82`** に設定されているパーティションを探すことで、**スワップ領域**として使用されているパーティションを特定できます。

---

### **まとめ**

- **スワップ領域のパーティションタイプ**：`82`（`Linux swap`）
- **`fdisk -l` コマンドの出力**を確認し、**パーティションタイプが `82`** のパーティションを探す
- **正解**：`/dev/sda6`（パーティションタイプが `82` の場合）

---

💡 **ポイント**

- **`fdisk -l` コマンド**でディスクのパーティション情報を確認できる
- **スワップ領域**のパーティションタイプは**`82`**
- **パーティションタイプ**を確認して、**スワップ領域**を特定しよう！

✅ **「`fdisk -l` でパーティションタイプ `82` を探せば、スワップ領域がわかる！」**

## `mkfs` または `mke2fs` コマンドで不良ブロックを検査してからファイルシステムを作成する方法

### **問題**

`mkfs` または `mke2fs` コマンドでファイルシステムを作成する際、**不良ブロックがないか検査してから作成** したい。  
適切なオプションを選びなさい。

### **選択肢**

1. `-a`
2. `-k`
3. `-c`
4. `-s`
5. `-e`

---

### **正解**

✅ **`-c`**

---

### **解説**

`mkfs` や `mke2fs` コマンドでファイルシステムを作成する際に、**不良ブロック（bad blocks）を事前に検査するには `-c` オプションを使用** します。

#### **1. `-c` オプションの意味**

- **不良ブロックをチェックしてからファイルシステムを作成**
- **事前に `badblocks` コマンドを実行し、壊れたブロックをマーク**
- 例：
  ```bash
  mkfs.ext4 -c /dev/sdb1
  ```
  または

```
mke2fs -c /dev/sdb1
```

✅ 正解！

⸻

誤った選択肢の解説

❌ -a - mkfs コマンドや mke2fs には -a オプションは 存在しない。- 間違い！

⸻

❌ -k - mke2fs -k は、既存のスーパーブロックを 保持（keep） するオプション。- 不良ブロックのチェックには関係しない。- 間違い！

⸻

❌ -s - mke2fs -s は、スーパーブロックのバックアップ数を設定 するオプション。- 不良ブロックのチェックには関係しない。- 間違い！

⸻

❌ -e - mke2fs -e <オプション> は、不良ブロックが検出された際のエラー処理方法を設定 するオプション。- 不良ブロックを検査するのではなく、検出後の動作を決める。- 間違い！

⸻

まとめ

```

オプション 目的 正解か
-c 不良ブロックを検査してからファイルシステムを作成 ✅
-a 無効なオプション（存在しない） ❌
-k 既存のスーパーブロックを保持する ❌
-s スーパーブロックのバックアップ数を設定 ❌
-e 不良ブロック発生時のエラー処理方法を設定 ❌

```

⸻

💡 ポイント - 不良ブロックをチェックしてから作成するなら -c！- 事前に badblocks を実行するため、安全なディスクセットアップが可能！

✅ 「mkfs.ext4 -c /dev/sdb1 で不良ブロックをチェックしてからフォーマット！」

## `ext2` ファイルシステムを `/dev/hda1` に作成する方法

### **問題**

`ext2` ファイルシステムを **`/dev/hda1`** に作成したい。
適切なコマンドを **全て選択** しなさい。

### **選択肢**

1. `mke2fs /dev/hda1`
2. `mkfs -t ext2 /dev/hda1`
3. `mke2fs -j /dev/hda1`
4. `mkfs /dev/hda1`
5. `mkfs -c ext2 /dev/hda1`

---

### **正解**

✅ **`mkfs -t ext2 /dev/hda1`**
✅ **`mke2fs /dev/hda1`**
✅ **`mkfs /dev/hda1`**

---

### **解説**

#### **1. `mke2fs /dev/hda1`**

- `mke2fs` は **`ext2` ファイルシステムを作成するための専用コマンド**。
- `mke2fs` のデフォルトは **`ext2`** なので、オプションなしで `ext2` ファイルシステムを作成できる。

✅ **正解！**

⸻

#### **2. `mkfs -t ext2 /dev/hda1`**

- `mkfs` は **汎用的なファイルシステム作成コマンド**。
- `-t ext2` を指定することで、`ext2` ファイルシステムを作成できる。

✅ **正解！**

⸻

#### **3. `mkfs /dev/hda1`**

- `mkfs` はデフォルトで `ext2` を作成する場合がある（システムの設定による）。
- `mkfs` の挙動は `mke2fs` に依存するため、**デフォルトが `ext2` なら正しく動作する**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mke2fs -j /dev/hda1`**

- `-j` オプションをつけると **`ext3` ファイルシステムが作成される**。
- **`ext2` ではなく `ext3` になるため不正解！**

⸻

❌ **`mkfs -c ext2 /dev/hda1`**

- `-c` は **不良ブロックのチェックを行うオプション**。
- ただし、正しい書式は **`mkfs -t ext2 -c /dev/hda1`** なので、**書式が誤っている**。

⸻

### **まとめ**

| コマンド                     | 説明                                                    | 正解か |
| ---------------------------- | ------------------------------------------------------- | ------ |
| **`mkfs -t ext2 /dev/hda1`** | **汎用 `mkfs` コマンドで `ext2` を作成**                | ✅     |
| **`mke2fs /dev/hda1`**       | **`ext2` 作成専用のコマンド**                           | ✅     |
| **`mkfs /dev/hda1`**         | **デフォルトで `ext2` を作成する場合がある**            | ✅     |
| `mke2fs -j /dev/hda1`        | `-j` により `ext3` が作成される                         | ❌     |
| `mkfs -c ext2 /dev/hda1`     | `-c` の位置が間違っている（正しくは `mkfs -t ext2 -c`） | ❌     |

⸻

💡 **ポイント**

- **`mke2fs /dev/hda1` は `ext2` 作成の専用コマンド**
- **`mkfs -t ext2 /dev/hda1` も `ext2` を作成可能**
- **`mkfs /dev/hda1` もデフォルトが `ext2` なら動作する**
- **`-j` をつけると `ext3` になるので注意！**

✅ **「`mke2fs /dev/hda1` or `mkfs -t ext2 /dev/hda1` で `ext2` 作成！」**

## exFAT ファイルシステムの特徴

### **問題**

exFAT ファイルシステムの特徴として **正しいものを 2 つ選択** しなさい。

### **選択肢**

1. **4GiB以上の大容量のファイルを扱える**
2. **すべてのLinuxでデフォルトでマウントできる**
3. **FATの後継であり、FATと互換性がある**
4. **フラッシュドライブ向けのファイルシステムである**
5. **扱えるファイルの最大サイズは 4GiB である**

---

### **正解**

✅ **フラッシュドライブ向けのファイルシステムである**
✅ **4GiB以上の大容量のファイルを扱える**

---

### **解説**

#### **1. 4GiB以上の大容量のファイルを扱える**

- exFAT は **FAT32 の後継として開発** され、大容量のファイルを扱えるように設計された。
- **1 ファイルの最大サイズは 16EiB（エクサバイト）**。
- FAT32 では **4GiB を超えるファイルを扱えない** が、exFAT では可能。

✅ **正解！**

⸻

#### **2. フラッシュドライブ向けのファイルシステムである**

- exFAT は **USB メモリや SD カードなどのフラッシュストレージ向け** に最適化されている。
- **ジャーナリング機能を持たず、書き込み回数を減らす** ことで、フラッシュメモリの寿命を延ばす設計になっている。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **すべてのLinuxでデフォルトでマウントできる**

- exFAT は **Microsoft が開発した独自のファイルシステム**。
- 以前は **Linux ではデフォルトでサポートされていなかった**。
- **Linux カーネル 5.4 以降** では **ネイティブサポート** されたが、**古いディストリビューションでは `exfat-utils` パッケージをインストールしないと使えない**。

⸻

❌ **FATの後継であり、FATと互換性がある**

- exFAT は **FAT32 の後継として開発された** が、**FAT32 との直接的な互換性はない**。
- **FAT32 から exFAT に変換するにはフォーマットが必要** で、**そのまま互換性があるわけではない**。

⸻

❌ **扱えるファイルの最大サイズは 4GiB である**

- これは **FAT32 の制限**。
- **exFAT では 4GiB を超えるファイルを扱えるため誤り！**

⸻

### **まとめ**

| 特徴                                               | exFAT の対応                                 | 正解か |
| -------------------------------------------------- | -------------------------------------------- | ------ |
| **4GiB以上の大容量のファイルを扱える**             | **✅（最大 16EiB）**                         | ✅     |
| **すべてのLinuxでデフォルトでマウントできる**      | **❌（古いLinuxでは `exfat-utils` が必要）** | ❌     |
| **FATの後継であり、FATと互換性がある**             | **❌（FAT32 からの直接的な互換性はない）**   | ❌     |
| **フラッシュドライブ向けのファイルシステムである** | **✅（フラッシュメモリの寿命を考慮）**       | ✅     |
| **扱えるファイルの最大サイズは 4GiB である**       | **❌（これは FAT32 の制限）**                | ❌     |

⸻

💡 **ポイント**

- **exFAT は 4GiB を超えるファイルを扱える！**
- **exFAT はフラッシュストレージ向けに最適化！**
- **Linux ではカーネル 5.4 以降で標準サポートされているが、古い環境では追加パッケージが必要！**
- **FAT32 とは直接の互換性はない！**

✅ **「exFAT は 4GiB 超のファイルを扱えて、フラッシュストレージ向け！」**

## MBR形式・GPT形式のパーティションテーブルをサポートするパーティション操作コマンド

### **問題**

**MBR形式・GPT形式のパーティションテーブル** をサポートするパーティション操作コマンドはどれか。

### **選択肢**

1. `mgedit`
2. `parted`
3. `mgdisk`
4. `mgpart`
5. `partedit`

---

### **正解**

✅ **`parted`**

---

### **解説**

#### **1. `parted`**

- **MBR（Master Boot Record）** と **GPT（GUID Partition Table）** の両方をサポートするパーティション操作コマンド。
- **ディスクのパーティションを作成・削除・変更** できる。
- **大容量ディスク（2TB 以上）に対応する GPT をサポート** している。
- **対話モード・コマンドモードの両方で使用可能**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mgedit`**

- **実在しないコマンド**。
- `parted` のようなパーティション操作ツールではない。

⸻

❌ **`mgdisk`**

- `gdisk`（GPT専用のパーティション操作ツール）に似た名前だが、**存在しないコマンド**。

⸻

❌ **`mgpart`**

- **実在しないコマンド**。
- `parted` や `fdisk` とは関係ない。

⸻

❌ **`partedit`**

- **実在しないコマンド**。
- `parted` のようなパーティション管理ツールではない。

⸻

### **まとめ**

| コマンド     | 説明                                               | 正解か |
| ------------ | -------------------------------------------------- | ------ |
| **`parted`** | **MBR/GPT をサポートするパーティション操作ツール** | ✅     |
| `mgedit`     | 存在しないコマンド                                 | ❌     |
| `mgdisk`     | 存在しないコマンド                                 | ❌     |
| `mgpart`     | 存在しないコマンド                                 | ❌     |
| `partedit`   | 存在しないコマンド                                 | ❌     |

⸻

💡 **ポイント**

- **`parted` は MBR / GPT の両方をサポート！**
- **`fdisk` は MBR のみ、`gdisk` は GPT のみ対応**
- **2TB 以上のディスクを扱うなら GPT（parted を使用するのが一般的）**

✅ **「MBR・GPT のパーティションを操作するなら `parted`！」**

## GRUB（GRUB Legacy または GRUB2）のインストール方法

### **問題**

デバイスファイルを指定して、ブートローダの **GRUB（GRUB Legacy または GRUB2）** をインストールしたい。
**3番目のディスク** にインストールする場合のコマンドと、**2番目のディスクの1番目のパーティション** にインストールする場合のコマンドを選びなさい。（**2つ選択**）

### **選択肢**

1. `grub-install /dev/hdc0`
2. `grub-install /dev/sdb`
3. `grub-install /dev/hdc`
4. `grub-install /dev/sdb1`
5. `grub-install /dev/hd3`
6. `grub-install /dev/sdb0`

---

### **正解**

✅ **`grub-install /dev/hdc`**
✅ **`grub-install /dev/sdb1`**

---

### **解説**

#### **1. `grub-install /dev/hdc`（3番目のディスクにインストール）**

- **IDE（PATA）ディスクの場合、`/dev/hdc` は 3 番目のディスク** に相当する。
- GRUB は通常、ディスク全体（MBR または GPT の先頭セクタ）にインストールされるため、**`/dev/hdc` にインストールするのが正しい**。

✅ **正解！**

⸻

#### **2. `grub-install /dev/sdb1`（2番目のディスクの1番目のパーティションにインストール）**

- **`/dev/sdb` は 2 番目のディスク（SATA/SCSI ディスク）を指す**。
- **`/dev/sdb1` は 2 番目のディスクの 1 番目のパーティション** なので、**GRUB を特定のパーティションにインストールしたい場合に適切**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`grub-install /dev/hdc0`**

- **`/dev/hdc0` というデバイス名は存在しない**（IDE の場合 `hdc1` などがパーティション名）。
- **正しくは `/dev/hdc` または `/dev/hdc1`**。

⸻

❌ **`grub-install /dev/sdb`**

- **`/dev/sdb` は 2 番目のディスク全体** を指すため、**MBR や GPT のブートローダをインストールするのには適している**。
- ただし、問題文では「**2番目のディスクの1番目のパーティション**」を求めているため、**不適切**。

⸻

❌ **`grub-install /dev/hd3`**

- **`/dev/hd3` というデバイス名は存在しない**（IDE の場合 `hda`, `hdb`, `hdc`, `hdd` まで）。
- **3番目のディスクは `/dev/hdc`** なので、これは間違い。

⸻

❌ **`grub-install /dev/sdb0`**

- **`/dev/sdb0` というデバイス名は存在しない**。
- **通常、パーティションは `/dev/sdb1`, `/dev/sdb2` のように番号が付く**。

⸻

### **まとめ**

| コマンド                     | 目的                                                     | 正解か |
| ---------------------------- | -------------------------------------------------------- | ------ |
| **`grub-install /dev/hdc`**  | **3番目のディスク（IDE `hdc`）にインストール**           | ✅     |
| **`grub-install /dev/sdb1`** | **2番目のディスクの1番目のパーティションにインストール** | ✅     |
| `grub-install /dev/hdc0`     | 無効なデバイス名（`/dev/hdc1` ならあり得る）             | ❌     |
| `grub-install /dev/sdb`      | 2番目のディスク全体（パーティション指定ではない）        | ❌     |
| `grub-install /dev/hd3`      | 存在しないデバイス名（`/dev/hdc` が正しい）              | ❌     |
| `grub-install /dev/sdb0`     | 存在しないデバイス名（`/dev/sdb1` なら正しい）           | ❌     |

⸻

💡 **ポイント**

- **ディスク全体に GRUB をインストールするなら `/dev/sdX` や `/dev/hdX`**
- **パーティションに GRUB をインストールするなら `/dev/sdX1` のように指定**
- **IDE の 3 番目のディスクは `/dev/hdc`、SATA の 2 番目のディスクは `/dev/sdb`**
- **デバイス名に `0` をつけるのは誤り！（`/dev/sdb0` は存在しない）**

✅ **「GRUB のインストール先を正しく指定しよう！」**

## 論理パーティションを表すデバイスファイル

### **問題**

論理パーティションを表すデバイスファイルは次のうちどれか。（**全て選択**）

### **選択肢**

1. `/dev/sda4`
2. `/dev/sda6`
3. `/dev/sda5`
4. `/dev/sda1`
5. `/dev/sda3`

---

### **正解**

✅ **`/dev/sda5`**
✅ **`/dev/sda6`**

---

### **解説**

Linux では、ディスクのパーティションには **基本パーティション**（プライマリパーティション）と **論理パーティション** があります。

#### **1. パーティションの種類**

- **基本パーティション（プライマリパーティション）**

  - `/dev/sda1` ～ `/dev/sda4` の範囲で作成可能（最大4つ）。
  - 拡張パーティションもこの範囲に含まれる。

- **拡張パーティション**

  - **基本パーティションの1つを拡張パーティションとして設定** し、その中に論理パーティションを作成。
  - `/dev/sda4` が拡張パーティションになることが多い。

- **論理パーティション**
  - **拡張パーティション内に作成されるパーティション**。
  - **デバイスファイルは `/dev/sda5` 以降（`/dev/sda5`, `/dev/sda6`, `/dev/sda7`...）となる**。

⸻

### **各デバイスファイルの確認**

| デバイスファイル | 種類                                                       | 正解か |
| ---------------- | ---------------------------------------------------------- | ------ |
| `/dev/sda1`      | 基本パーティション                                         | ❌     |
| `/dev/sda3`      | 基本パーティション                                         | ❌     |
| `/dev/sda4`      | **通常は拡張パーティション**（論理パーティションではない） | ❌     |
| `/dev/sda5`      | **論理パーティションの最初の番号**                         | ✅     |
| `/dev/sda6`      | **2番目以降の論理パーティション**                          | ✅     |

⸻

### **まとめ**

- **基本パーティション**：`/dev/sda1` ～ `/dev/sda4`
- **論理パーティション**：**`/dev/sda5` 以降**
- **拡張パーティション**（論理パーティションを格納するための枠）：通常 `/dev/sda4`
- **論理パーティションは `/dev/sda5` 以降の番号が割り当てられる！**

⸻

💡 **ポイント**

- **`/dev/sda5` 以降が論理パーティション**
- **`/dev/sda4` は拡張パーティションであることが多い**
- **基本パーティションは `/dev/sda1` ～ `/dev/sda4`**

✅ **「論理パーティションは `/dev/sda5` 以降！」**

## ジャーナリングファイルシステムではないもの

### **問題**

次のうち、**ジャーナリングファイルシステムではないもの** を選びなさい。

### **選択肢**

1. `JFS`
2. `ext4`
3. `ext2`
4. `ext3`
5. `XFS`

---

### **正解**

✅ **`ext2`**

---

### **解説**

#### **ジャーナリングファイルシステムとは？**

ジャーナリングファイルシステムは、**クラッシュや電源断によるデータ破損を防ぐために、変更履歴（ジャーナル）を記録する機能を持つファイルシステム** です。
ファイルの変更が発生すると、**まずジャーナル領域に変更内容を記録してから、実際のデータを書き込む** ため、データの整合性が向上します。

#### **1. `ext2`（ジャーナリングなし）**

- **`ext2` はジャーナリング機能を持たないファイルシステム。**
- シンプルでオーバーヘッドが少ないため、組み込み機器や USB メモリなどに使用されることがある。
- **クラッシュ時の復旧には `fsck`（ファイルシステムチェック）が必要で、時間がかかる。**

✅ **正解！**

⸻

#### **ジャーナリングファイルシステム（誤りの選択肢）**

❌ **`JFS`**（Journaled File System）

- **IBM が開発したジャーナリングファイルシステム。**
- 大規模なストレージ環境向けに設計され、高速なファイル処理が可能。

⸻

❌ **`ext4`**

- **`ext3` の拡張版で、ジャーナリング機能を持つ。**
- 大容量ディスク対応や `extents`（連続ブロック管理）などの改良が加えられている。

⸻

❌ **`ext3`**

- **`ext2` にジャーナリング機能を追加したファイルシステム。**
- クラッシュ時のデータ復旧が速く、Linux で長く使われた。

⸻

❌ **`XFS`**

- **高性能なジャーナリングファイルシステム。**
- **大容量ストレージ向けに最適化されており、並列処理性能が高い。**

⸻

### **まとめ**

| ファイルシステム | ジャーナリング | 特徴                             | 正解か |
| ---------------- | -------------- | -------------------------------- | ------ |
| **`ext2`**       | **なし**       | シンプルでオーバーヘッドが少ない | ✅     |
| `JFS`            | あり           | IBM 開発、大規模ストレージ向け   | ❌     |
| `ext4`           | あり           | `ext3` の改良版、大容量対応      | ❌     |
| `ext3`           | あり           | `ext2` + ジャーナリング機能      | ❌     |
| `XFS`            | あり           | 高速処理、大容量向け             | ❌     |

⸻

💡 **ポイント**

- **`ext2` はジャーナリング機能を持たない唯一の選択肢！**
- **ジャーナリングがないため `fsck`（チェック＆修復）が必要になる。**
- **`ext3` 以降はすべてジャーナリングをサポート！**

✅ **「ジャーナリングなし＝`ext2`！」**

## 次世代のLinux標準ファイルシステム

### **問題**

次世代の **Linux標準ファイルシステム** として開発され、
**ディレクトリの一部をサブボリュームとして個別のファイルシステムのように扱える** ファイルシステムはどれか。

### **選択肢**

1. `ext5`
2. `ZFS`
3. `Btrfs`
4. `XFS`

---

### **正解**

✅ **`Btrfs`**

---

### **解説**

#### **1. `Btrfs`（バターFS）**

- **「B-tree filesystem」** の略で、Linuxの次世代標準ファイルシステムとして開発された。
- **スナップショット、サブボリューム、データ圧縮、自己修復機能などをサポート**。
- **サブボリューム（subvolume）を作成し、個別のファイルシステムのように扱うことが可能**。
- **Red Hat は RHEL 8 以降でサポートを終了したが、openSUSE や Fedora では標準採用されている**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`ext5`**

- **存在しないファイルシステム**。
- `ext4` の次のバージョンとして `ext5` が開発される予定はない。
- **`ext4` は安定しているが、次世代ファイルシステムとしては Btrfs の方が高機能**。

⸻

❌ **`ZFS`**

- **Oracle（旧Sun Microsystems）が開発したファイルシステム**。
- **スナップショットやプール管理などの高機能を持つが、GPL ライセンスとの互換性の問題がある**。
- **Linux カーネルには直接統合されていない**（Ubuntu では公式に ZFS をサポート）。

⸻

❌ **`XFS`**

- **高性能なジャーナリングファイルシステム**。
- **大容量のデータ処理に適しているが、Btrfs のようなスナップショットやサブボリュームの概念はない**。

⸻

### **まとめ**

| ファイルシステム | 特徴                                                       | サブボリューム対応 | 次世代Linux標準 | 正解か |
| ---------------- | ---------------------------------------------------------- | ------------------ | --------------- | ------ |
| **`Btrfs`**      | **スナップショット、サブボリューム、自己修復対応**         | ✅                 | ✅              | ✅     |
| `ext5`           | **存在しない**                                             | ❌                 | ❌              | ❌     |
| `ZFS`            | **スナップショット、プール管理対応（Linux 公式統合なし）** | ✅                 | ❌              | ❌     |
| `XFS`            | **大規模データ向け高性能FS（サブボリュームなし）**         | ❌                 | ❌              | ❌     |

⸻

💡 **ポイント**

- **Btrfs は Linux の次世代標準ファイルシステムとして開発されている！**
- **サブボリューム機能により、一部のディレクトリを独立したファイルシステムのように扱える！**
- **ZFS も高機能だが、ライセンスの問題で Linux に標準統合されていない！**

✅ **「次世代 Linux 標準ファイルシステムは Btrfs！」**

## GPT に存在しない制約

### **問題**

GPT（GUID Partition Table）に **存在しない制約** を **3つ選択** しなさい。

### **選択肢**

1. **起動用システムファームウェア：UEFI**
2. **最大ハードディスク容量：2.2TB（2TiB）**
3. **起動用システムファームウェア：BIOS**
4. **基本パーティション数：128**
5. **最大ハードディスク容量：9.4ZB（8ZiB）**
6. **基本パーティション数：4**

---

### **正解**

✅ **基本パーティション数：4**
✅ **最大ハードディスク容量：2.2TB（2TiB）**
✅ **起動用システムファームウェア：BIOS**

---

### **解説**

#### **GPTとは？**

GPT（GUID Partition Table）は、従来の **MBR（Master Boot Record）** に代わる **次世代のパーティションテーブルフォーマット** です。
MBR の制約を克服し、**大容量ディスクや多数のパーティションをサポート** します。

⸻

### **存在しない制約（正解）**

#### **1. 基本パーティション数：4**

- **MBR では基本パーティションは最大4つまで** だが、GPT では **128個以上のパーティションを作成可能**（UEFI仕様では128個が一般的）。
- **GPT には「基本パーティション」という概念がなく、すべてのパーティションが等しく扱われる**。

✅ **正解！**

⸻

#### **2. 最大ハードディスク容量：2.2TB（2TiB）**

- **MBR では 2.2TB（2TiB）が上限** だったが、GPT では **最大 9.4ZB（8ZiB）まで対応可能**。
- **GPT の 64bit LBA により、非常に大きなディスク容量を扱える**。

✅ **正解！**

⸻

#### **3. 起動用システムファームウェア：BIOS**

- **GPT は UEFI に対応** しているが、**従来の BIOS とは互換性がない**。
- BIOS で GPT ディスクからのブートは **基本的に不可**（特殊な方法を除く）。
- **BIOS でブートする場合は MBR を使用するのが一般的**。

✅ **正解！**

⸻

### **GPT に存在する仕様（誤りの選択肢）**

❌ **起動用システムファームウェア：UEFI**

- **GPT は UEFI に対応** しており、GPT ディスクからの起動には UEFI が必要。
- **正しい仕様なので不正解！**

⸻

❌ **基本パーティション数：128**

- **GPT では UEFI 仕様で最大128個のパーティションを作成可能**。
- **実際の最大数はディスクのサイズと OS に依存**。

⸻

❌ **最大ハードディスク容量：9.4ZB（8ZiB）**

- **GPT の仕様では 64bit LBA により最大 9.4ZB（8ZiB）まで対応**。
- **正しい仕様なので不正解！**

⸻

### **まとめ**

| 制約                                            | MBR                                         | GPT                 | 存在しない制約か |
| ----------------------------------------------- | ------------------------------------------- | ------------------- | ---------------- |
| **基本パーティション数**                        | **最大4つ**（拡張パーティションで増やせる） | **128個以上**       | ✅               |
| **最大ハードディスク容量**                      | **2.2TB（2TiB）**                           | **9.4ZB（8ZiB）**   | ✅               |
| **起動用システムファームウェア**                | **BIOS**                                    | **UEFI**            | ✅               |
| **GPT の基本パーティション数：128**             | ❌（MBR では4つ）                           | ✅（一般的に128個） | ❌               |
| **GPT の最大ハードディスク容量：9.4ZB（8ZiB）** | ❌（MBR は 2.2TB）                          | ✅                  | ❌               |
| **GPT の起動ファームウェア：UEFI**              | ❌（MBR は BIOS）                           | ✅                  | ❌               |

⸻

💡 **ポイント**

- **GPT では 128個以上のパーティションを作成可能（MBR は最大4つ）**
- **GPT のディスクサイズ上限は 9.4ZB（MBR は 2.2TB 制限あり）**
- **GPT は UEFI 対応、BIOS ではブート不可**
- **「MBR の制約 = GPT では解決されている」と考えると分かりやすい！**

✅ **「GPT にない制約は『パーティション数4』『2.2TB上限』『BIOSブート』！」**

## `fdisk` コマンドのサブコマンドとその説明

### **問題**

`fdisk` コマンドの **サブコマンドとその説明の組み合わせとして正しいもの** を **2つ選択** しなさい。

### **選択肢**

1. `m`：パーティションタイプ（システムID）の変更
2. `t`：パーティションタイプ（システムID）の変更
3. `q`：パーティションテーブルの変更を保存して終了
4. `p`：パーティションテーブルの表示
5. `d`：パーティションの作成

---

### **正解**

✅ **`p`：パーティションテーブルの表示**
✅ **`t`：パーティションタイプ（システムID）の変更**

---

### **解説**

#### **1. `p`：パーティションテーブルの表示**

- **現在のパーティション情報を表示するコマンド**。
- **ディスク上のパーティションのリスト、サイズ、ファイルシステムタイプなどを確認可能**。
- 実行例：
  ```bash
  Command (m for help): p
  ```
  - 出力例：

```
Disk /dev/sda: 500GB
Sector size: 512 bytes
Device Boot  Start     End      Blocks   Id  System
/dev/sda1    *        1        1024    102400  83  Linux
```

✅ 正解！

⸻

2. t：パーティションタイプ（システムID）の変更
   - パーティションのファイルシステムタイプ（システムID）を変更するコマンド。
   - 例えば、ext4（ID: 83）から Linux Swap（ID: 82）に変更する際に使用。
   - 実行例：

```
Command (m for help): t
Partition number (1-4): 1
Hex code (type L to list codes): 82
```

    -	l を押すと、利用可能なパーティションタイプの一覧が表示される。

✅ 正解！

⸻

誤った選択肢の解説

❌ m：パーティションタイプ（システムID）の変更 - m は fdisk のヘルプメニューを表示するコマンド であり、パーティションタイプの変更は t を使用 する。

⸻

❌ q：パーティションテーブルの変更を保存して終了 - q は 変更を保存せずに終了するコマンド。- 変更を保存して終了するには w を使用する。

⸻

❌ d：パーティションの作成 - d は パーティションの削除を行うコマンド であり、作成には n を使用する。

⸻

### まとめ

```
サブコマンド	説明	正解か
p	パーティションテーブルの表示	✅
t	パーティションタイプ（システムID）の変更	✅
m	fdisk のサブコマンド一覧を表示（ヘルプ）	❌
q	変更を保存せずに終了（保存して終了ではない）	❌
d	パーティションを削除（作成ではない）	❌
```

⸻

💡 ポイント - p：現在のパーティション情報を確認 - t：パーティションタイプ（システムID）の変更 - m はヘルプ、q は保存せず終了、d は削除 - パーティションを作成する場合は n を使用

✅ 「p でパーティション情報確認、t でタイプ変更！」

## `parted` を使用してパーティションテーブルの方式を GPT に設定する方法

### **問題**

新しいハードディスクの **パーティションテーブルの方式を GPT に設定** したい。
正しいコマンドを **2つ選択** しなさい。

### **選択肢**

1.  parted /dev/sdb -s mklabel gpt
2.  parted /dev/sdb -t gpt
3.  parted /dev/sdb
    (parted) parttbl gpt
    (parted) q
4.  parted /dev/sdb -s parttbl gpt

5.  parted /dev/sdb
    (parted) gpt
    (parted) q
6.  parted /dev/sdb
    (parted) mklabel gpt
    (parted) q

⸻

### 正解

✅ parted /dev/sdb -s mklabel gpt
✅ parted /dev/sdb → (parted) mklabel gpt → (parted) q

⸻

解説

1.  parted /dev/sdb -s mklabel gpt

- -s オプションは スクリプトモード で実行するためのもので、対話モードなしで mklabel gpt を実行できる。
- 短縮形のコマンドで GPT に設定するのに適切。

✅ 正解！

⸻

2.  parted /dev/sdb → (parted) mklabel gpt → (parted) q

- parted を 対話モード で実行し、手動で mklabel gpt を入力して GPT に設定する方法。
- q を入力することで parted を終了 する。

✅ 正解！

⸻

誤った選択肢の解説

❌ parted /dev/sdb -t gpt - -t オプションは parted には存在しない。- パーティションテーブルの作成には mklabel を使用する必要がある。

⸻

❌ parted /dev/sdb -s parttbl gpt - parttbl というコマンドは 存在しない。- mklabel gpt を使用するのが正しい方法。

⸻

❌ parted /dev/sdb → (parted) parttbl gpt → (parted) q - parttbl というサブコマンドは 存在しない。- mklabel gpt が正しいコマンド。

⸻

❌ # parted /dev/sdb → (parted) gpt → (parted) q - gpt というコマンドは parted には存在しない。- 正しくは mklabel gpt を使う。

⸻

### まとめ

```
コマンド	説明	正解か
 parted /dev/sdb -s mklabel gpt	スクリプトモードで GPT を設定	✅
 parted /dev/sdb → (parted) mklabel gpt → (parted) q	対話モードで GPT を設定	✅
 parted /dev/sdb -t gpt	-t オプションは無効	❌
 parted /dev/sdb -s parttbl gpt	parttbl というコマンドは存在しない	❌
 parted /dev/sdb → (parted) parttbl gpt → (parted) q	parttbl コマンドは存在しない	❌
 parted /dev/sdb → (parted) gpt → (parted) q	gpt というコマンドは存在しない	❌
```

⸻

💡 ポイント - mklabel gpt を使うと GPT のパーティションテーブルを作成できる！- parted -s mklabel gpt なら対話なしで一発設定！- 対話モードで実行するなら parted を開いて mklabel gpt を入力！

✅ 「GPT の設定には mklabel gpt を使おう！」

## GRUB（GRUB Legacy / GRUB2）のインストールコマンドの説明

### **問題**

デバイスファイルを指定して **GRUB（GRUB LegacyまたはGRUB2）** をインストールするコマンドについて、**正しい説明** を **2つ選択** しなさい。

### **選択肢**

1. **`grub-install /dev/sdd`** は、4番目のディスクにインストールする
2. **`grub-install /dev/hdd0`** は、1番目のパーティションにインストールする
3. **`grub-install /dev/sdd`** は、1番目のパーティションにインストールする
4. **`grub-install /dev/hdd2`** は、2番目のパーティションにインストールする

---

### **正解**

✅ **`grub-install /dev/sdd` は、4番目のディスクにインストールする**
✅ **`grub-install /dev/hdd2` は、2番目のパーティションにインストールする**

---

### **解説**

#### **1. `grub-install /dev/sdd` は、4番目のディスクにインストールする**

- **SATA（SCSI）デバイスの場合**、Linux では `/dev/sda` が **1番目のディスク**、`/dev/sdb` が **2番目のディスク**...と続く。
- **`/dev/sdd` は 4 番目のディスクを指す**。
- **パーティション指定がない場合はディスク全体の MBR / GPT に GRUB をインストールする**。

✅ **正解！**

⸻

#### **2. `grub-install /dev/hdd2` は、2番目のパーティションにインストールする**

- **IDE（PATA）デバイスの場合**、Linux では `/dev/hda` が **1番目のディスク**、`/dev/hdb` が **2番目のディスク**...と続く。
- **`/dev/hdd` は 4 番目のディスク** なので、`/dev/hdd2` は **4番目のディスクの2番目のパーティション** を指す。
- **GRUB を MBR ではなく特定のパーティションにインストールする場合は、`grub-install /dev/hdd2` のようにパーティションを指定する**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`grub-install /dev/hdd0` は、1番目のパーティションにインストールする**

- **誤り！**
- **Linux では `hdd0` というデバイスファイルは存在しない**。
- **1番目のパーティションは `/dev/hdd1` になるため、`/dev/hdd0` は無効**。

⸻

❌ **`grub-install /dev/sdd` は、1番目のパーティションにインストールする**

- **誤り！**
- **パーティション指定がない場合、GRUB はディスク全体（MBR または GPT）にインストールされる**。
- **1番目のパーティションなら `/dev/sdd1` を指定する必要がある**。

⸻

### **まとめ**

| コマンド                                         | 説明                                                     | 正解か |
| ------------------------------------------------ | -------------------------------------------------------- | ------ |
| **`grub-install /dev/sdd`**                      | **4番目のディスク全体にインストール**                    | ✅     |
| **`grub-install /dev/hdd2`**                     | **4番目のディスクの2番目のパーティションにインストール** | ✅     |
| `grub-install /dev/hdd0`                         | **無効なデバイス名（`/dev/hdd1` が正しい）**             | ❌     |
| `grub-install /dev/sdd`（1番目のパーティション） | **ディスク全体にインストールされるため誤り**             | ❌     |

⸻

💡 **ポイント**

- **`/dev/sda`, `/dev/sdb`, `/dev/sdc`, `/dev/sdd`... はそれぞれ1番目、2番目、3番目、4番目のディスク**
- **GRUB をディスク全体（MBR / GPT）にインストールする場合は `/dev/sdX`**
- **特定のパーティションにインストールする場合は `/dev/sdX1` のように指定**
- **`/dev/hdd2` は IDE の4番目のディスクの2番目のパーティション**

✅ **「GRUB のインストール先を正しく指定しよう！」**

## inode の数が制限されるファイルシステム

### **問題**

inode の数が制限されるファイルシステムは次のうちどれか。（**全て選択**）

### **選択肢**

1. `ext2`
2. `ext4`
3. `XFS`
4. `ext3`
5. `JFS`

---

### **正解**

✅ **`ext2`**
✅ **`ext3`**
✅ **`ext4`**

---

### **解説**

#### **inode とは？**

- **inode（インノード）** は、ファイルのメタデータ（所有者、パーミッション、サイズ、格納場所 など）を管理するデータ構造。
- **Linux の `ext` 系ファイルシステムでは、ファイルシステム作成時に inode の総数が決まるため、後から増やすことはできない**。

⸻

#### **1. `ext2`, `ext3`, `ext4`（inode 数の制限あり）**

- **`ext2`、`ext3`、`ext4` は、ファイルシステム作成時に inode 数が決まる**。
- そのため、**inode を使い切ると、ディスクの空き容量があっても新しいファイルを作成できない**。
- `ext4` では **inode サイズの柔軟な設定** や **拡張機能** が追加されたが、基本的な制限は変わらない。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`XFS`（inode 数の制限なし）**

- **`XFS` は動的 inode を採用** しているため、必要に応じて inode を増やせる。
- **ファイルシステム作成時に inode 数を事前に決める必要がない**。

⸻

❌ **`JFS`（inode 数の制限なし）**

- **`JFS` も動的 inode を採用** しており、`ext` 系のような inode 数の制限はない。

⸻

### **まとめ**

| ファイルシステム | inode 数の制限 | 説明                                   | 正解か |
| ---------------- | -------------- | -------------------------------------- | ------ |
| **`ext2`**       | **あり**       | 作成時に inode 数が固定                | ✅     |
| **`ext3`**       | **あり**       | `ext2` にジャーナリングを追加          | ✅     |
| **`ext4`**       | **あり**       | `ext3` の改良版だが inode 数の制限あり | ✅     |
| `XFS`            | なし           | 動的 inode を採用                      | ❌     |
| `JFS`            | なし           | 動的 inode を採用                      | ❌     |

⸻

💡 **ポイント**

- **`ext2`、`ext3`、`ext4` は inode の数が固定で、後から増やせない！**
- **`XFS` や `JFS` は動的 inode なので、inode 数の制限なし！**
- **inode 数が足りなくなると、ディスクの空き容量があってもファイルが作成できなくなる！**

✅ **「inode の数が制限されるのは `ext2` `ext3` `ext4`！」**

## MBR 方式のハードディスクに作成できる基本パーティションの最大数

### **問題**

MBR（Master Boot Record）方式のハードディスクに **基本パーティションは最大何個作成できるか**。

### **選択肢**

1. **4**
2. **7**
3. **6**
4. **5**
5. **無限**

---

### **正解**

✅ **4**

---

### **解説**

#### **MBR（Master Boot Record）とは**

MBR（Master Boot Record）は、**従来のパーティション管理方式** であり、
ディスクの先頭に **パーティション情報** を格納する **パーティションテーブル** を持っています。

⸻

#### **1. MBR で作成可能な基本パーティションの最大数**

- **MBR のパーティションテーブルには最大 4 つのエントリしか存在しない**。
- そのため、**基本パーティション（プライマリパーティション）は最大 4 つまでしか作成できない**。

✅ **正解！**

⸻

#### **2. 拡張パーティションと論理パーティション**

- **MBR では 4 つ以上のパーティションを作成したい場合、拡張パーティションを利用する**。
- **基本パーティション 4 つのうち 1 つを拡張パーティションにすると、その中に無制限に論理パーティションを作成できる**。
- **論理パーティションは `/dev/sda5` 以降の番号で作成される**（`/dev/sda1` ～ `/dev/sda4` は基本パーティション）。

⸻

### **誤った選択肢の解説**

❌ **7 / 6 / 5**

- **MBR では基本パーティションは最大 4 つまでしか作成できない**。
- 5 個以上作成したい場合は、**1 つを拡張パーティションにし、その中に論理パーティションを作成する必要がある**。

⸻

❌ **無限**

- **MBR では基本パーティションは 4 つまでという制限があるため無限には作成できない**。
- GPT（GUID Partition Table）を使用すれば、**128個以上のパーティションを作成できる**。

⸻

### **まとめ**

| パーティションの種類           | MBR                                          | GPT                             |
| ------------------------------ | -------------------------------------------- | ------------------------------- |
| **基本パーティションの最大数** | **4 つ**                                     | **制限なし（一般的に 128 個）** |
| **拡張パーティションの数**     | **1 つ**（基本パーティションとしてカウント） | **不要**                        |
| **論理パーティションの数**     | **無制限（拡張パーティション内）**           | **不要**                        |

⸻

💡 **ポイント**

- **MBR では基本パーティションは最大 4 つ！**
- **5 個以上のパーティションを作成するには、拡張パーティションを作り、その中に論理パーティションを作成する**
- **制限なしで多くのパーティションを作りたいなら GPT を使う**

✅ **「MBR では基本パーティションは 4 つまで！」**

## `fdisk` コマンドで作成したパーティションにファイルシステムを作成するコマンド

### **問題**

`fdisk` コマンドで作成したパーティションに **ファイルシステムを作成** できるコマンドを **2つ選択** しなさい。

### **選択肢**

1. `mkfdisk`
2. `mkfs`
3. `mke2fs`
4. `mk2fs`
5. `make2fs`

---

### **正解**

✅ **`mkfs`**
✅ **`mke2fs`**

---

### **解説**

#### **1. `mkfs`（汎用的なファイルシステム作成コマンド）**

- **`mkfs`（Make File System）は、任意のファイルシステムを作成できる汎用コマンド**。
- `-t` オプションを使って **ファイルシステムの種類を指定可能**。
- 例（`ext4` ファイルシステムを作成）：
  ```bash
  mkfs -t ext4 /dev/sda1
  ```
  - mkfs.ext4 や mkfs.xfs など、特定のファイルシステム向けのバージョンもある。

✅ 正解！

⸻

2. mke2fs（ext 系ファイルシステム専用コマンド）
   - mke2fs は ext2、ext3、ext4 ファイルシステムを作成できる専用コマンド。
   - -t オプションを指定することで、ext2 以外も作成可能。
   - 例（ext4 ファイルシステムを作成）：

```
mke2fs -t ext4 /dev/sda1

```

    -	例（ext3 ファイルシステムを作成）：

```
mke2fs -j /dev/sda1

```

✅ 正解！

⸻

誤った選択肢の解説

❌ mkfdisk - 存在しないコマンド。- パーティションを作成する fdisk とは無関係。

⸻

❌ mk2fs - 存在しないコマンド。- 正しくは mke2fs。

⸻

❌ make2fs - 存在しないコマンド。- 正しくは mke2fs。

⸻

### まとめ

```
コマンド 説明 正解か
mkfs 汎用的なファイルシステム作成コマンド ✅
mke2fs ext2/ext3/ext4 専用のファイルシステム作成コマンド ✅
mkfdisk 存在しないコマンド ❌
mk2fs 存在しないコマンド ❌
make2fs 存在しないコマンド ❌

```

⸻

💡 ポイント - mkfs は汎用的なファイルシステム作成コマンド - mke2fs は ext2 / ext3 / ext4 用のファイルシステム作成コマンド - mkfdisk や make2fs などは存在しない！

✅ 「パーティションにファイルシステムを作成するなら mkfs または mke2fs！」

## MBR 形式のハードディスクにおけるパーティションタイプの組み合わせ

### **問題**

MBR 形式のハードディスクにおける **パーティションタイプの組み合わせとして正しいもの** はどれか。

### **選択肢**

1. **`e0`：空**
2. **`82`：Linux swap**
3. **`0`：Linux LVM**
4. **`83`：FAT**
5. **`8e`：Linux**

---

### **正解**

✅ **`82`：Linux swap**

---

### **解説**

MBR（Master Boot Record）では、**各パーティションに対して「パーティションタイプ ID（16進数）」が割り当てられる**。
この ID により、OS はパーティションの種類を判別します。

⸻

#### **1. `82`：Linux swap（正解）**

- **Linux のスワップ領域を表すパーティションタイプ**。
- スワップ領域は、**物理メモリ（RAM）が不足したときに仮想メモリとして使用される**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`e0`：空**

- **`e0` というパーティションタイプは存在しない**。
- **未使用の領域（未割り当てパーティション）には特定のパーティションタイプは設定されない**。

⸻

❌ **`0`：Linux LVM**

- **`0` は「未使用」のパーティションタイプ ID であり、LVM とは無関係**。
- **Linux LVM（Logical Volume Manager）の ID は `8e`**。

⸻

❌ **`83`：FAT**

- **`83` は「Linux ファイルシステム（ext2/ext3/ext4 など）」を表す ID**。
- **FAT のパーティションタイプ ID は `0b`（FAT32）、`0c`（FAT32（LBA））など**。

⸻

❌ **`8e`：Linux**

- **`8e` は「Linux LVM（Logical Volume Manager）」の ID** であり、**通常の Linux ファイルシステムを指すわけではない**。
- **Linux の標準的なファイルシステム（ext2/ext3/ext4 など）の ID は `83`**。

⸻

### **正しいパーティションタイプ ID 一覧（MBR）**

| パーティションタイプ ID | 説明                                    |
| ----------------------- | --------------------------------------- |
| **`82`**                | **Linux swap**                          |
| **`83`**                | **Linux（ext2/ext3/ext4 など）**        |
| **`8e`**                | **Linux LVM（Logical Volume Manager）** |
| **`0b`**                | **FAT32**                               |
| **`0c`**                | **FAT32（LBA）**                        |
| **`07`**                | **NTFS/exFAT**                          |
| **`05`**                | **拡張パーティション**                  |

⸻

### **まとめ**

| 選択肢               | 正しいパーティションタイプか | 説明                                           |
| -------------------- | ---------------------------- | ---------------------------------------------- |
| **`82`：Linux swap** | ✅                           | **スワップ領域を表す**                         |
| `e0`：空             | ❌                           | **存在しないパーティションタイプ ID**          |
| `0`：Linux LVM       | ❌                           | **`0` は未使用、LVM は `8e`**                  |
| `83`：FAT            | ❌                           | **`83` は Linux（FAT ではない）**              |
| `8e`：Linux          | ❌                           | **`8e` は Linux LVM（通常の Linux ではない）** |

⸻

💡 **ポイント**

- **`82` は Linux swap！**
- **Linux の標準的なファイルシステム（ext2/ext3/ext4 など）は `83`！**
- **Linux LVM は `8e`！**
- **FAT32 は `0b` または `0c`！**

✅ **「Linux swap のパーティションタイプは `82`！」**

## `fdisk` コマンドのサブコマンドとその説明の間違い

### **問題**

次の `fdisk` コマンドのサブコマンドとその説明の組み合わせのうち、**間違っているもの** はどれか。

### **選択肢**

1. **`n`：パーティションの作成**
2. **`t`：パーティションテーブルの表示**
3. **`q`：パーティションテーブルの変更を保存せずに終了**
4. **`d`：パーティションの削除**
5. **`w`：パーティションテーブルの変更を保存して終了**

---

### **正解**

✅ **`t`：パーティションテーブルの表示（間違い）**

---

### **解説**

#### **1. `t`：パーティションテーブルの表示（間違い）**

- **`t` はパーティションのファイルシステムタイプ（システム ID）を変更するコマンド**。
- **パーティションテーブルを表示するコマンドではない！**
- **パーティションテーブルの表示には `p` を使用する**。

❌ **誤り！**

⸻

### **正しい選択肢の解説**

✅ **`n`：パーティションの作成**

- **新しいパーティションを作成するコマンド**。
- `fdisk` 内で **`n` を入力し、パーティションの種類（基本 or 拡張）やサイズを指定** する。

✅ **正しい！**

⸻

✅ **`q`：パーティションテーブルの変更を保存せずに終了**

- **変更を破棄し、`fdisk` を終了するコマンド**。
- **パーティションの変更を保存せずに抜けたい場合に使用**。

✅ **正しい！**

⸻

✅ **`d`：パーティションの削除**

- **指定したパーティションを削除するコマンド**。
- **削除を確定するには `w`（保存）を実行する必要がある**。

✅ **正しい！**

⸻

✅ **`w`：パーティションテーブルの変更を保存して終了**

- **変更をディスクに書き込み（保存し）、`fdisk` を終了するコマンド**。
- **この操作を行うと、変更が確定し、取り消せなくなるので注意！**

✅ **正しい！**

⸻

### **まとめ**

| サブコマンド | 説明                                                                   | 正しいか |
| ------------ | ---------------------------------------------------------------------- | -------- |
| **`n`**      | **パーティションの作成**                                               | ✅       |
| **`t`**      | **パーティションのファイルシステムタイプ（ID）の変更**（表示ではない） | ❌       |
| **`q`**      | **変更を保存せずに終了**                                               | ✅       |
| **`d`**      | **パーティションの削除**                                               | ✅       |
| **`w`**      | **パーティションテーブルの変更を保存して終了**                         | ✅       |

⸻

💡 **ポイント**

- **パーティションテーブルの表示は `p`！**
- **`t` はパーティションのタイプ（システム ID）を変更するコマンド！**
- **変更を保存せずに終了するなら `q`、保存して終了するなら `w`！**

✅ **「`t` はパーティションタイプ変更！パーティションテーブルの表示は `p`！」**

## MBR 方式のハードディスク `/dev/sda` のパーティションテーブルを確認する方法

### **問題**

MBR 方式のハードディスク **`/dev/sda`** のパーティションテーブルを確認したい。
適切なコマンドを選びなさい。

### **選択肢**

1. **`fdisk --table /dev/sda`**
2. **`fdisk -p /dev/sda`**
3. **`fdisk -l /dev/sda`**
4. **`fdisk -t /dev/sda`**
5. **`fdisk --library /dev/sda`**

---

### **正解**

✅ **`fdisk -l /dev/sda`**

---

### **解説**

#### **1. `fdisk -l /dev/sda`（正解）**

- `fdisk -l` は **指定したデバイスのパーティションテーブルを一覧表示するコマンド**。
- MBR のパーティション情報を確認する際に使用される。
- 実行例：
  ```bash
  sudo fdisk -l /dev/sda
  ```
  - 出力例：

```
Disk /dev/sda: 500GB
Sector size: 512 bytes
Device      Boot Start    End      Blocks   Id  System
/dev/sda1   *     2048    4096     102400   83  Linux
```

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk --table /dev/sda - --table というオプションは存在しない。

⸻

❌ fdisk -p /dev/sda - -p というオプションは fdisk には存在しない。- パーティション情報を表示するなら -l を使用する。

⸻

❌ fdisk -t /dev/sda - -t は fdisk には存在しないオプション（mkfs -t のような形式でファイルシステムを指定するコマンドには存在）。

⸻

❌ fdisk --library /dev/sda - --library というオプションは fdisk には存在しない。

⸻

### まとめ

```
コマンド	説明	正解か
fdisk -l /dev/sda	パーティションテーブルを一覧表示	✅
fdisk --table /dev/sda	無効なオプション	❌
fdisk -p /dev/sda	無効なオプション	❌
fdisk -t /dev/sda	無効なオプション	❌
fdisk --library /dev/sda	無効なオプション	❌
```

⸻

💡 ポイント - fdisk -l /dev/sda で MBR のパーティションテーブルを表示 - -l は「list」の意味 - 無効なオプション（--table -p -t --library）に注意！

✅ 「MBR のパーティションを確認するなら fdisk -l /dev/sda！」

## GPT 形式のハードディスクでパーティションの作成・削除・変更・情報表示を行うコマンド

### **問題**

GPT 形式のハードディスクにおいて、**パーティションの作成、削除、変更、および情報表示** を行うことができるコマンドはどれか。

### **選択肢**

1. **`fdisk`**
2. **`gptedit`**
3. **`gdisk`**
4. **`partition`**
5. **`gptdisk`**

---

### **正解**

✅ **`gdisk`**

---

### **解説**

#### **1. `gdisk`（正解）**

- **GPT（GUID Partition Table）専用のパーティション操作ツール**。
- `fdisk` の **GPT 版** であり、**MBR ではなく GPT を扱うために設計されたコマンド**。
- **パーティションの作成、削除、変更、表示** などが可能。
- 実行例：

  ```bash
  sudo gdisk /dev/sda
  ```

  - 対話モードでパーティション操作を実行可能。

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk - fdisk は MBR（Master Boot Record）専用 のコマンド。- GPT には対応していない（fdisk で GPT ディスクを扱うと、警告が出ることがある）。

⸻

❌ gptedit - 実在しないコマンド。

⸻

❌ partition - Linux にこの名前のパーティション管理コマンドは存在しない。

⸻

❌ gptdisk - 実在しないコマンド。- GPT を操作するには gdisk を使用する。

⸻

### まとめ

```
コマンド 説明 正解か
gdisk GPT 形式のパーティションを作成・削除・変更・表示するコマンド ✅
fdisk MBR 専用のパーティション管理ツール（GPT には非対応） ❌
gptedit 実在しないコマンド ❌
partition 実在しないコマンド ❌
gptdisk 実在しないコマンド ❌
```

⸻

💡 ポイント - GPT のパーティション管理には gdisk を使用する！- fdisk は MBR 専用であり、GPT には適用できない！- gptedit partition gptdisk などのコマンドは存在しない！

✅ 「GPT のパーティションを管理するなら gdisk！」

## MBR 形式のハードディスク `/dev/sda` のパーティションを操作するコマンド

### **問題**

MBR 形式のハードディスク **`/dev/sda`** の **パーティションを操作** したい。
適切なコマンドを選びなさい。

### **選択肢**

1. **`fdisk -l /dev/sda`**
2. **`fdisk -n /dev/sda`**
3. **`fdisk -c /dev/sda`**
4. **`fdisk /dev/sda`**
5. **`fdisk -p /dev/sda`**

---

### **正解**

✅ **`fdisk /dev/sda`**

---

### **解説**

#### **1. `fdisk /dev/sda`（正解）**

- **MBR 形式のパーティションを作成・削除・変更するための対話モードを開始するコマンド**。
- `fdisk` を実行すると、`Command (m for help):` のプロンプトが表示され、**対話モードでパーティションを操作できる**。
- 実行例：
  ```bash
  sudo fdisk /dev/sda
  ```
  - このモードで n（パーティション作成）、d（削除）、w（変更を保存） などのサブコマンドを使用可能。

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk -l /dev/sda - -l はパーティションテーブルを一覧表示するだけで、操作はできない。- パーティション情報の確認には便利だが、作成・削除・変更はできない。

⸻

❌ fdisk -n /dev/sda - -n というオプションは fdisk には存在しない。- パーティションを作成する場合は、fdisk の対話モードで n を入力する。

⸻

❌ fdisk -c /dev/sda - -c は古いバージョンの fdisk で互換モードを変更するオプション（現在はほぼ不要）。- パーティションの作成・削除・変更はできない。

⸻

❌ fdisk -p /dev/sda - -p というオプションは fdisk には存在しない。- パーティション情報を表示するなら fdisk -l を使用する。

⸻

### まとめ

```
コマンド	説明	正解か
fdisk /dev/sda	MBR 形式のパーティションを作成・削除・変更するための対話モードを開始	✅
fdisk -l /dev/sda	パーティションテーブルを表示する（操作は不可）	❌
fdisk -n /dev/sda	無効なオプション（存在しない）	❌
fdisk -c /dev/sda	互換モードを変更するオプション（パーティション操作は不可）	❌
fdisk -p /dev/sda	無効なオプション（存在しない）	❌
```

⸻

💡 ポイント - パーティションの作成・削除・変更を行うには fdisk /dev/sda を使う！- パーティションテーブルの表示だけなら fdisk -l /dev/sda！- -n や -p のようなオプションは存在しない！

✅ 「MBR のパーティションを操作するなら fdisk /dev/sda！」

## Btrfs ファイルシステムの特徴

### **問題**

Btrfs ファイルシステムの特徴として **正しいものを 2 つ選択** しなさい。

### **選択肢**

1. **ファイルの圧縮はサポートしていない**
2. **マルチデバイスに対応している**
3. **inode の数が制限される**
4. **ext3 の後継である**
5. **サブボリューム単位でのスナップショット機能がある**

---

### **正解**

✅ **マルチデバイスに対応している**
✅ **サブボリューム単位でのスナップショット機能がある**

---

### **解説**

#### **1. マルチデバイスに対応している（正解）**

- **Btrfs は複数のデバイスを 1 つのストレージプールとして管理できる**。
- **RAID 機能（RAID 0, 1, 10, 5, 6）を内蔵し、複数のストレージデバイスを統合可能**。
- 例：
  ```bash
  mkfs.btrfs -m raid1 -d raid1 /dev/sdb /dev/sdc
  ```
  - マルチデバイス管理機能が組み込まれているため、LVM を使わなくてもストレージ管理が柔軟にできる。

✅ 正解！

⸻

2. サブボリューム単位でのスナップショット機能がある（正解）
   - Btrfs は「サブボリューム」機能を持ち、これを単位としてスナップショットを作成できる。
   - サブボリュームごとにデータのスナップショットを取ることができるため、バックアップやシステムの復元に便利。
   - 例：

btrfs subvolume snapshot /mnt/data /mnt/snapshots/data-20240317

    -	スナップショットは差分で保存されるため、ディスク使用量が最小限に抑えられる。

✅ 正解！

⸻

誤った選択肢の解説

❌ ファイルの圧縮はサポートしていない - Btrfs はファイルの圧縮（zlib、lzo、zstd）をサポートしている。- 圧縮を有効にする例：

mount -o compress=zstd /dev/sda1 /mnt

    -	「ファイルの圧縮はサポートしていない」は誤り！

⸻

❌ inode の数が制限される - Btrfs は動的に inode を割り当てるため、inode の数に制限はない。- ext2/ext3/ext4 のようにファイルシステム作成時に inode 数を固定する方式ではない。

⸻

❌ ext3 の後継である - Btrfs は ext3 の後継ではなく、新しい設計の CoW（Copy-on-Write）ファイルシステム。- ext3 の後継は ext4 であり、Btrfs とは別系統のファイルシステム。

⸻

### まとめ

```

特徴 Btrfs の対応 正解か
マルチデバイスに対応している ✅（RAID 0, 1, 10, 5, 6 をサポート） ✅
サブボリューム単位でのスナップショット機能がある ✅（サブボリュームごとにスナップショットが可能） ✅
ファイルの圧縮はサポートしていない ❌（zlib、lzo、zstd 圧縮をサポート） ❌
inode の数が制限される ❌（動的に inode を割り当てる） ❌
ext3 の後継である ❌（ext3 の後継は ext4、Btrfs は別系統） ❌

```

⸻

💡 ポイント - Btrfs はマルチデバイス対応！ RAID 機能を内蔵！- サブボリュームとスナップショット機能がある！- 動的 inode 割り当てなので inode 数の制限なし！- ext3 の後継ではなく、新しい CoW（Copy-on-Write）ファイルシステム！

✅ 「Btrfs はマルチデバイス & スナップショット対応！」

## Linuxのルートファイルシステムに使用できるファイルシステム

### **問題**

Linuxの **ルートファイルシステム（/）** に使用できるファイルシステムは次のうちどれか。
（**3つ選択**）

### **選択肢**

1. `ext4`
2. `iso9660`
3. `XFS`
4. `NTFS`
5. `ext3`

---

### **正解**

✅ **`ext3`**
✅ **`ext4`**
✅ **`XFS`**

---

### **解説**

#### **ルートファイルシステムとは？**

- Linux システムの中核を担う **`/`（ルート）ディレクトリを保持するファイルシステム**。
- 起動に必要なすべてのファイル、ライブラリ、設定ファイルが含まれるため、**信頼性とLinuxカーネルの互換性が必要**。

⸻

### **正解のファイルシステム**

#### **1. `ext3`**

- **古くから使用されているジャーナリングファイルシステム**。
- 信頼性が高く、現在でも多くのディストリビューションが対応。
- **ルートファイルシステムとして使用可能**。

✅ **正解！**

⸻

#### **2. `ext4`**

- **ext3 の後継で、現在の Linux で最も一般的なファイルシステム**。
- **大容量対応、高速化、信頼性向上などの機能が追加されている**。
- **多くの Linux ディストリビューションでルートファイルシステムとして標準使用されている**。

✅ **正解！**

⸻

#### **3. `XFS`**

- **高性能でスケーラブルなジャーナリングファイルシステム**。
- **Red Hat 系のディストリビューション（例：RHEL、CentOS、Rocky）でルートファイルシステムとして採用されていることが多い**。
- 大量ファイルや大規模データに強い。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`iso9660`**

- **CD-ROM や DVD-ROM などの読み取り専用メディア向けのファイルシステム**。
- 読み取り専用のため、**ルートファイルシステムとして使用不可**。

⸻

❌ **`NTFS`**

- **Windows のファイルシステム**。
- Linux でも読み書き可能だが、**完全な互換性や安定性が保証されない**。
- **カーネルレベルでの公式サポートが限定的で、ルートファイルシステムとしては推奨されない**。

⸻

### **まとめ**

| ファイルシステム | ルートに使用可否 | 理由                               | 正解か |
| ---------------- | ---------------- | ---------------------------------- | ------ |
| **`ext3`**       | ✅ 使用可能      | 古くから安定して使用されている     | ✅     |
| **`ext4`**       | ✅ 使用可能      | 現在の主流、信頼性と高速性         | ✅     |
| **`XFS`**        | ✅ 使用可能      | 大容量、高性能な FS、RHEL 系で採用 | ✅     |
| `iso9660`        | ❌ 使用不可      | 読み取り専用（CD/DVD 向け）        | ❌     |
| `NTFS`           | ❌ 使用非推奨    | Windows 用、完全な互換性なし       | ❌     |

⸻

💡 **ポイント**

- **ルートファイルシステムは「読み書き可能」で「信頼性のある Linux ネイティブ FS」が条件！**
- **主に使われるのは `ext4`、次いで `ext3` や `XFS`！**

✅ **「Linux のルートファイルシステムには `ext4`、`ext3`、`XFS` が使える！」**

## ディレクトリと配下の容量を単位付きで表示するコマンド

### **問題**

`dir` ディレクトリと、その配下にある **ディレクトリおよびファイルの容量を、分かりやすい単位（KB/MB/GB など）付きで表示したい**。
適切なコマンドを選びなさい。

### **選択肢**

1. `du -a dir`
2. `du -ah dir`
3. `du -c dir`
4. `du -s dir`
5. `du -sh dir`

---

### **正解**

✅ **`du -ah dir`**

---

### **解説**

#### **`du` コマンドとは？**

- **`du`（Disk Usage）コマンド**は、ファイルやディレクトリのディスク使用量を表示するためのコマンド。
- **`-h` オプションで「人間に読みやすい」形式（KB/MB/GBなど）で表示**される。

---

### **正解のコマンド**

#### **`du -ah dir`**

- `-a`（all）：**すべてのファイルとディレクトリの使用量を表示**
- `-h`（human-readable）：**サイズを KB/MB/GB 単位で見やすく表示**
- **目的に完全に一致するオプションの組み合わせ！**

✅ **正解！**

---

### **誤った選択肢の解説**

❌ **`du -a dir`**

- ファイルとディレクトリのサイズは表示されるが、**単位が付かない（バイト数）**。

⸻

❌ **`du -c dir`**

- `-c` は **合計を表示**するオプションであり、**単位表示や全ファイルのサイズ表示はしない**。

⸻

❌ **`du -s dir`**

- `-s` は **合計のみ（dir の総量）を表示**。
- **中のファイルやサブディレクトリのサイズは表示されない**。

⸻

❌ **`du -sh dir`**

- **`dir` 自体の合計サイズのみを単位付きで表示**する。
- **中の個別ファイルやディレクトリのサイズは表示されない**。

---

### **まとめ**

| コマンド         | 内容                                                   | 単位付き | 全ファイル表示 | 正解か |
| ---------------- | ------------------------------------------------------ | -------- | -------------- | ------ |
| **`du -ah dir`** | すべてのファイルとディレクトリのサイズを単位付きで表示 | ✅       | ✅             | ✅     |
| `du -a dir`      | 単位なしで全ファイル表示                               | ❌       | ✅             | ❌     |
| `du -c dir`      | 合計表示のみ（全ファイル不可）                         | ❌       | ❌             | ❌     |
| `du -s dir`      | 合計サイズのみ表示                                     | ❌       | ❌             | ❌     |
| `du -sh dir`     | 合計サイズのみを単位付きで表示                         | ✅       | ❌             | ❌     |

---

💡 **ポイント**

- **すべてのファイル・ディレクトリのサイズを確認したいなら `-a`！**
- **人間に読みやすい単位（KB/MB/GBなど）で見たいなら `-h`！**
- **`-ah` の組み合わせで、詳細＋単位表示を両立！**

✅ **「`du -ah dir` で、すべての容量を単位付きで見やすく表示！」**

## `e2fsck` コマンドで全ての問題を自動修復する方法

### **問題**

`e2fsck` コマンドで `/dev/sda4` をチェックする際に、
**ユーザーに確認せず、すべての問題を自動的に修復したい**。
適切なコマンドはどれか。

### **選択肢**

1. `e2fsck -auto /dev/sda4`
2. `e2fsck -n /dev/sda4`
3. `e2fsck -P /dev/sda4`
4. `e2fsck -p /dev/sda4`
5. `e2fsck -y /dev/sda4`

---

### **正解**

✅ **`e2fsck -p /dev/sda4`**

---

### **解説**

#### **`e2fsck` コマンドとは**

- **ext2/ext3/ext4 ファイルシステムの整合性チェックと修復を行うコマンド**。
- ファイルシステムに破損があった場合、問題点を報告し、必要であれば修復を試みる。

---

### **正解のオプション**

#### **`-p`（または `--preen`）**

- **ユーザーへの確認なしに、安全と思われる修復を自動的に実行する**。
- 通常は **システム起動時に自動チェック用として使用される**。
- 危険な修復操作（ファイルの削除など）は行わず、基本的な修復のみに限定。

✅ **正解！**

---

### **他の選択肢の解説**

❌ **`-auto`**

- **存在しないオプション**。
- `e2fsck` には `-auto` というオプションは定義されていない。

⸻

❌ **`-n`**

- **読み取り専用チェックを行う（変更はしない）**。
- どのような問題があるかを確認する用途には便利だが、**修復は行わない**。

⸻

❌ **`-P`**

- **複数のデバイスを並列でチェックする時の制御用**（複数デバイスを扱うスクリプト向け）。
- **単体のデバイスチェックで自動修復には関係なし**。

⸻

❌ **`-y`**

- **すべての質問に「yes」で自動応答する**。
- `-p` よりも強力で、**すべての修復操作を強制的に実行する**ため、**危険な修復も行われる可能性がある**。
- 完全自動化には便利だが、安全性を重視するなら `-p` の方が推奨される。

---

### **まとめ**

| オプション | 内容                               | 自動修復 | 安全性               | 正解か |
| ---------- | ---------------------------------- | -------- | -------------------- | ------ |
| **`-p`**   | 基本的な修復を自動実行（確認なし） | ✅       | 高い                 | ✅     |
| `-y`       | すべての操作に「yes」で応答        | ✅       | やや低い（強制修復） | ❌     |
| `-n`       | 読み取り専用で確認のみ             | ❌       | 高い                 | ❌     |
| `-P`       | 並列チェック制御用                 | ❌       | ―                    | ❌     |
| `-auto`    | 存在しないオプション               | ❌       | ―                    | ❌     |

---

💡 **ポイント**

- **安全に自動修復したい場合は `-p` オプション**
- **強制的にすべて修復したい場合は `-y` も使えるが、注意が必要**
- **チェックのみなら `-n`、情報だけ確認できる**

✅ **「基本的な自動修復を行いたいなら `e2fsck -p /dev/sda4`！」**

## ファイルやディレクトリが占めている容量を確認するコマンド

### **問題**

**ファイルやディレクトリが占めている容量** を確認できるコマンドは次のうちどれか。

### **選択肢**

1. `du`
2. `df`
3. `mkfs`
4. `ps`
5. `fdisk`

---

### **正解**

✅ **`du`**

---

### **解説**

#### **`du`（Disk Usage）**

- **ファイルやディレクトリ単位でディスクの使用量を表示するコマンド**。
- 指定したディレクトリ以下の各ファイル・ディレクトリが**どれだけのディスク容量を使用しているかを確認できる**。
- オプション例：
  ```bash
  du -sh /path/to/dir
  ```
  - -s: 合計のみ表示
  - -h: 人間に読みやすい単位で表示（KB/MB/GB）

✅ 正解！

⸻

誤った選択肢の解説

❌ df - ファイルシステム全体の使用量を確認するコマンド。- 各ファイルやディレクトリ単位の容量はわからない。- 使用例：

df -h

⸻

❌ mkfs - 新しくファイルシステムを作成するコマンド。- 使用量の確認には使えない。

⸻

❌ ps - プロセスの一覧を表示するコマンド。- ディスク容量とは無関係。

⸻

❌ fdisk - パーティションテーブルを操作するコマンド。- ファイルやディレクトリの容量確認には使えない。

⸻

### まとめ

```
コマンド	用途	容量確認	正解か
du	ファイル・ディレクトリごとの使用量表示	✅	✅
df	ファイルシステム全体の使用状況確認	❌	❌
mkfs	ファイルシステムの作成	❌	❌
ps	プロセスの表示	❌	❌
fdisk	パーティション操作	❌	❌
```

⸻

💡 ポイント - 個別のファイルやフォルダのサイズを見るなら du - ディスク全体の空き容量を確認するなら df - 用途に応じて使い分けよう！

✅ 「ファイルやディレクトリの容量を知りたいなら du！」

## XFSファイルシステムをチェックするコマンド

### **問題**

**XFSファイルシステムのチェック**を行うための適切なコマンドはどれか。

### **選択肢**

1. `xfs_check`
2. `xfs_fsck`
3. `xfs_db`
4. `xfs_info`
5. `mkfs.xfs`

---

### **正解**

✅ **`xfs_check`**

---

### **解説**

#### **`xfs_check`**

- **XFSファイルシステムの整合性をチェックするためのコマンド**。
- **読み取り専用でメタデータのチェックを行う**。
- 実行例：
  ```bash
  sudo xfs_check /dev/sdXn
  ```
  - 注意：マウントされていない状態で使う必要がある。

✅ 正解！

⸻

他の選択肢の解説

❌ xfs*fsck - 存在しないコマンド。- XFS では fsck の代わりに専用の xfs*\* 系ツールを使う。

⸻

❌ xfs_db - XFSのメタデータに対して対話的なアクセスやデバッグを行うツール。- チェック用ではなく、内部構造を調査・修復に使う低レベルツール。

⸻

❌ xfs_info - XFSファイルシステムの情報（ブロックサイズやinodeサイズなど）を表示するコマンド。- チェックではない。

⸻

❌ mkfs.xfs - XFSファイルシステムを新規に作成するためのコマンド。- チェックとは関係ない。

⸻

### まとめ

```

コマンド 用途 正解か
xfs_check XFSファイルシステムの整合性チェック ✅
xfs_fsck 存在しないコマンド ❌
xfs_db メタデータの調査・デバッグ用 ❌
xfs_info XFSの情報表示（構成確認） ❌
mkfs.xfs XFSファイルシステムの作成 ❌

```

⸻

💡 ポイント - xfs_check は XFS 専用のファイルシステムチェックツール！- マウントされていない状態で使うこと！- 最近では xfs_repair -n が推奨されることもあるが、選択肢にない場合は xfs_check が正解！

✅ 「XFS のチェックには xfs_check！」

## ext2/ext3/ext4 ファイルシステムのボリュームラベルを設定するオプション

### **問題**

ext2/ext3/ext4 ファイルシステムのボリュームラベルを設定する
`tune2fs` コマンドの適切なオプションはどれか。

### **選択肢**

1. `-L`
2. `-a`
3. `-j`
4. `-i`
5. `-c`

---

### **正解**

✅ **`-L`**

---

### **解説**

#### **`-L` オプション**

- **`tune2fs` コマンドでファイルシステムにラベル（名前）を設定・変更するためのオプション**。
- 対象は ext2/ext3/ext4 ファイルシステム。
- 使用例：

```bash
sudo tune2fs -L MyVolume /dev/sdXn
```

    -	この例では /dev/sdXn に MyVolume というラベルを設定。

✅ 正解！

⸻

誤った選択肢の解説

❌ -a - tune2fs には -a オプションは存在しない。

⸻

❌ -j - ext2 を ext3 に変換するための mke2fs コマンド用オプションであり、tune2fs のラベル設定とは無関係。

⸻

❌ -i - 自動チェックの間隔（日数）を設定するオプション。- 例：tune2fs -i 10 /dev/sda1 は10日ごとに自動チェック。

⸻

❌ -c - マウント回数によるチェックの設定。- 例：tune2fs -c 20 /dev/sda1 は20回マウントごとにチェック。

⸻

### まとめ

```
オプション	説明	正解か
-L	ボリュームラベルの設定	✅
-a	無効なオプション（存在しない）	❌
-j	mke2fs 用：ext2→ext3 変換	❌
-i	自動チェックの間隔（日数）	❌
-c	マウント回数によるチェック設定	❌
```

⸻

💡 ポイント - ボリュームラベルの設定は tune2fs -L ラベル名 デバイス名 - ラベルは e2label コマンドでも確認・設定できる

✅ 「ボリュームラベルの設定は -L オプション！」

## ext2/ext3/ext4ファイルシステム作成時に予約される領域

### **問題**

ext2/ext3/ext4 ファイルシステムを作成した時に、**rootユーザ用に予約される領域**として正しいものはどれか。

### **選択肢**

1. 200MB
2. ファイルシステム全体の5%
3. 1GB
4. ファイルシステム全体の1%
5. デフォルトでは予約されない

---

### **正解**

✅ **ファイルシステム全体の5%**

---

### **解説**

#### **予約領域とは？**

- ext2/ext3/ext4 ファイルシステムでは、**システムの安定性や緊急時の復旧を目的として、ファイルシステムの一部を root ユーザ専用に予約**する。
- この予約領域により、一般ユーザがディスクを100%使い切っても、**root ユーザはログインして復旧作業ができる**ように設計されている。

#### **デフォルト値**

- `mke2fs` または `mkfs.ext4` などでファイルシステムを作成する際、**デフォルトで 5% の領域が root 用に予約される**。

✅ **正解！**

---

### **確認・変更方法**

#### **確認**

```bash
sudo tune2fs -l /dev/sdXn | grep 'Reserved block count'
```

変更（例：1%に変更）

sudo tune2fs -m 1 /dev/sdXn

    -	-m は予約領域の割合（%）を指定するオプション。

⸻

誤った選択肢の解説

❌ 200MB / 1GB - 固定サイズではなく、全体容量に対するパーセンテージで指定される。

❌ ファイルシステム全体の1% - 変更すれば1%に設定可能だが、デフォルトは5%。

❌ デフォルトでは予約されない - ext2/ext3/ext4 の初期設定では 5% が予約されるため誤り。

⸻

### まとめ

```
選択肢	内容	正解か
200MB	固定サイズ → 誤り	❌
ファイルシステム全体の5%	デフォルト設定	✅
1GB	固定サイズ → 誤り	❌
ファイルシステム全体の1%	設定変更は可能だがデフォルトではない	❌
デフォルトでは予約されない	ext系では予約されるため誤り	❌
```

⸻

💡 ポイント - ext2/ext3/ext4 のファイルシステムは、デフォルトで5%の容量を root のために予約！- tune2fs -m を使って変更可能！

✅ 「予約領域はファイルシステム全体の 5%！」

## fsckコマンドでファイルシステムの整合性を自動修復するオプション

### **問題**

`fsck` コマンドでファイルシステムの整合性をチェックする際、
**障害箇所を自動的に修復したい**。
適切なオプションはどれか。

### **選択肢**

1. `-a`
2. `-N`
3. `-auto`
4. `-r`
5. `-A`

---

### **正解**

✅ **`-a`**

---

### **解説**

#### **`-a` オプション**

- **自動修復（非対話モード）**で整合性を修復するためのオプション。
- **fsck が見つけたエラーに対して、自動的に「yes」で修復を進める**。
- **一部のファイルシステム（特に ext 系）でのみ有効**。
- 使用例：
  ```bash
  sudo fsck -a /dev/sdXn
  ```

✅ 正解！

⸻

誤った選択肢の解説

❌ -N - 実行されるコマンドを表示するだけで実行しないオプション（dry-run的な用途）。

❌ -auto - 存在しないオプション。- 自動修復には -a または -y を使う。

❌ -r - 対話式モード。ユーザーに修復の確認を求めるオプション。- 自動ではないため、誤り。

❌ -A - /etc/fstab にあるすべてのファイルシステムをチェック対象にするオプション。- 修復の自動化とは直接関係しない。

⸻

### まとめ

```
オプション 内容 自動修復 正解か
-a 自動修復（yesで進行） ✅ ✅
-N 実行内容を表示するだけ（実行しない） ❌ ❌
-auto 存在しないオプション ❌ ❌
-r 対話式修復（確認あり） ❌ ❌
-A 全ファイルシステムチェック（fstab） ❌ ❌
```

⸻

💡 ポイント - fsck -a でエラーを自動修復！（一部ファイルシステムのみ対応）- 対話なしで完全自動なら -y も使用可能（-a より強力）

✅ 「自動で修復したいなら fsck -a を使おう！」

## ファイルシステムのチェック間隔を3日間に変更するコマンド

### **問題**

`/dev/sda2` の **ファイルシステムをチェックする間隔** を **3日ごと** に設定したい。
適切なコマンドを **2つ選択**しなさい。

### **選択肢**

1. `tune2fs -D 3i /dev/sda2`
2. `tune2fs -i 3d /dev/sda2`
3. `tune2fs -i 3 /dev/sda2`
4. `tune2fs -day 3 /dev/sda2`

---

### **正解**

✅ **`tune2fs -i 3d /dev/sda2`**
✅ **`tune2fs -i 3 /dev/sda2`**

---

### **解説**

#### **`tune2fs` コマンド**

- `tune2fs` は **ext2/ext3/ext4 ファイルシステムの設定を調整するコマンド**。
- `-i` オプションは **fsck による自動チェックの間隔（days/weeks/months）を指定**する。

---

### **正しいコマンド**

#### **1. `tune2fs -i 3d /dev/sda2`**

- **3日ごとに自動チェックする**ように設定。
- `3d` は「3 days（3日）」を意味する。

✅ **正解！**

⸻

#### **2. `tune2fs -i 3 /dev/sda2`**

- デフォルトでは単位なしの数字は「日（days）」と解釈されるため、**これも「3日間隔」を意味する**。

✅ **正解！**

---

### **誤った選択肢の解説**

❌ **`tune2fs -D 3i /dev/sda2`**

- 存在しないオプションと無効な構文。
- `-D` も `3i` も不正。

⸻

❌ **`tune2fs -day 3 /dev/sda2`**

- `-day` というオプションは存在しない。

---

### **まとめ**

| コマンド                      | 説明                            | 正解か |
| ----------------------------- | ------------------------------- | ------ |
| **`tune2fs -i 3d /dev/sda2`** | **3日間隔で自動チェック**       | ✅     |
| **`tune2fs -i 3 /dev/sda2`**  | **単位なしでも3日と解釈される** | ✅     |
| `tune2fs -D 3i /dev/sda2`     | 存在しないオプション            | ❌     |
| `tune2fs -day 3 /dev/sda2`    | 無効なオプション                | ❌     |

---

💡 **ポイント**

- **`tune2fs -i` オプションで自動fsckの実行間隔（日数・週・月）を設定可能！**
- 単位は `d`（days）、`w`（weeks）、`m`（months）

✅ **「`tune2fs -i 3d /dev/sda2` または `-i 3` で3日間隔に設定！」**

## ファイルシステムをチェックせずにマウントできる回数を変更するコマンド

### **問題**

ファイルシステムをチェックせずに「/dev/sda2」が**マウントできる回数**を **10回** に変更したい。
適切なコマンドはどれか。

### **選択肢**

1. `tune2fs -c 10 /dev/sda2`
2. `tune2fs -L 10 /dev/sda2`
3. `tune2fs -j 10 /dev/sda2`
4. `tune2fs -mount 10 /dev/sda2`
5. `tune2fs -i 10 /dev/sda2`

---

### **正解**

✅ **`tune2fs -c 10 /dev/sda2`**

---

### **解説**

#### **`-c` オプション**

- `-c` は **fsck（ファイルシステムチェック）が実行されるまでの最大マウント回数**を設定するオプション。
- **指定回数マウントされたら、自動的に fsck によるチェックが実行される**。
- 使用例：

```bash
sudo tune2fs -c 10 /dev/sda2
```

    -	このコマンドにより、「10回マウントされるまで fsck をスキップ」する設定になる。

✅ 正解！

⸻

誤った選択肢の解説

❌ -L - ファイルシステムのラベル（名前）を設定するオプション。マウント回数とは無関係。

❌ -j - ext2 を ext3 に変換するためのジャーナリング機能を追加するオプション（mke2fs用）。

❌ -mount - 存在しないオプション。誤記。

❌ -i - 日数ベースでチェック間隔を指定するオプション（例：-i 10d = 10日ごとにチェック）。- マウント回数ではなく、時間ベースのチェック設定。

⸻

### まとめ

```
オプション	説明	正解か
-c	マウント回数でチェックを行う条件を設定	✅
-L	ラベル（名前）を設定	❌
-j	ジャーナリング機能を追加（ext2→ext3）	❌
-mount	存在しないオプション	❌
-i	チェック実行間隔（日数）を設定	❌
```

⸻

💡 ポイント - マウント回数ベースでチェックを制御するには -c オプション！- 時間間隔ベースなら -i、ラベル変更なら -L を使う！

✅ 「tune2fs -c 10 /dev/sda2 で、10回マウントするまで fsck をスキップ！」

## `fsck`コマンドで実行せずに内容だけ表示する方法（ext3の例）

### **問題**

`fsck` コマンドで **ext3 ファイルシステム `/dev/sda4` の整合性をチェック**する際、
**実際には実行せず、「何が行われるか」だけを表示したい**。
適切なコマンドはどれか。

### **選択肢**

1. `fsck ext3 /dev/sda4`
2. `fsck -t -A ext3 /dev/sda4`
3. `fsck -t -N ext3 /dev/sda4`
4. `fsck -t ext3 /dev/sda4`
5. `fsck -N -t ext3 /dev/sda4`

---

### **正解**

✅ **`fsck -N -t ext3 /dev/sda4`**

---

### **解説**

#### **`-N` オプション**

- **実行されるコマンドを表示するだけで、実際には何も実行しない**（dry-run）。
- スクリプトでのテストや確認に便利。

#### **`-t ext3`**

- **対象のファイルシステムタイプ（ここでは ext3）を明示的に指定**。
- `fsck` は複数のファイルシステムに対応しているため、必要に応じて明示することで適切なサブコマンド（`fsck.ext3` など）を選択する。

#### **使用例**

```bash
sudo fsck -N -t ext3 /dev/sda4
```

    -	出力例（実際の修復は行われず、内部的にどのコマンドが実行されるかを表示）：

```
Would execute command: fsck.ext3 /dev/sda4
```

✅ 正解！

⸻

誤った選択肢の解説

❌ fsck ext3 /dev/sda4 - 不正な構文。- ext3 がデバイス名のように解釈されてしまうため、正しく動作しない。

⸻

❌ fsck -t -A ext3 /dev/sda4 - -A は /etc/fstab に基づいて全ファイルシステムを処理するためのもので、単一のデバイス /dev/sda4 と併用するのは不自然。- -t の直後にファイルシステムタイプがないため構文ミスでもある。

⸻

❌ fsck -t -N ext3 /dev/sda4 - オプションの順序と構文が正しくない。- -t に続くファイルシステムタイプ ext3 が -N に割り込まれてしまっている。

⸻

❌ fsck -t ext3 /dev/sda4 - 正常に ext3 のチェックは実行されるが、実行を「表示するだけ」ではないため不正解。

⸻

### まとめ

```
コマンド 内容 実行されるか 正解か
fsck -N -t ext3 /dev/sda4 実行せず内容のみ表示 ❌ 実行されない ✅
fsck ext3 /dev/sda4 構文ミス ― ❌
fsck -t -A ext3 /dev/sda4 全体対象＋構文不正 実行される可能性あり ❌
fsck -t -N ext3 /dev/sda4 オプション順序が不正 ― ❌
fsck -t ext3 /dev/sda4 実行される（表示のみではない） ✅ 実行される ❌
```

⸻

💡 ポイント - -N：実行内容だけ表示（dry-run）- -t ファイルシステムタイプ：対象FSを明示 - fsck -N -t ext3 /dev/sda4 で実際には何もせず内容だけ表示できる！

✅ 「実行せず内容だけ確認したいなら fsck -N -t ext3 /dev/sda4！」

## XFSファイルシステムの情報を表示するコマンド

### **問題**

XFSファイルシステムの**情報を表示するための適切なコマンド**はどれか。

### **選択肢**

1. `mkfs.xfs`
2. `info.xfs`
3. `check.xfs`
4. `xfs_db`
5. `xfs_info`

---

### **正解**

✅ **`xfs_info`**

---

### **解説**

#### **`xfs_info` コマンド**

- **XFSファイルシステムの詳細情報（ブロックサイズ、セクタサイズ、ログ情報など）を表示するコマンド**。
- マウントされた XFS ファイルシステムに対して使用する。
- 使用例：

```bash
sudo xfs_info /mnt/data
```

    -	出力例：

```
meta-data=/dev/sda1              isize=512    agcount=4, agsize=327680 blks
         =                       sectsz=512   attr=2, projid32bit=1
```

...

✅ 正解！

⸻

誤った選択肢の解説

❌ mkfs.xfs - XFSファイルシステムを新しく作成するコマンド。- 情報を表示する用途ではない。

⸻

❌ info.xfs - 存在しないコマンド。

⸻

❌ check.xfs - 存在しないコマンド名。チェックは xfs_check または xfs_repair で行う。

⸻

❌ xfs_db - XFSメタデータを操作・調査するための対話的な低レベルツール。- 詳細情報の表示は可能だが、通常の情報確認には不向き。

⸻

### まとめ

```
コマンド	内容	正解か
xfs_info	XFSファイルシステムの基本情報表示	✅
mkfs.xfs	XFSファイルシステムの作成	❌
info.xfs	存在しない	❌
check.xfs	存在しない	❌
xfs_db	メタデータの調査・操作用（上級者向け）	❌
```

⸻

💡 ポイント - XFSの基本情報を確認したいなら xfs_info！- 高度な調査は xfs_db、整合性チェックは xfs_check や xfs_repair を使おう

✅ 「XFS の情報表示には xfs_info！」

## inodeの使用状況を確認するコマンド

### **問題**

inode の**使用状況（使用中/残りの数）**を確認するための適切なコマンドはどれか。

### **選択肢**

1. `df -h`
2. `df -i`
3. `df -u`
4. `df -I`
5. `df -H`

---

### **正解**

✅ **`df -i`**

---

### **解説**

#### **`df -i`**

- **ディスクの inode 使用状況（使用済み/空き）を表示するオプション**。
- 各マウントポイントごとの inode の数と使用率が確認できる。
- 使用例：

```bash
df -i
```

    -	出力例：

```
Filesystem     Inodes  IUsed   IFree IUse% Mounted on
/dev/sda1     6553600 125000 6428600    2% /
```

✅ 正解！

⸻

誤った選択肢の解説

❌ df -h - ディスク容量（サイズ・使用量）を「人間に読みやすい単位」で表示。- inode の情報は表示されない。

⸻

❌ df -u - 存在しないオプション。無効。

⸻

❌ df -I - df に -I オプションは存在しない。大文字小文字にも注意。

⸻

❌ df -H - ディスク容量を 1000バイト単位（SI単位） で表示。- inode とは無関係。

⸻

まとめ

コマンド 説明 inode表示 正解か
df -i inodeの使用状況を表示 ✅ ✅
df -h 容量を人間に読みやすく表示（MB/GBなど） ❌ ❌
df -u 存在しないオプション ❌ ❌
df -I 存在しないオプション（大文字） ❌ ❌
df -H 容量をSI単位（1000バイト）で表示 ❌ ❌

⸻

💡 ポイント - df -i で inode の「使用中」「残り」「使用率」が確認できる！- inode を使い切ると空き容量があってもファイルが作れなくなるので注意！

✅ 「inode の使用状況を確認するには df -i！」
