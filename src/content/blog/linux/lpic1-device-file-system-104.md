---
author: Taro Gray
pubDatetime: 2025-01-31T08:00:00.000Z
title: デバイス、Linuxファイルシステム、FHS (主題104)編
postSlug: lpic1-device-file-system
featured: true
ogImage: https://github.com/satnaing/astro-paper/assets/53733092/1ef0cf03-8137-4d67-ac81-84a032119e3a
tags:
  - Linux
description: デバイス、Linuxファイルシステム、FHS (主題104)編
---

## `parted` を使用して MBR 形式の新しいハードディスクにパーティションを作成する方法

### **問題**

`parted` を使用して、新しいハードディスクに以下の要件の通りパーティションを作成した。

- **先頭に 1000MB の基本パーティションを作成**
- **ファイルシステムは ext4**
- **パーティションテーブルは MBR 形式**

次のコマンドのうち、**正しくパーティションを作成するために必要なものを選びなさい**。（**全て選択**）

### **選択肢**

1. `mklabel gpt`
2. `print`
3. `mkpart primary ext4 1 1000MB`
4. `mklabel mbr`
5. `mklabel msdos`
6. `create ext4 1 1000MB`
7. `show`
8. `mkpart 1 1000MB`

---

### **正解**

✅ **`mklabel msdos`**  
✅ **`print`**  
✅ **`mkpart primary ext4 1 1000MB`**

---

### **解説**

#### **1. `mklabel msdos`**

- **MBR 形式のパーティションテーブルを作成するコマンド**。
- MBR（Master Boot Record）形式のパーティションテーブルを作成するために必要。
- `msdos` は MBR の別名。

✅ **正解！**

⸻

#### **2. `print`**

- **現在のパーティションテーブルの状態を確認するコマンド**。
- 作成したパーティションが正しく認識されているか確認するために使用。
  ✅ **正解！** ⸻ #### **3. `mkpart primary ext4 1 1000MB`**

- **1000MB の基本（primary）パーティションを作成するコマンド**。
- `mkpart primary <ファイルシステム> <開始位置> <終了位置>` の形式で指定。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mklabel gpt`**

- **GPT（GUID Partition Table）形式のパーティションテーブルを作成するコマンド**。
- 問題では **MBR 形式** のパーティションテーブルを作成するため **不正解**。

⸻

❌ **`create ext4 1 1000MB`**

- **`parted` にこのようなコマンドは存在しない**。
- **パーティションを作成する場合は `mkpart` を使用する**。

⸻

❌ **`mklabel mbr`**

- **`parted` では MBR 形式のパーティションテーブルを作成する場合、`mklabel msdos` を使用する**。
- `mklabel mbr` というコマンドは **存在しない**。

⸻

❌ **`show`**

- **`parted` には `show` というコマンドは存在しない**。
- パーティション情報を確認するには **`print`** を使用する。

⸻

❌ **`mkpart 1 1000MB`**

- `mkpart` コマンドの **書式が間違っている**。
- 正しくは **`mkpart primary ext4 1 1000MB`**。

⸻

### **まとめ**

| コマンド                         | 目的                                               | 正解か |
| -------------------------------- | -------------------------------------------------- | ------ |
| **mklabel msdos**                | **MBR（msdos）形式のパーティションテーブルを作成** | ✅     |
| **print**                        | **パーティションの状態を確認**                     | ✅     |
| **mkpart primary ext4 1 1000MB** | **1000MB の基本パーティションを作成**              | ✅     |
| mklabel gpt                      | GPT（GUID Partition Table）形式を作成              | ❌     |
| create ext4 1 1000MB             | 無効なコマンド                                     | ❌     |
| mklabel mbr                      | 無効なコマンド                                     | ❌     |
| show                             | 無効なコマンド                                     | ❌     |
| mkpart 1 1000MB                  | 書式が間違っている                                 | ❌     |

⸻

💡 **ポイント**

- **MBR 形式を指定するには `mklabel msdos`**
- **パーティション作成は `mkpart primary ext4 1 1000MB`**
- **パーティション確認には `print`**
- **GPT 形式（`mklabel gpt`）は今回のケースでは不適切！**

✅ **「parted で MBR のパーティションを作成するなら `mklabel msdos` → `mkpart primary ext4 1 1000MB` → `print` で確認！」**

## `fdisk -l /dev/sda` の出力からスワップ領域のパーティションを特定する

### **問題**

以下は、コマンド `fdisk -l /dev/sda` の表示結果からの抜粋である。  
**パーティションタイプがスワップ領域のパーティション** はどれか。

### **選択肢**

1. `/dev/sda1`
2. `/dev/sda5`
3. `/dev/sda2`
4. `/dev/sda6`

---

### **正解**

✅ **`/dev/sda6`**

---

### **解説**

`fdisk -l /dev/sda` コマンドは、指定したディスク `/dev/sda` のパーティションテーブルを表示します。各パーティションの詳細情報には、**パーティション番号**、**開始位置**、**終了位置**、**サイズ**、**タイプ**などが含まれます。

**スワップ領域**として使用されるパーティションは、通常、**パーティションタイプが `82`**（`Linux swap`）に設定されています。以下に、`fdisk -l /dev/sda` の出力例を示します。

```
Disk /dev/sda: 100 GB, 100000000000 bytes
255 heads, 63 sectors/track, 12158 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
```

```
Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1        1045     8385861   83  Linux
/dev/sda2            1046        2090     8385862+  83  Linux
/dev/sda3            2091        3135     8385862+  83  Linux
/dev/sda4            3136        3187      418492+   5  Extended
/dev/sda5            3136        3187      418460   82  Linux swap / Solaris
```

上記の例では、`/dev/sda5` のパーティションタイプが `82`（`Linux swap / Solaris`）となっており、**スワップ領域**として使用されることがわかります。

**注意点**：

- **パーティションタイプ `82`** は、**スワップ領域**を示します。
- **パーティションタイプ `83`** は、**Linuxファイルシステム**（`ext4` など）を示します。
- **パーティションタイプ `5`** は、**拡張パーティション**を示します。

したがって、`fdisk -l /dev/sda` の出力を確認し、**パーティションタイプが `82`** に設定されているパーティションを探すことで、**スワップ領域**として使用されているパーティションを特定できます。

---

### **まとめ**

- **スワップ領域のパーティションタイプ**：`82`（`Linux swap`）
- **`fdisk -l` コマンドの出力**を確認し、**パーティションタイプが `82`** のパーティションを探す
- **正解**：`/dev/sda6`（パーティションタイプが `82` の場合）

---

💡 **ポイント**

- **`fdisk -l` コマンド**でディスクのパーティション情報を確認できる
- **スワップ領域**のパーティションタイプは**`82`**
- **パーティションタイプ**を確認して、**スワップ領域**を特定しよう！

✅ **「`fdisk -l` でパーティションタイプ `82` を探せば、スワップ領域がわかる！」**

## `mkfs` または `mke2fs` コマンドで不良ブロックを検査してからファイルシステムを作成する方法

### **問題**

`mkfs` または `mke2fs` コマンドでファイルシステムを作成する際、**不良ブロックがないか検査してから作成** したい。  
適切なオプションを選びなさい。

### **選択肢**

1. `-a`
2. `-k`
3. `-c`
4. `-s`
5. `-e`

---

### **正解**

✅ **`-c`**

---

### **解説**

`mkfs` や `mke2fs` コマンドでファイルシステムを作成する際に、**不良ブロック（bad blocks）を事前に検査するには `-c` オプションを使用** します。

#### **1. `-c` オプションの意味**

- **不良ブロックをチェックしてからファイルシステムを作成**
- **事前に `badblocks` コマンドを実行し、壊れたブロックをマーク**
- 例：
  ```bash
  mkfs.ext4 -c /dev/sdb1
  ```
  または

```
mke2fs -c /dev/sdb1
```

✅ 正解！

⸻

誤った選択肢の解説

❌ -a - mkfs コマンドや mke2fs には -a オプションは 存在しない。- 間違い！

⸻

❌ -k - mke2fs -k は、既存のスーパーブロックを 保持（keep） するオプション。- 不良ブロックのチェックには関係しない。- 間違い！

⸻

❌ -s - mke2fs -s は、スーパーブロックのバックアップ数を設定 するオプション。- 不良ブロックのチェックには関係しない。- 間違い！

⸻

❌ -e - mke2fs -e <オプション> は、不良ブロックが検出された際のエラー処理方法を設定 するオプション。- 不良ブロックを検査するのではなく、検出後の動作を決める。- 間違い！

⸻

まとめ

```

オプション 目的 正解か
-c 不良ブロックを検査してからファイルシステムを作成 ✅
-a 無効なオプション（存在しない） ❌
-k 既存のスーパーブロックを保持する ❌
-s スーパーブロックのバックアップ数を設定 ❌
-e 不良ブロック発生時のエラー処理方法を設定 ❌

```

⸻

💡 ポイント - 不良ブロックをチェックしてから作成するなら -c！- 事前に badblocks を実行するため、安全なディスクセットアップが可能！

✅ 「mkfs.ext4 -c /dev/sdb1 で不良ブロックをチェックしてからフォーマット！」

## `ext2` ファイルシステムを `/dev/hda1` に作成する方法

### **問題**

`ext2` ファイルシステムを **`/dev/hda1`** に作成したい。
適切なコマンドを **全て選択** しなさい。

### **選択肢**

1. `mke2fs /dev/hda1`
2. `mkfs -t ext2 /dev/hda1`
3. `mke2fs -j /dev/hda1`
4. `mkfs /dev/hda1`
5. `mkfs -c ext2 /dev/hda1`

---

### **正解**

✅ **`mkfs -t ext2 /dev/hda1`**
✅ **`mke2fs /dev/hda1`**
✅ **`mkfs /dev/hda1`**

---

### **解説**

#### **1. `mke2fs /dev/hda1`**

- `mke2fs` は **`ext2` ファイルシステムを作成するための専用コマンド**。
- `mke2fs` のデフォルトは **`ext2`** なので、オプションなしで `ext2` ファイルシステムを作成できる。

✅ **正解！**

⸻

#### **2. `mkfs -t ext2 /dev/hda1`**

- `mkfs` は **汎用的なファイルシステム作成コマンド**。
- `-t ext2` を指定することで、`ext2` ファイルシステムを作成できる。

✅ **正解！**

⸻

#### **3. `mkfs /dev/hda1`**

- `mkfs` はデフォルトで `ext2` を作成する場合がある（システムの設定による）。
- `mkfs` の挙動は `mke2fs` に依存するため、**デフォルトが `ext2` なら正しく動作する**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mke2fs -j /dev/hda1`**

- `-j` オプションをつけると **`ext3` ファイルシステムが作成される**。
- **`ext2` ではなく `ext3` になるため不正解！**

⸻

❌ **`mkfs -c ext2 /dev/hda1`**

- `-c` は **不良ブロックのチェックを行うオプション**。
- ただし、正しい書式は **`mkfs -t ext2 -c /dev/hda1`** なので、**書式が誤っている**。

⸻

### **まとめ**

| コマンド                     | 説明                                                    | 正解か |
| ---------------------------- | ------------------------------------------------------- | ------ |
| **`mkfs -t ext2 /dev/hda1`** | **汎用 `mkfs` コマンドで `ext2` を作成**                | ✅     |
| **`mke2fs /dev/hda1`**       | **`ext2` 作成専用のコマンド**                           | ✅     |
| **`mkfs /dev/hda1`**         | **デフォルトで `ext2` を作成する場合がある**            | ✅     |
| `mke2fs -j /dev/hda1`        | `-j` により `ext3` が作成される                         | ❌     |
| `mkfs -c ext2 /dev/hda1`     | `-c` の位置が間違っている（正しくは `mkfs -t ext2 -c`） | ❌     |

⸻

💡 **ポイント**

- **`mke2fs /dev/hda1` は `ext2` 作成の専用コマンド**
- **`mkfs -t ext2 /dev/hda1` も `ext2` を作成可能**
- **`mkfs /dev/hda1` もデフォルトが `ext2` なら動作する**
- **`-j` をつけると `ext3` になるので注意！**

✅ **「`mke2fs /dev/hda1` or `mkfs -t ext2 /dev/hda1` で `ext2` 作成！」**

## exFAT ファイルシステムの特徴

### **問題**

exFAT ファイルシステムの特徴として **正しいものを 2 つ選択** しなさい。

### **選択肢**

1. **4GiB以上の大容量のファイルを扱える**
2. **すべてのLinuxでデフォルトでマウントできる**
3. **FATの後継であり、FATと互換性がある**
4. **フラッシュドライブ向けのファイルシステムである**
5. **扱えるファイルの最大サイズは 4GiB である**

---

### **正解**

✅ **フラッシュドライブ向けのファイルシステムである**
✅ **4GiB以上の大容量のファイルを扱える**

---

### **解説**

#### **1. 4GiB以上の大容量のファイルを扱える**

- exFAT は **FAT32 の後継として開発** され、大容量のファイルを扱えるように設計された。
- **1 ファイルの最大サイズは 16EiB（エクサバイト）**。
- FAT32 では **4GiB を超えるファイルを扱えない** が、exFAT では可能。

✅ **正解！**

⸻

#### **2. フラッシュドライブ向けのファイルシステムである**

- exFAT は **USB メモリや SD カードなどのフラッシュストレージ向け** に最適化されている。
- **ジャーナリング機能を持たず、書き込み回数を減らす** ことで、フラッシュメモリの寿命を延ばす設計になっている。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **すべてのLinuxでデフォルトでマウントできる**

- exFAT は **Microsoft が開発した独自のファイルシステム**。
- 以前は **Linux ではデフォルトでサポートされていなかった**。
- **Linux カーネル 5.4 以降** では **ネイティブサポート** されたが、**古いディストリビューションでは `exfat-utils` パッケージをインストールしないと使えない**。

⸻

❌ **FATの後継であり、FATと互換性がある**

- exFAT は **FAT32 の後継として開発された** が、**FAT32 との直接的な互換性はない**。
- **FAT32 から exFAT に変換するにはフォーマットが必要** で、**そのまま互換性があるわけではない**。

⸻

❌ **扱えるファイルの最大サイズは 4GiB である**

- これは **FAT32 の制限**。
- **exFAT では 4GiB を超えるファイルを扱えるため誤り！**

⸻

### **まとめ**

| 特徴                                               | exFAT の対応                                 | 正解か |
| -------------------------------------------------- | -------------------------------------------- | ------ |
| **4GiB以上の大容量のファイルを扱える**             | **✅（最大 16EiB）**                         | ✅     |
| **すべてのLinuxでデフォルトでマウントできる**      | **❌（古いLinuxでは `exfat-utils` が必要）** | ❌     |
| **FATの後継であり、FATと互換性がある**             | **❌（FAT32 からの直接的な互換性はない）**   | ❌     |
| **フラッシュドライブ向けのファイルシステムである** | **✅（フラッシュメモリの寿命を考慮）**       | ✅     |
| **扱えるファイルの最大サイズは 4GiB である**       | **❌（これは FAT32 の制限）**                | ❌     |

⸻

💡 **ポイント**

- **exFAT は 4GiB を超えるファイルを扱える！**
- **exFAT はフラッシュストレージ向けに最適化！**
- **Linux ではカーネル 5.4 以降で標準サポートされているが、古い環境では追加パッケージが必要！**
- **FAT32 とは直接の互換性はない！**

✅ **「exFAT は 4GiB 超のファイルを扱えて、フラッシュストレージ向け！」**

## MBR形式・GPT形式のパーティションテーブルをサポートするパーティション操作コマンド

### **問題**

**MBR形式・GPT形式のパーティションテーブル** をサポートするパーティション操作コマンドはどれか。

### **選択肢**

1. `mgedit`
2. `parted`
3. `mgdisk`
4. `mgpart`
5. `partedit`

---

### **正解**

✅ **`parted`**

---

### **解説**

#### **1. `parted`**

- **MBR（Master Boot Record）** と **GPT（GUID Partition Table）** の両方をサポートするパーティション操作コマンド。
- **ディスクのパーティションを作成・削除・変更** できる。
- **大容量ディスク（2TB 以上）に対応する GPT をサポート** している。
- **対話モード・コマンドモードの両方で使用可能**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`mgedit`**

- **実在しないコマンド**。
- `parted` のようなパーティション操作ツールではない。

⸻

❌ **`mgdisk`**

- `gdisk`（GPT専用のパーティション操作ツール）に似た名前だが、**存在しないコマンド**。

⸻

❌ **`mgpart`**

- **実在しないコマンド**。
- `parted` や `fdisk` とは関係ない。

⸻

❌ **`partedit`**

- **実在しないコマンド**。
- `parted` のようなパーティション管理ツールではない。

⸻

### **まとめ**

| コマンド     | 説明                                               | 正解か |
| ------------ | -------------------------------------------------- | ------ |
| **`parted`** | **MBR/GPT をサポートするパーティション操作ツール** | ✅     |
| `mgedit`     | 存在しないコマンド                                 | ❌     |
| `mgdisk`     | 存在しないコマンド                                 | ❌     |
| `mgpart`     | 存在しないコマンド                                 | ❌     |
| `partedit`   | 存在しないコマンド                                 | ❌     |

⸻

💡 **ポイント**

- **`parted` は MBR / GPT の両方をサポート！**
- **`fdisk` は MBR のみ、`gdisk` は GPT のみ対応**
- **2TB 以上のディスクを扱うなら GPT（parted を使用するのが一般的）**

✅ **「MBR・GPT のパーティションを操作するなら `parted`！」**

## GRUB（GRUB Legacy または GRUB2）のインストール方法

### **問題**

デバイスファイルを指定して、ブートローダの **GRUB（GRUB Legacy または GRUB2）** をインストールしたい。
**3番目のディスク** にインストールする場合のコマンドと、**2番目のディスクの1番目のパーティション** にインストールする場合のコマンドを選びなさい。（**2つ選択**）

### **選択肢**

1. `grub-install /dev/hdc0`
2. `grub-install /dev/sdb`
3. `grub-install /dev/hdc`
4. `grub-install /dev/sdb1`
5. `grub-install /dev/hd3`
6. `grub-install /dev/sdb0`

---

### **正解**

✅ **`grub-install /dev/hdc`**
✅ **`grub-install /dev/sdb1`**

---

### **解説**

#### **1. `grub-install /dev/hdc`（3番目のディスクにインストール）**

- **IDE（PATA）ディスクの場合、`/dev/hdc` は 3 番目のディスク** に相当する。
- GRUB は通常、ディスク全体（MBR または GPT の先頭セクタ）にインストールされるため、**`/dev/hdc` にインストールするのが正しい**。

✅ **正解！**

⸻

#### **2. `grub-install /dev/sdb1`（2番目のディスクの1番目のパーティションにインストール）**

- **`/dev/sdb` は 2 番目のディスク（SATA/SCSI ディスク）を指す**。
- **`/dev/sdb1` は 2 番目のディスクの 1 番目のパーティション** なので、**GRUB を特定のパーティションにインストールしたい場合に適切**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`grub-install /dev/hdc0`**

- **`/dev/hdc0` というデバイス名は存在しない**（IDE の場合 `hdc1` などがパーティション名）。
- **正しくは `/dev/hdc` または `/dev/hdc1`**。

⸻

❌ **`grub-install /dev/sdb`**

- **`/dev/sdb` は 2 番目のディスク全体** を指すため、**MBR や GPT のブートローダをインストールするのには適している**。
- ただし、問題文では「**2番目のディスクの1番目のパーティション**」を求めているため、**不適切**。

⸻

❌ **`grub-install /dev/hd3`**

- **`/dev/hd3` というデバイス名は存在しない**（IDE の場合 `hda`, `hdb`, `hdc`, `hdd` まで）。
- **3番目のディスクは `/dev/hdc`** なので、これは間違い。

⸻

❌ **`grub-install /dev/sdb0`**

- **`/dev/sdb0` というデバイス名は存在しない**。
- **通常、パーティションは `/dev/sdb1`, `/dev/sdb2` のように番号が付く**。

⸻

### **まとめ**

| コマンド                     | 目的                                                     | 正解か |
| ---------------------------- | -------------------------------------------------------- | ------ |
| **`grub-install /dev/hdc`**  | **3番目のディスク（IDE `hdc`）にインストール**           | ✅     |
| **`grub-install /dev/sdb1`** | **2番目のディスクの1番目のパーティションにインストール** | ✅     |
| `grub-install /dev/hdc0`     | 無効なデバイス名（`/dev/hdc1` ならあり得る）             | ❌     |
| `grub-install /dev/sdb`      | 2番目のディスク全体（パーティション指定ではない）        | ❌     |
| `grub-install /dev/hd3`      | 存在しないデバイス名（`/dev/hdc` が正しい）              | ❌     |
| `grub-install /dev/sdb0`     | 存在しないデバイス名（`/dev/sdb1` なら正しい）           | ❌     |

⸻

💡 **ポイント**

- **ディスク全体に GRUB をインストールするなら `/dev/sdX` や `/dev/hdX`**
- **パーティションに GRUB をインストールするなら `/dev/sdX1` のように指定**
- **IDE の 3 番目のディスクは `/dev/hdc`、SATA の 2 番目のディスクは `/dev/sdb`**
- **デバイス名に `0` をつけるのは誤り！（`/dev/sdb0` は存在しない）**

✅ **「GRUB のインストール先を正しく指定しよう！」**

## 論理パーティションを表すデバイスファイル

### **問題**

論理パーティションを表すデバイスファイルは次のうちどれか。（**全て選択**）

### **選択肢**

1. `/dev/sda4`
2. `/dev/sda6`
3. `/dev/sda5`
4. `/dev/sda1`
5. `/dev/sda3`

---

### **正解**

✅ **`/dev/sda5`**
✅ **`/dev/sda6`**

---

### **解説**

Linux では、ディスクのパーティションには **基本パーティション**（プライマリパーティション）と **論理パーティション** があります。

#### **1. パーティションの種類**

- **基本パーティション（プライマリパーティション）**

  - `/dev/sda1` ～ `/dev/sda4` の範囲で作成可能（最大4つ）。
  - 拡張パーティションもこの範囲に含まれる。

- **拡張パーティション**

  - **基本パーティションの1つを拡張パーティションとして設定** し、その中に論理パーティションを作成。
  - `/dev/sda4` が拡張パーティションになることが多い。

- **論理パーティション**
  - **拡張パーティション内に作成されるパーティション**。
  - **デバイスファイルは `/dev/sda5` 以降（`/dev/sda5`, `/dev/sda6`, `/dev/sda7`...）となる**。

⸻

### **各デバイスファイルの確認**

| デバイスファイル | 種類                                                       | 正解か |
| ---------------- | ---------------------------------------------------------- | ------ |
| `/dev/sda1`      | 基本パーティション                                         | ❌     |
| `/dev/sda3`      | 基本パーティション                                         | ❌     |
| `/dev/sda4`      | **通常は拡張パーティション**（論理パーティションではない） | ❌     |
| `/dev/sda5`      | **論理パーティションの最初の番号**                         | ✅     |
| `/dev/sda6`      | **2番目以降の論理パーティション**                          | ✅     |

⸻

### **まとめ**

- **基本パーティション**：`/dev/sda1` ～ `/dev/sda4`
- **論理パーティション**：**`/dev/sda5` 以降**
- **拡張パーティション**（論理パーティションを格納するための枠）：通常 `/dev/sda4`
- **論理パーティションは `/dev/sda5` 以降の番号が割り当てられる！**

⸻

💡 **ポイント**

- **`/dev/sda5` 以降が論理パーティション**
- **`/dev/sda4` は拡張パーティションであることが多い**
- **基本パーティションは `/dev/sda1` ～ `/dev/sda4`**

✅ **「論理パーティションは `/dev/sda5` 以降！」**

## ジャーナリングファイルシステムではないもの

### **問題**

次のうち、**ジャーナリングファイルシステムではないもの** を選びなさい。

### **選択肢**

1. `JFS`
2. `ext4`
3. `ext2`
4. `ext3`
5. `XFS`

---

### **正解**

✅ **`ext2`**

---

### **解説**

#### **ジャーナリングファイルシステムとは？**

ジャーナリングファイルシステムは、**クラッシュや電源断によるデータ破損を防ぐために、変更履歴（ジャーナル）を記録する機能を持つファイルシステム** です。
ファイルの変更が発生すると、**まずジャーナル領域に変更内容を記録してから、実際のデータを書き込む** ため、データの整合性が向上します。

#### **1. `ext2`（ジャーナリングなし）**

- **`ext2` はジャーナリング機能を持たないファイルシステム。**
- シンプルでオーバーヘッドが少ないため、組み込み機器や USB メモリなどに使用されることがある。
- **クラッシュ時の復旧には `fsck`（ファイルシステムチェック）が必要で、時間がかかる。**

✅ **正解！**

⸻

#### **ジャーナリングファイルシステム（誤りの選択肢）**

❌ **`JFS`**（Journaled File System）

- **IBM が開発したジャーナリングファイルシステム。**
- 大規模なストレージ環境向けに設計され、高速なファイル処理が可能。

⸻

❌ **`ext4`**

- **`ext3` の拡張版で、ジャーナリング機能を持つ。**
- 大容量ディスク対応や `extents`（連続ブロック管理）などの改良が加えられている。

⸻

❌ **`ext3`**

- **`ext2` にジャーナリング機能を追加したファイルシステム。**
- クラッシュ時のデータ復旧が速く、Linux で長く使われた。

⸻

❌ **`XFS`**

- **高性能なジャーナリングファイルシステム。**
- **大容量ストレージ向けに最適化されており、並列処理性能が高い。**

⸻

### **まとめ**

| ファイルシステム | ジャーナリング | 特徴                             | 正解か |
| ---------------- | -------------- | -------------------------------- | ------ |
| **`ext2`**       | **なし**       | シンプルでオーバーヘッドが少ない | ✅     |
| `JFS`            | あり           | IBM 開発、大規模ストレージ向け   | ❌     |
| `ext4`           | あり           | `ext3` の改良版、大容量対応      | ❌     |
| `ext3`           | あり           | `ext2` + ジャーナリング機能      | ❌     |
| `XFS`            | あり           | 高速処理、大容量向け             | ❌     |

⸻

💡 **ポイント**

- **`ext2` はジャーナリング機能を持たない唯一の選択肢！**
- **ジャーナリングがないため `fsck`（チェック＆修復）が必要になる。**
- **`ext3` 以降はすべてジャーナリングをサポート！**

✅ **「ジャーナリングなし＝`ext2`！」**

## 次世代のLinux標準ファイルシステム

### **問題**

次世代の **Linux標準ファイルシステム** として開発され、
**ディレクトリの一部をサブボリュームとして個別のファイルシステムのように扱える** ファイルシステムはどれか。

### **選択肢**

1. `ext5`
2. `ZFS`
3. `Btrfs`
4. `XFS`

---

### **正解**

✅ **`Btrfs`**

---

### **解説**

#### **1. `Btrfs`（バターFS）**

- **「B-tree filesystem」** の略で、Linuxの次世代標準ファイルシステムとして開発された。
- **スナップショット、サブボリューム、データ圧縮、自己修復機能などをサポート**。
- **サブボリューム（subvolume）を作成し、個別のファイルシステムのように扱うことが可能**。
- **Red Hat は RHEL 8 以降でサポートを終了したが、openSUSE や Fedora では標準採用されている**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`ext5`**

- **存在しないファイルシステム**。
- `ext4` の次のバージョンとして `ext5` が開発される予定はない。
- **`ext4` は安定しているが、次世代ファイルシステムとしては Btrfs の方が高機能**。

⸻

❌ **`ZFS`**

- **Oracle（旧Sun Microsystems）が開発したファイルシステム**。
- **スナップショットやプール管理などの高機能を持つが、GPL ライセンスとの互換性の問題がある**。
- **Linux カーネルには直接統合されていない**（Ubuntu では公式に ZFS をサポート）。

⸻

❌ **`XFS`**

- **高性能なジャーナリングファイルシステム**。
- **大容量のデータ処理に適しているが、Btrfs のようなスナップショットやサブボリュームの概念はない**。

⸻

### **まとめ**

| ファイルシステム | 特徴                                                       | サブボリューム対応 | 次世代Linux標準 | 正解か |
| ---------------- | ---------------------------------------------------------- | ------------------ | --------------- | ------ |
| **`Btrfs`**      | **スナップショット、サブボリューム、自己修復対応**         | ✅                 | ✅              | ✅     |
| `ext5`           | **存在しない**                                             | ❌                 | ❌              | ❌     |
| `ZFS`            | **スナップショット、プール管理対応（Linux 公式統合なし）** | ✅                 | ❌              | ❌     |
| `XFS`            | **大規模データ向け高性能FS（サブボリュームなし）**         | ❌                 | ❌              | ❌     |

⸻

💡 **ポイント**

- **Btrfs は Linux の次世代標準ファイルシステムとして開発されている！**
- **サブボリューム機能により、一部のディレクトリを独立したファイルシステムのように扱える！**
- **ZFS も高機能だが、ライセンスの問題で Linux に標準統合されていない！**

✅ **「次世代 Linux 標準ファイルシステムは Btrfs！」**

## GPT に存在しない制約

### **問題**

GPT（GUID Partition Table）に **存在しない制約** を **3つ選択** しなさい。

### **選択肢**

1. **起動用システムファームウェア：UEFI**
2. **最大ハードディスク容量：2.2TB（2TiB）**
3. **起動用システムファームウェア：BIOS**
4. **基本パーティション数：128**
5. **最大ハードディスク容量：9.4ZB（8ZiB）**
6. **基本パーティション数：4**

---

### **正解**

✅ **基本パーティション数：4**
✅ **最大ハードディスク容量：2.2TB（2TiB）**
✅ **起動用システムファームウェア：BIOS**

---

### **解説**

#### **GPTとは？**

GPT（GUID Partition Table）は、従来の **MBR（Master Boot Record）** に代わる **次世代のパーティションテーブルフォーマット** です。
MBR の制約を克服し、**大容量ディスクや多数のパーティションをサポート** します。

⸻

### **存在しない制約（正解）**

#### **1. 基本パーティション数：4**

- **MBR では基本パーティションは最大4つまで** だが、GPT では **128個以上のパーティションを作成可能**（UEFI仕様では128個が一般的）。
- **GPT には「基本パーティション」という概念がなく、すべてのパーティションが等しく扱われる**。

✅ **正解！**

⸻

#### **2. 最大ハードディスク容量：2.2TB（2TiB）**

- **MBR では 2.2TB（2TiB）が上限** だったが、GPT では **最大 9.4ZB（8ZiB）まで対応可能**。
- **GPT の 64bit LBA により、非常に大きなディスク容量を扱える**。

✅ **正解！**

⸻

#### **3. 起動用システムファームウェア：BIOS**

- **GPT は UEFI に対応** しているが、**従来の BIOS とは互換性がない**。
- BIOS で GPT ディスクからのブートは **基本的に不可**（特殊な方法を除く）。
- **BIOS でブートする場合は MBR を使用するのが一般的**。

✅ **正解！**

⸻

### **GPT に存在する仕様（誤りの選択肢）**

❌ **起動用システムファームウェア：UEFI**

- **GPT は UEFI に対応** しており、GPT ディスクからの起動には UEFI が必要。
- **正しい仕様なので不正解！**

⸻

❌ **基本パーティション数：128**

- **GPT では UEFI 仕様で最大128個のパーティションを作成可能**。
- **実際の最大数はディスクのサイズと OS に依存**。

⸻

❌ **最大ハードディスク容量：9.4ZB（8ZiB）**

- **GPT の仕様では 64bit LBA により最大 9.4ZB（8ZiB）まで対応**。
- **正しい仕様なので不正解！**

⸻

### **まとめ**

| 制約                                            | MBR                                         | GPT                 | 存在しない制約か |
| ----------------------------------------------- | ------------------------------------------- | ------------------- | ---------------- |
| **基本パーティション数**                        | **最大4つ**（拡張パーティションで増やせる） | **128個以上**       | ✅               |
| **最大ハードディスク容量**                      | **2.2TB（2TiB）**                           | **9.4ZB（8ZiB）**   | ✅               |
| **起動用システムファームウェア**                | **BIOS**                                    | **UEFI**            | ✅               |
| **GPT の基本パーティション数：128**             | ❌（MBR では4つ）                           | ✅（一般的に128個） | ❌               |
| **GPT の最大ハードディスク容量：9.4ZB（8ZiB）** | ❌（MBR は 2.2TB）                          | ✅                  | ❌               |
| **GPT の起動ファームウェア：UEFI**              | ❌（MBR は BIOS）                           | ✅                  | ❌               |

⸻

💡 **ポイント**

- **GPT では 128個以上のパーティションを作成可能（MBR は最大4つ）**
- **GPT のディスクサイズ上限は 9.4ZB（MBR は 2.2TB 制限あり）**
- **GPT は UEFI 対応、BIOS ではブート不可**
- **「MBR の制約 = GPT では解決されている」と考えると分かりやすい！**

✅ **「GPT にない制約は『パーティション数4』『2.2TB上限』『BIOSブート』！」**

## `fdisk` コマンドのサブコマンドとその説明

### **問題**

`fdisk` コマンドの **サブコマンドとその説明の組み合わせとして正しいもの** を **2つ選択** しなさい。

### **選択肢**

1. `m`：パーティションタイプ（システムID）の変更
2. `t`：パーティションタイプ（システムID）の変更
3. `q`：パーティションテーブルの変更を保存して終了
4. `p`：パーティションテーブルの表示
5. `d`：パーティションの作成

---

### **正解**

✅ **`p`：パーティションテーブルの表示**
✅ **`t`：パーティションタイプ（システムID）の変更**

---

### **解説**

#### **1. `p`：パーティションテーブルの表示**

- **現在のパーティション情報を表示するコマンド**。
- **ディスク上のパーティションのリスト、サイズ、ファイルシステムタイプなどを確認可能**。
- 実行例：
  ```bash
  Command (m for help): p
  ```
  - 出力例：

```
Disk /dev/sda: 500GB
Sector size: 512 bytes
Device Boot  Start     End      Blocks   Id  System
/dev/sda1    *        1        1024    102400  83  Linux
```

✅ 正解！

⸻

2. t：パーティションタイプ（システムID）の変更
   - パーティションのファイルシステムタイプ（システムID）を変更するコマンド。
   - 例えば、ext4（ID: 83）から Linux Swap（ID: 82）に変更する際に使用。
   - 実行例：

```
Command (m for help): t
Partition number (1-4): 1
Hex code (type L to list codes): 82
```

- l を押すと、利用可能なパーティションタイプの一覧が表示される。

✅ 正解！

⸻

誤った選択肢の解説

❌ m：パーティションタイプ（システムID）の変更 - m は fdisk のヘルプメニューを表示するコマンド であり、パーティションタイプの変更は t を使用 する。

⸻

❌ q：パーティションテーブルの変更を保存して終了 - q は 変更を保存せずに終了するコマンド。- 変更を保存して終了するには w を使用する。

⸻

❌ d：パーティションの作成 - d は パーティションの削除を行うコマンド であり、作成には n を使用する。

⸻

### まとめ

```
サブコマンド	説明	正解か
p	パーティションテーブルの表示	✅
t	パーティションタイプ（システムID）の変更	✅
m	fdisk のサブコマンド一覧を表示（ヘルプ）	❌
q	変更を保存せずに終了（保存して終了ではない）	❌
d	パーティションを削除（作成ではない）	❌
```

⸻

💡 ポイント - p：現在のパーティション情報を確認 - t：パーティションタイプ（システムID）の変更 - m はヘルプ、q は保存せず終了、d は削除 - パーティションを作成する場合は n を使用

✅ 「p でパーティション情報確認、t でタイプ変更！」

## `parted` を使用してパーティションテーブルの方式を GPT に設定する方法

### **問題**

新しいハードディスクの **パーティションテーブルの方式を GPT に設定** したい。
正しいコマンドを **2つ選択** しなさい。

### **選択肢**

1.  parted /dev/sdb -s mklabel gpt
2.  parted /dev/sdb -t gpt
3.  parted /dev/sdb
    (parted) parttbl gpt
    (parted) q
4.  parted /dev/sdb -s parttbl gpt

5.  parted /dev/sdb
    (parted) gpt
    (parted) q
6.  parted /dev/sdb
    (parted) mklabel gpt
    (parted) q

⸻

### 正解

✅ parted /dev/sdb -s mklabel gpt
✅ parted /dev/sdb → (parted) mklabel gpt → (parted) q

⸻

解説

1.  parted /dev/sdb -s mklabel gpt

- -s オプションは スクリプトモード で実行するためのもので、対話モードなしで mklabel gpt を実行できる。
- 短縮形のコマンドで GPT に設定するのに適切。

✅ 正解！

⸻

2.  parted /dev/sdb → (parted) mklabel gpt → (parted) q

- parted を 対話モード で実行し、手動で mklabel gpt を入力して GPT に設定する方法。
- q を入力することで parted を終了 する。

✅ 正解！

⸻

誤った選択肢の解説

❌ parted /dev/sdb -t gpt - -t オプションは parted には存在しない。- パーティションテーブルの作成には mklabel を使用する必要がある。

⸻

❌ parted /dev/sdb -s parttbl gpt - parttbl というコマンドは 存在しない。- mklabel gpt を使用するのが正しい方法。

⸻

❌ parted /dev/sdb → (parted) parttbl gpt → (parted) q - parttbl というサブコマンドは 存在しない。- mklabel gpt が正しいコマンド。

⸻

❌ # parted /dev/sdb → (parted) gpt → (parted) q - gpt というコマンドは parted には存在しない。- 正しくは mklabel gpt を使う。

⸻

### まとめ

```
コマンド	説明	正解か
 parted /dev/sdb -s mklabel gpt	スクリプトモードで GPT を設定	✅
 parted /dev/sdb → (parted) mklabel gpt → (parted) q	対話モードで GPT を設定	✅
 parted /dev/sdb -t gpt	-t オプションは無効	❌
 parted /dev/sdb -s parttbl gpt	parttbl というコマンドは存在しない	❌
 parted /dev/sdb → (parted) parttbl gpt → (parted) q	parttbl コマンドは存在しない	❌
 parted /dev/sdb → (parted) gpt → (parted) q	gpt というコマンドは存在しない	❌
```

⸻

💡 ポイント - mklabel gpt を使うと GPT のパーティションテーブルを作成できる！- parted -s mklabel gpt なら対話なしで一発設定！- 対話モードで実行するなら parted を開いて mklabel gpt を入力！

✅ 「GPT の設定には mklabel gpt を使おう！」

## GRUB（GRUB Legacy / GRUB2）のインストールコマンドの説明

### **問題**

デバイスファイルを指定して **GRUB（GRUB LegacyまたはGRUB2）** をインストールするコマンドについて、**正しい説明** を **2つ選択** しなさい。

### **選択肢**

1. **`grub-install /dev/sdd`** は、4番目のディスクにインストールする
2. **`grub-install /dev/hdd0`** は、1番目のパーティションにインストールする
3. **`grub-install /dev/sdd`** は、1番目のパーティションにインストールする
4. **`grub-install /dev/hdd2`** は、2番目のパーティションにインストールする

---

### **正解**

✅ **`grub-install /dev/sdd` は、4番目のディスクにインストールする**
✅ **`grub-install /dev/hdd2` は、2番目のパーティションにインストールする**

---

### **解説**

#### **1. `grub-install /dev/sdd` は、4番目のディスクにインストールする**

- **SATA（SCSI）デバイスの場合**、Linux では `/dev/sda` が **1番目のディスク**、`/dev/sdb` が **2番目のディスク**...と続く。
- **`/dev/sdd` は 4 番目のディスクを指す**。
- **パーティション指定がない場合はディスク全体の MBR / GPT に GRUB をインストールする**。

✅ **正解！**

⸻

#### **2. `grub-install /dev/hdd2` は、2番目のパーティションにインストールする**

- **IDE（PATA）デバイスの場合**、Linux では `/dev/hda` が **1番目のディスク**、`/dev/hdb` が **2番目のディスク**...と続く。
- **`/dev/hdd` は 4 番目のディスク** なので、`/dev/hdd2` は **4番目のディスクの2番目のパーティション** を指す。
- **GRUB を MBR ではなく特定のパーティションにインストールする場合は、`grub-install /dev/hdd2` のようにパーティションを指定する**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`grub-install /dev/hdd0` は、1番目のパーティションにインストールする**

- **誤り！**
- **Linux では `hdd0` というデバイスファイルは存在しない**。
- **1番目のパーティションは `/dev/hdd1` になるため、`/dev/hdd0` は無効**。

⸻

❌ **`grub-install /dev/sdd` は、1番目のパーティションにインストールする**

- **誤り！**
- **パーティション指定がない場合、GRUB はディスク全体（MBR または GPT）にインストールされる**。
- **1番目のパーティションなら `/dev/sdd1` を指定する必要がある**。

⸻

### **まとめ**

| コマンド                                         | 説明                                                     | 正解か |
| ------------------------------------------------ | -------------------------------------------------------- | ------ |
| **`grub-install /dev/sdd`**                      | **4番目のディスク全体にインストール**                    | ✅     |
| **`grub-install /dev/hdd2`**                     | **4番目のディスクの2番目のパーティションにインストール** | ✅     |
| `grub-install /dev/hdd0`                         | **無効なデバイス名（`/dev/hdd1` が正しい）**             | ❌     |
| `grub-install /dev/sdd`（1番目のパーティション） | **ディスク全体にインストールされるため誤り**             | ❌     |

⸻

💡 **ポイント**

- **`/dev/sda`, `/dev/sdb`, `/dev/sdc`, `/dev/sdd`... はそれぞれ1番目、2番目、3番目、4番目のディスク**
- **GRUB をディスク全体（MBR / GPT）にインストールする場合は `/dev/sdX`**
- **特定のパーティションにインストールする場合は `/dev/sdX1` のように指定**
- **`/dev/hdd2` は IDE の4番目のディスクの2番目のパーティション**

✅ **「GRUB のインストール先を正しく指定しよう！」**

## inode の数が制限されるファイルシステム

### **問題**

inode の数が制限されるファイルシステムは次のうちどれか。（**全て選択**）

### **選択肢**

1. `ext2`
2. `ext4`
3. `XFS`
4. `ext3`
5. `JFS`

---

### **正解**

✅ **`ext2`**
✅ **`ext3`**
✅ **`ext4`**

---

### **解説**

#### **inode とは？**

- **inode（インノード）** は、ファイルのメタデータ（所有者、パーミッション、サイズ、格納場所 など）を管理するデータ構造。
- **Linux の `ext` 系ファイルシステムでは、ファイルシステム作成時に inode の総数が決まるため、後から増やすことはできない**。

⸻

#### **1. `ext2`, `ext3`, `ext4`（inode 数の制限あり）**

- **`ext2`、`ext3`、`ext4` は、ファイルシステム作成時に inode 数が決まる**。
- そのため、**inode を使い切ると、ディスクの空き容量があっても新しいファイルを作成できない**。
- `ext4` では **inode サイズの柔軟な設定** や **拡張機能** が追加されたが、基本的な制限は変わらない。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`XFS`（inode 数の制限なし）**

- **`XFS` は動的 inode を採用** しているため、必要に応じて inode を増やせる。
- **ファイルシステム作成時に inode 数を事前に決める必要がない**。

⸻

❌ **`JFS`（inode 数の制限なし）**

- **`JFS` も動的 inode を採用** しており、`ext` 系のような inode 数の制限はない。

⸻

### **まとめ**

| ファイルシステム | inode 数の制限 | 説明                                   | 正解か |
| ---------------- | -------------- | -------------------------------------- | ------ |
| **`ext2`**       | **あり**       | 作成時に inode 数が固定                | ✅     |
| **`ext3`**       | **あり**       | `ext2` にジャーナリングを追加          | ✅     |
| **`ext4`**       | **あり**       | `ext3` の改良版だが inode 数の制限あり | ✅     |
| `XFS`            | なし           | 動的 inode を採用                      | ❌     |
| `JFS`            | なし           | 動的 inode を採用                      | ❌     |

⸻

💡 **ポイント**

- **`ext2`、`ext3`、`ext4` は inode の数が固定で、後から増やせない！**
- **`XFS` や `JFS` は動的 inode なので、inode 数の制限なし！**
- **inode 数が足りなくなると、ディスクの空き容量があってもファイルが作成できなくなる！**

✅ **「inode の数が制限されるのは `ext2` `ext3` `ext4`！」**

## MBR 方式のハードディスクに作成できる基本パーティションの最大数

### **問題**

MBR（Master Boot Record）方式のハードディスクに **基本パーティションは最大何個作成できるか**。

### **選択肢**

1. **4**
2. **7**
3. **6**
4. **5**
5. **無限**

---

### **正解**

✅ **4**

---

### **解説**

#### **MBR（Master Boot Record）とは**

MBR（Master Boot Record）は、**従来のパーティション管理方式** であり、
ディスクの先頭に **パーティション情報** を格納する **パーティションテーブル** を持っています。

⸻

#### **1. MBR で作成可能な基本パーティションの最大数**

- **MBR のパーティションテーブルには最大 4 つのエントリしか存在しない**。
- そのため、**基本パーティション（プライマリパーティション）は最大 4 つまでしか作成できない**。

✅ **正解！**

⸻

#### **2. 拡張パーティションと論理パーティション**

- **MBR では 4 つ以上のパーティションを作成したい場合、拡張パーティションを利用する**。
- **基本パーティション 4 つのうち 1 つを拡張パーティションにすると、その中に無制限に論理パーティションを作成できる**。
- **論理パーティションは `/dev/sda5` 以降の番号で作成される**（`/dev/sda1` ～ `/dev/sda4` は基本パーティション）。

⸻

### **誤った選択肢の解説**

❌ **7 / 6 / 5**

- **MBR では基本パーティションは最大 4 つまでしか作成できない**。
- 5 個以上作成したい場合は、**1 つを拡張パーティションにし、その中に論理パーティションを作成する必要がある**。

⸻

❌ **無限**

- **MBR では基本パーティションは 4 つまでという制限があるため無限には作成できない**。
- GPT（GUID Partition Table）を使用すれば、**128個以上のパーティションを作成できる**。

⸻

### **まとめ**

| パーティションの種類           | MBR                                          | GPT                             |
| ------------------------------ | -------------------------------------------- | ------------------------------- |
| **基本パーティションの最大数** | **4 つ**                                     | **制限なし（一般的に 128 個）** |
| **拡張パーティションの数**     | **1 つ**（基本パーティションとしてカウント） | **不要**                        |
| **論理パーティションの数**     | **無制限（拡張パーティション内）**           | **不要**                        |

⸻

💡 **ポイント**

- **MBR では基本パーティションは最大 4 つ！**
- **5 個以上のパーティションを作成するには、拡張パーティションを作り、その中に論理パーティションを作成する**
- **制限なしで多くのパーティションを作りたいなら GPT を使う**

✅ **「MBR では基本パーティションは 4 つまで！」**

## `fdisk` コマンドで作成したパーティションにファイルシステムを作成するコマンド

### **問題**

`fdisk` コマンドで作成したパーティションに **ファイルシステムを作成** できるコマンドを **2つ選択** しなさい。

### **選択肢**

1. `mkfdisk`
2. `mkfs`
3. `mke2fs`
4. `mk2fs`
5. `make2fs`

---

### **正解**

✅ **`mkfs`**
✅ **`mke2fs`**

---

### **解説**

#### **1. `mkfs`（汎用的なファイルシステム作成コマンド）**

- **`mkfs`（Make File System）は、任意のファイルシステムを作成できる汎用コマンド**。
- `-t` オプションを使って **ファイルシステムの種類を指定可能**。
- 例（`ext4` ファイルシステムを作成）：
  ```bash
  mkfs -t ext4 /dev/sda1
  ```
  - mkfs.ext4 や mkfs.xfs など、特定のファイルシステム向けのバージョンもある。

✅ 正解！

⸻

2. mke2fs（ext 系ファイルシステム専用コマンド）
   - mke2fs は ext2、ext3、ext4 ファイルシステムを作成できる専用コマンド。
   - -t オプションを指定することで、ext2 以外も作成可能。
   - 例（ext4 ファイルシステムを作成）：

```
mke2fs -t ext4 /dev/sda1

```

- 例（ext3 ファイルシステムを作成）：

```
mke2fs -j /dev/sda1

```

✅ 正解！

⸻

誤った選択肢の解説

❌ mkfdisk - 存在しないコマンド。- パーティションを作成する fdisk とは無関係。

⸻

❌ mk2fs - 存在しないコマンド。- 正しくは mke2fs。

⸻

❌ make2fs - 存在しないコマンド。- 正しくは mke2fs。

⸻

### まとめ

```
コマンド 説明 正解か
mkfs 汎用的なファイルシステム作成コマンド ✅
mke2fs ext2/ext3/ext4 専用のファイルシステム作成コマンド ✅
mkfdisk 存在しないコマンド ❌
mk2fs 存在しないコマンド ❌
make2fs 存在しないコマンド ❌

```

⸻

💡 ポイント - mkfs は汎用的なファイルシステム作成コマンド - mke2fs は ext2 / ext3 / ext4 用のファイルシステム作成コマンド - mkfdisk や make2fs などは存在しない！

✅ 「パーティションにファイルシステムを作成するなら mkfs または mke2fs！」

## MBR 形式のハードディスクにおけるパーティションタイプの組み合わせ

### **問題**

MBR 形式のハードディスクにおける **パーティションタイプの組み合わせとして正しいもの** はどれか。

### **選択肢**

1. **`e0`：空**
2. **`82`：Linux swap**
3. **`0`：Linux LVM**
4. **`83`：FAT**
5. **`8e`：Linux**

---

### **正解**

✅ **`82`：Linux swap**

---

### **解説**

MBR（Master Boot Record）では、**各パーティションに対して「パーティションタイプ ID（16進数）」が割り当てられる**。
この ID により、OS はパーティションの種類を判別します。

⸻

#### **1. `82`：Linux swap（正解）**

- **Linux のスワップ領域を表すパーティションタイプ**。
- スワップ領域は、**物理メモリ（RAM）が不足したときに仮想メモリとして使用される**。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`e0`：空**

- **`e0` というパーティションタイプは存在しない**。
- **未使用の領域（未割り当てパーティション）には特定のパーティションタイプは設定されない**。

⸻

❌ **`0`：Linux LVM**

- **`0` は「未使用」のパーティションタイプ ID であり、LVM とは無関係**。
- **Linux LVM（Logical Volume Manager）の ID は `8e`**。

⸻

❌ **`83`：FAT**

- **`83` は「Linux ファイルシステム（ext2/ext3/ext4 など）」を表す ID**。
- **FAT のパーティションタイプ ID は `0b`（FAT32）、`0c`（FAT32（LBA））など**。

⸻

❌ **`8e`：Linux**

- **`8e` は「Linux LVM（Logical Volume Manager）」の ID** であり、**通常の Linux ファイルシステムを指すわけではない**。
- **Linux の標準的なファイルシステム（ext2/ext3/ext4 など）の ID は `83`**。

⸻

### **正しいパーティションタイプ ID 一覧（MBR）**

| パーティションタイプ ID | 説明                                    |
| ----------------------- | --------------------------------------- |
| **`82`**                | **Linux swap**                          |
| **`83`**                | **Linux（ext2/ext3/ext4 など）**        |
| **`8e`**                | **Linux LVM（Logical Volume Manager）** |
| **`0b`**                | **FAT32**                               |
| **`0c`**                | **FAT32（LBA）**                        |
| **`07`**                | **NTFS/exFAT**                          |
| **`05`**                | **拡張パーティション**                  |

⸻

### **まとめ**

| 選択肢               | 正しいパーティションタイプか | 説明                                           |
| -------------------- | ---------------------------- | ---------------------------------------------- |
| **`82`：Linux swap** | ✅                           | **スワップ領域を表す**                         |
| `e0`：空             | ❌                           | **存在しないパーティションタイプ ID**          |
| `0`：Linux LVM       | ❌                           | **`0` は未使用、LVM は `8e`**                  |
| `83`：FAT            | ❌                           | **`83` は Linux（FAT ではない）**              |
| `8e`：Linux          | ❌                           | **`8e` は Linux LVM（通常の Linux ではない）** |

⸻

💡 **ポイント**

- **`82` は Linux swap！**
- **Linux の標準的なファイルシステム（ext2/ext3/ext4 など）は `83`！**
- **Linux LVM は `8e`！**
- **FAT32 は `0b` または `0c`！**

✅ **「Linux swap のパーティションタイプは `82`！」**

## `fdisk` コマンドのサブコマンドとその説明の間違い

### **問題**

次の `fdisk` コマンドのサブコマンドとその説明の組み合わせのうち、**間違っているもの** はどれか。

### **選択肢**

1. **`n`：パーティションの作成**
2. **`t`：パーティションテーブルの表示**
3. **`q`：パーティションテーブルの変更を保存せずに終了**
4. **`d`：パーティションの削除**
5. **`w`：パーティションテーブルの変更を保存して終了**

---

### **正解**

✅ **`t`：パーティションテーブルの表示（間違い）**

---

### **解説**

#### **1. `t`：パーティションテーブルの表示（間違い）**

- **`t` はパーティションのファイルシステムタイプ（システム ID）を変更するコマンド**。
- **パーティションテーブルを表示するコマンドではない！**
- **パーティションテーブルの表示には `p` を使用する**。

❌ **誤り！**

⸻

### **正しい選択肢の解説**

✅ **`n`：パーティションの作成**

- **新しいパーティションを作成するコマンド**。
- `fdisk` 内で **`n` を入力し、パーティションの種類（基本 or 拡張）やサイズを指定** する。

✅ **正しい！**

⸻

✅ **`q`：パーティションテーブルの変更を保存せずに終了**

- **変更を破棄し、`fdisk` を終了するコマンド**。
- **パーティションの変更を保存せずに抜けたい場合に使用**。

✅ **正しい！**

⸻

✅ **`d`：パーティションの削除**

- **指定したパーティションを削除するコマンド**。
- **削除を確定するには `w`（保存）を実行する必要がある**。

✅ **正しい！**

⸻

✅ **`w`：パーティションテーブルの変更を保存して終了**

- **変更をディスクに書き込み（保存し）、`fdisk` を終了するコマンド**。
- **この操作を行うと、変更が確定し、取り消せなくなるので注意！**

✅ **正しい！**

⸻

### **まとめ**

| サブコマンド | 説明                                                                   | 正しいか |
| ------------ | ---------------------------------------------------------------------- | -------- |
| **`n`**      | **パーティションの作成**                                               | ✅       |
| **`t`**      | **パーティションのファイルシステムタイプ（ID）の変更**（表示ではない） | ❌       |
| **`q`**      | **変更を保存せずに終了**                                               | ✅       |
| **`d`**      | **パーティションの削除**                                               | ✅       |
| **`w`**      | **パーティションテーブルの変更を保存して終了**                         | ✅       |

⸻

💡 **ポイント**

- **パーティションテーブルの表示は `p`！**
- **`t` はパーティションのタイプ（システム ID）を変更するコマンド！**
- **変更を保存せずに終了するなら `q`、保存して終了するなら `w`！**

✅ **「`t` はパーティションタイプ変更！パーティションテーブルの表示は `p`！」**

## MBR 方式のハードディスク `/dev/sda` のパーティションテーブルを確認する方法

### **問題**

MBR 方式のハードディスク **`/dev/sda`** のパーティションテーブルを確認したい。
適切なコマンドを選びなさい。

### **選択肢**

1. **`fdisk --table /dev/sda`**
2. **`fdisk -p /dev/sda`**
3. **`fdisk -l /dev/sda`**
4. **`fdisk -t /dev/sda`**
5. **`fdisk --library /dev/sda`**

---

### **正解**

✅ **`fdisk -l /dev/sda`**

---

### **解説**

#### **1. `fdisk -l /dev/sda`（正解）**

- `fdisk -l` は **指定したデバイスのパーティションテーブルを一覧表示するコマンド**。
- MBR のパーティション情報を確認する際に使用される。
- 実行例：
  ```bash
  sudo fdisk -l /dev/sda
  ```
  - 出力例：

```
Disk /dev/sda: 500GB
Sector size: 512 bytes
Device      Boot Start    End      Blocks   Id  System
/dev/sda1   *     2048    4096     102400   83  Linux
```

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk --table /dev/sda - --table というオプションは存在しない。

⸻

❌ fdisk -p /dev/sda - -p というオプションは fdisk には存在しない。- パーティション情報を表示するなら -l を使用する。

⸻

❌ fdisk -t /dev/sda - -t は fdisk には存在しないオプション（mkfs -t のような形式でファイルシステムを指定するコマンドには存在）。

⸻

❌ fdisk --library /dev/sda - --library というオプションは fdisk には存在しない。

⸻

### まとめ

```
コマンド	説明	正解か
fdisk -l /dev/sda	パーティションテーブルを一覧表示	✅
fdisk --table /dev/sda	無効なオプション	❌
fdisk -p /dev/sda	無効なオプション	❌
fdisk -t /dev/sda	無効なオプション	❌
fdisk --library /dev/sda	無効なオプション	❌
```

⸻

💡 ポイント - fdisk -l /dev/sda で MBR のパーティションテーブルを表示 - -l は「list」の意味 - 無効なオプション（--table -p -t --library）に注意！

✅ 「MBR のパーティションを確認するなら fdisk -l /dev/sda！」

## GPT 形式のハードディスクでパーティションの作成・削除・変更・情報表示を行うコマンド

### **問題**

GPT 形式のハードディスクにおいて、**パーティションの作成、削除、変更、および情報表示** を行うことができるコマンドはどれか。

### **選択肢**

1. **`fdisk`**
2. **`gptedit`**
3. **`gdisk`**
4. **`partition`**
5. **`gptdisk`**

---

### **正解**

✅ **`gdisk`**

---

### **解説**

#### **1. `gdisk`（正解）**

- **GPT（GUID Partition Table）専用のパーティション操作ツール**。
- `fdisk` の **GPT 版** であり、**MBR ではなく GPT を扱うために設計されたコマンド**。
- **パーティションの作成、削除、変更、表示** などが可能。
- 実行例：

  ```bash
  sudo gdisk /dev/sda
  ```

  - 対話モードでパーティション操作を実行可能。

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk - fdisk は MBR（Master Boot Record）専用 のコマンド。- GPT には対応していない（fdisk で GPT ディスクを扱うと、警告が出ることがある）。

⸻

❌ gptedit - 実在しないコマンド。

⸻

❌ partition - Linux にこの名前のパーティション管理コマンドは存在しない。

⸻

❌ gptdisk - 実在しないコマンド。- GPT を操作するには gdisk を使用する。

⸻

### まとめ

```
コマンド 説明 正解か
gdisk GPT 形式のパーティションを作成・削除・変更・表示するコマンド ✅
fdisk MBR 専用のパーティション管理ツール（GPT には非対応） ❌
gptedit 実在しないコマンド ❌
partition 実在しないコマンド ❌
gptdisk 実在しないコマンド ❌
```

⸻

💡 ポイント - GPT のパーティション管理には gdisk を使用する！- fdisk は MBR 専用であり、GPT には適用できない！- gptedit partition gptdisk などのコマンドは存在しない！

✅ 「GPT のパーティションを管理するなら gdisk！」

## MBR 形式のハードディスク `/dev/sda` のパーティションを操作するコマンド

### **問題**

MBR 形式のハードディスク **`/dev/sda`** の **パーティションを操作** したい。
適切なコマンドを選びなさい。

### **選択肢**

1. **`fdisk -l /dev/sda`**
2. **`fdisk -n /dev/sda`**
3. **`fdisk -c /dev/sda`**
4. **`fdisk /dev/sda`**
5. **`fdisk -p /dev/sda`**

---

### **正解**

✅ **`fdisk /dev/sda`**

---

### **解説**

#### **1. `fdisk /dev/sda`（正解）**

- **MBR 形式のパーティションを作成・削除・変更するための対話モードを開始するコマンド**。
- `fdisk` を実行すると、`Command (m for help):` のプロンプトが表示され、**対話モードでパーティションを操作できる**。
- 実行例：
  ```bash
  sudo fdisk /dev/sda
  ```
  - このモードで n（パーティション作成）、d（削除）、w（変更を保存） などのサブコマンドを使用可能。

✅ 正解！

⸻

誤った選択肢の解説

❌ fdisk -l /dev/sda - -l はパーティションテーブルを一覧表示するだけで、操作はできない。- パーティション情報の確認には便利だが、作成・削除・変更はできない。

⸻

❌ fdisk -n /dev/sda - -n というオプションは fdisk には存在しない。- パーティションを作成する場合は、fdisk の対話モードで n を入力する。

⸻

❌ fdisk -c /dev/sda - -c は古いバージョンの fdisk で互換モードを変更するオプション（現在はほぼ不要）。- パーティションの作成・削除・変更はできない。

⸻

❌ fdisk -p /dev/sda - -p というオプションは fdisk には存在しない。- パーティション情報を表示するなら fdisk -l を使用する。

⸻

### まとめ

```
コマンド	説明	正解か
fdisk /dev/sda	MBR 形式のパーティションを作成・削除・変更するための対話モードを開始	✅
fdisk -l /dev/sda	パーティションテーブルを表示する（操作は不可）	❌
fdisk -n /dev/sda	無効なオプション（存在しない）	❌
fdisk -c /dev/sda	互換モードを変更するオプション（パーティション操作は不可）	❌
fdisk -p /dev/sda	無効なオプション（存在しない）	❌
```

⸻

💡 ポイント - パーティションの作成・削除・変更を行うには fdisk /dev/sda を使う！- パーティションテーブルの表示だけなら fdisk -l /dev/sda！- -n や -p のようなオプションは存在しない！

✅ 「MBR のパーティションを操作するなら fdisk /dev/sda！」

## Btrfs ファイルシステムの特徴

### **問題**

Btrfs ファイルシステムの特徴として **正しいものを 2 つ選択** しなさい。

### **選択肢**

1. **ファイルの圧縮はサポートしていない**
2. **マルチデバイスに対応している**
3. **inode の数が制限される**
4. **ext3 の後継である**
5. **サブボリューム単位でのスナップショット機能がある**

---

### **正解**

✅ **マルチデバイスに対応している**
✅ **サブボリューム単位でのスナップショット機能がある**

---

### **解説**

#### **1. マルチデバイスに対応している（正解）**

- **Btrfs は複数のデバイスを 1 つのストレージプールとして管理できる**。
- **RAID 機能（RAID 0, 1, 10, 5, 6）を内蔵し、複数のストレージデバイスを統合可能**。
- 例：
  ```bash
  mkfs.btrfs -m raid1 -d raid1 /dev/sdb /dev/sdc
  ```
  - マルチデバイス管理機能が組み込まれているため、LVM を使わなくてもストレージ管理が柔軟にできる。

✅ 正解！

⸻

2. サブボリューム単位でのスナップショット機能がある（正解）
   - Btrfs は「サブボリューム」機能を持ち、これを単位としてスナップショットを作成できる。
   - サブボリュームごとにデータのスナップショットを取ることができるため、バックアップやシステムの復元に便利。
   - 例：

btrfs subvolume snapshot /mnt/data /mnt/snapshots/data-20240317

    -	スナップショットは差分で保存されるため、ディスク使用量が最小限に抑えられる。

✅ 正解！

⸻

誤った選択肢の解説

❌ ファイルの圧縮はサポートしていない - Btrfs はファイルの圧縮（zlib、lzo、zstd）をサポートしている。- 圧縮を有効にする例：

mount -o compress=zstd /dev/sda1 /mnt

    -	「ファイルの圧縮はサポートしていない」は誤り！

⸻

❌ inode の数が制限される - Btrfs は動的に inode を割り当てるため、inode の数に制限はない。- ext2/ext3/ext4 のようにファイルシステム作成時に inode 数を固定する方式ではない。

⸻

❌ ext3 の後継である - Btrfs は ext3 の後継ではなく、新しい設計の CoW（Copy-on-Write）ファイルシステム。- ext3 の後継は ext4 であり、Btrfs とは別系統のファイルシステム。

⸻

### まとめ

```

特徴 Btrfs の対応 正解か
マルチデバイスに対応している ✅（RAID 0, 1, 10, 5, 6 をサポート） ✅
サブボリューム単位でのスナップショット機能がある ✅（サブボリュームごとにスナップショットが可能） ✅
ファイルの圧縮はサポートしていない ❌（zlib、lzo、zstd 圧縮をサポート） ❌
inode の数が制限される ❌（動的に inode を割り当てる） ❌
ext3 の後継である ❌（ext3 の後継は ext4、Btrfs は別系統） ❌

```

⸻

💡 ポイント - Btrfs はマルチデバイス対応！ RAID 機能を内蔵！- サブボリュームとスナップショット機能がある！- 動的 inode 割り当てなので inode 数の制限なし！- ext3 の後継ではなく、新しい CoW（Copy-on-Write）ファイルシステム！

✅ 「Btrfs はマルチデバイス & スナップショット対応！」

## Linuxのルートファイルシステムに使用できるファイルシステム

### **問題**

Linuxの **ルートファイルシステム（/）** に使用できるファイルシステムは次のうちどれか。
（**3つ選択**）

### **選択肢**

1. `ext4`
2. `iso9660`
3. `XFS`
4. `NTFS`
5. `ext3`

---

### **正解**

✅ **`ext3`**
✅ **`ext4`**
✅ **`XFS`**

---

### **解説**

#### **ルートファイルシステムとは？**

- Linux システムの中核を担う **`/`（ルート）ディレクトリを保持するファイルシステム**。
- 起動に必要なすべてのファイル、ライブラリ、設定ファイルが含まれるため、**信頼性とLinuxカーネルの互換性が必要**。

⸻

### **正解のファイルシステム**

#### **1. `ext3`**

- **古くから使用されているジャーナリングファイルシステム**。
- 信頼性が高く、現在でも多くのディストリビューションが対応。
- **ルートファイルシステムとして使用可能**。

✅ **正解！**

⸻

#### **2. `ext4`**

- **ext3 の後継で、現在の Linux で最も一般的なファイルシステム**。
- **大容量対応、高速化、信頼性向上などの機能が追加されている**。
- **多くの Linux ディストリビューションでルートファイルシステムとして標準使用されている**。

✅ **正解！**

⸻

#### **3. `XFS`**

- **高性能でスケーラブルなジャーナリングファイルシステム**。
- **Red Hat 系のディストリビューション（例：RHEL、CentOS、Rocky）でルートファイルシステムとして採用されていることが多い**。
- 大量ファイルや大規模データに強い。

✅ **正解！**

⸻

### **誤った選択肢の解説**

❌ **`iso9660`**

- **CD-ROM や DVD-ROM などの読み取り専用メディア向けのファイルシステム**。
- 読み取り専用のため、**ルートファイルシステムとして使用不可**。

⸻

❌ **`NTFS`**

- **Windows のファイルシステム**。
- Linux でも読み書き可能だが、**完全な互換性や安定性が保証されない**。
- **カーネルレベルでの公式サポートが限定的で、ルートファイルシステムとしては推奨されない**。

⸻

### **まとめ**

| ファイルシステム | ルートに使用可否 | 理由                               | 正解か |
| ---------------- | ---------------- | ---------------------------------- | ------ |
| **`ext3`**       | ✅ 使用可能      | 古くから安定して使用されている     | ✅     |
| **`ext4`**       | ✅ 使用可能      | 現在の主流、信頼性と高速性         | ✅     |
| **`XFS`**        | ✅ 使用可能      | 大容量、高性能な FS、RHEL 系で採用 | ✅     |
| `iso9660`        | ❌ 使用不可      | 読み取り専用（CD/DVD 向け）        | ❌     |
| `NTFS`           | ❌ 使用非推奨    | Windows 用、完全な互換性なし       | ❌     |

⸻

💡 **ポイント**

- **ルートファイルシステムは「読み書き可能」で「信頼性のある Linux ネイティブ FS」が条件！**
- **主に使われるのは `ext4`、次いで `ext3` や `XFS`！**

✅ **「Linux のルートファイルシステムには `ext4`、`ext3`、`XFS` が使える！」**

## ディレクトリと配下の容量を単位付きで表示するコマンド

### **問題**

`dir` ディレクトリと、その配下にある **ディレクトリおよびファイルの容量を、分かりやすい単位（KB/MB/GB など）付きで表示したい**。
適切なコマンドを選びなさい。

### **選択肢**

1. `du -a dir`
2. `du -ah dir`
3. `du -c dir`
4. `du -s dir`
5. `du -sh dir`

---

### **正解**

✅ **`du -ah dir`**

---

### **解説**

#### **`du` コマンドとは？**

- **`du`（Disk Usage）コマンド**は、ファイルやディレクトリのディスク使用量を表示するためのコマンド。
- **`-h` オプションで「人間に読みやすい」形式（KB/MB/GBなど）で表示**される。

---

### **正解のコマンド**

#### **`du -ah dir`**

- `-a`（all）：**すべてのファイルとディレクトリの使用量を表示**
- `-h`（human-readable）：**サイズを KB/MB/GB 単位で見やすく表示**
- **目的に完全に一致するオプションの組み合わせ！**

✅ **正解！**

---

### **誤った選択肢の解説**

❌ **`du -a dir`**

- ファイルとディレクトリのサイズは表示されるが、**単位が付かない（バイト数）**。

⸻

❌ **`du -c dir`**

- `-c` は **合計を表示**するオプションであり、**単位表示や全ファイルのサイズ表示はしない**。

⸻

❌ **`du -s dir`**

- `-s` は **合計のみ（dir の総量）を表示**。
- **中のファイルやサブディレクトリのサイズは表示されない**。

⸻

❌ **`du -sh dir`**

- **`dir` 自体の合計サイズのみを単位付きで表示**する。
- **中の個別ファイルやディレクトリのサイズは表示されない**。

---

### **まとめ**

| コマンド         | 内容                                                   | 単位付き | 全ファイル表示 | 正解か |
| ---------------- | ------------------------------------------------------ | -------- | -------------- | ------ |
| **`du -ah dir`** | すべてのファイルとディレクトリのサイズを単位付きで表示 | ✅       | ✅             | ✅     |
| `du -a dir`      | 単位なしで全ファイル表示                               | ❌       | ✅             | ❌     |
| `du -c dir`      | 合計表示のみ（全ファイル不可）                         | ❌       | ❌             | ❌     |
| `du -s dir`      | 合計サイズのみ表示                                     | ❌       | ❌             | ❌     |
| `du -sh dir`     | 合計サイズのみを単位付きで表示                         | ✅       | ❌             | ❌     |

---

💡 **ポイント**

- **すべてのファイル・ディレクトリのサイズを確認したいなら `-a`！**
- **人間に読みやすい単位（KB/MB/GBなど）で見たいなら `-h`！**
- **`-ah` の組み合わせで、詳細＋単位表示を両立！**

✅ **「`du -ah dir` で、すべての容量を単位付きで見やすく表示！」**

## `e2fsck` コマンドで全ての問題を自動修復する方法

### **問題**

`e2fsck` コマンドで `/dev/sda4` をチェックする際に、
**ユーザーに確認せず、すべての問題を自動的に修復したい**。
適切なコマンドはどれか。

### **選択肢**

1. `e2fsck -auto /dev/sda4`
2. `e2fsck -n /dev/sda4`
3. `e2fsck -P /dev/sda4`
4. `e2fsck -p /dev/sda4`
5. `e2fsck -y /dev/sda4`

---

### **正解**

✅ **`e2fsck -p /dev/sda4`**

---

### **解説**

#### **`e2fsck` コマンドとは**

- **ext2/ext3/ext4 ファイルシステムの整合性チェックと修復を行うコマンド**。
- ファイルシステムに破損があった場合、問題点を報告し、必要であれば修復を試みる。

---

### **正解のオプション**

#### **`-p`（または `--preen`）**

- **ユーザーへの確認なしに、安全と思われる修復を自動的に実行する**。
- 通常は **システム起動時に自動チェック用として使用される**。
- 危険な修復操作（ファイルの削除など）は行わず、基本的な修復のみに限定。

✅ **正解！**

---

### **他の選択肢の解説**

❌ **`-auto`**

- **存在しないオプション**。
- `e2fsck` には `-auto` というオプションは定義されていない。

⸻

❌ **`-n`**

- **読み取り専用チェックを行う（変更はしない）**。
- どのような問題があるかを確認する用途には便利だが、**修復は行わない**。

⸻

❌ **`-P`**

- **複数のデバイスを並列でチェックする時の制御用**（複数デバイスを扱うスクリプト向け）。
- **単体のデバイスチェックで自動修復には関係なし**。

⸻

❌ **`-y`**

- **すべての質問に「yes」で自動応答する**。
- `-p` よりも強力で、**すべての修復操作を強制的に実行する**ため、**危険な修復も行われる可能性がある**。
- 完全自動化には便利だが、安全性を重視するなら `-p` の方が推奨される。

---

### **まとめ**

| オプション | 内容                               | 自動修復 | 安全性               | 正解か |
| ---------- | ---------------------------------- | -------- | -------------------- | ------ |
| **`-p`**   | 基本的な修復を自動実行（確認なし） | ✅       | 高い                 | ✅     |
| `-y`       | すべての操作に「yes」で応答        | ✅       | やや低い（強制修復） | ❌     |
| `-n`       | 読み取り専用で確認のみ             | ❌       | 高い                 | ❌     |
| `-P`       | 並列チェック制御用                 | ❌       | ―                    | ❌     |
| `-auto`    | 存在しないオプション               | ❌       | ―                    | ❌     |

---

💡 **ポイント**

- **安全に自動修復したい場合は `-p` オプション**
- **強制的にすべて修復したい場合は `-y` も使えるが、注意が必要**
- **チェックのみなら `-n`、情報だけ確認できる**

✅ **「基本的な自動修復を行いたいなら `e2fsck -p /dev/sda4`！」**

## ファイルやディレクトリが占めている容量を確認するコマンド

### **問題**

**ファイルやディレクトリが占めている容量** を確認できるコマンドは次のうちどれか。

### **選択肢**

1. `du`
2. `df`
3. `mkfs`
4. `ps`
5. `fdisk`

---

### **正解**

✅ **`du`**

---

### **解説**

#### **`du`（Disk Usage）**

- **ファイルやディレクトリ単位でディスクの使用量を表示するコマンド**。
- 指定したディレクトリ以下の各ファイル・ディレクトリが**どれだけのディスク容量を使用しているかを確認できる**。
- オプション例：
  ```bash
  du -sh /path/to/dir
  ```
  - -s: 合計のみ表示
  - -h: 人間に読みやすい単位で表示（KB/MB/GB）

✅ 正解！

⸻

誤った選択肢の解説

❌ df - ファイルシステム全体の使用量を確認するコマンド。- 各ファイルやディレクトリ単位の容量はわからない。- 使用例：

df -h

⸻

❌ mkfs - 新しくファイルシステムを作成するコマンド。- 使用量の確認には使えない。

⸻

❌ ps - プロセスの一覧を表示するコマンド。- ディスク容量とは無関係。

⸻

❌ fdisk - パーティションテーブルを操作するコマンド。- ファイルやディレクトリの容量確認には使えない。

⸻

### まとめ

```
コマンド	用途	容量確認	正解か
du	ファイル・ディレクトリごとの使用量表示	✅	✅
df	ファイルシステム全体の使用状況確認	❌	❌
mkfs	ファイルシステムの作成	❌	❌
ps	プロセスの表示	❌	❌
fdisk	パーティション操作	❌	❌
```

⸻

💡 ポイント - 個別のファイルやフォルダのサイズを見るなら du - ディスク全体の空き容量を確認するなら df - 用途に応じて使い分けよう！

✅ 「ファイルやディレクトリの容量を知りたいなら du！」

## XFSファイルシステムをチェックするコマンド

### **問題**

**XFSファイルシステムのチェック**を行うための適切なコマンドはどれか。

### **選択肢**

1. `xfs_check`
2. `xfs_fsck`
3. `xfs_db`
4. `xfs_info`
5. `mkfs.xfs`

---

### **正解**

✅ **`xfs_check`**

---

### **解説**

#### **`xfs_check`**

- **XFSファイルシステムの整合性をチェックするためのコマンド**。
- **読み取り専用でメタデータのチェックを行う**。
- 実行例：
  ```bash
  sudo xfs_check /dev/sdXn
  ```
  - 注意：マウントされていない状態で使う必要がある。

✅ 正解！

⸻

他の選択肢の解説

❌ xfs*fsck - 存在しないコマンド。- XFS では fsck の代わりに専用の xfs*\* 系ツールを使う。

⸻

❌ xfs_db - XFSのメタデータに対して対話的なアクセスやデバッグを行うツール。- チェック用ではなく、内部構造を調査・修復に使う低レベルツール。

⸻

❌ xfs_info - XFSファイルシステムの情報（ブロックサイズやinodeサイズなど）を表示するコマンド。- チェックではない。

⸻

❌ mkfs.xfs - XFSファイルシステムを新規に作成するためのコマンド。- チェックとは関係ない。

⸻

### まとめ

```

コマンド 用途 正解か
xfs_check XFSファイルシステムの整合性チェック ✅
xfs_fsck 存在しないコマンド ❌
xfs_db メタデータの調査・デバッグ用 ❌
xfs_info XFSの情報表示（構成確認） ❌
mkfs.xfs XFSファイルシステムの作成 ❌

```

⸻

💡 ポイント - xfs_check は XFS 専用のファイルシステムチェックツール！- マウントされていない状態で使うこと！- 最近では xfs_repair -n が推奨されることもあるが、選択肢にない場合は xfs_check が正解！

✅ 「XFS のチェックには xfs_check！」

## ext2/ext3/ext4 ファイルシステムのボリュームラベルを設定するオプション

### **問題**

ext2/ext3/ext4 ファイルシステムのボリュームラベルを設定する
`tune2fs` コマンドの適切なオプションはどれか。

### **選択肢**

1. `-L`
2. `-a`
3. `-j`
4. `-i`
5. `-c`

---

### **正解**

✅ **`-L`**

---

### **解説**

#### **`-L` オプション**

- **`tune2fs` コマンドでファイルシステムにラベル（名前）を設定・変更するためのオプション**。
- 対象は ext2/ext3/ext4 ファイルシステム。
- 使用例：

```bash
sudo tune2fs -L MyVolume /dev/sdXn
```

    -	この例では /dev/sdXn に MyVolume というラベルを設定。

✅ 正解！

⸻

誤った選択肢の解説

❌ -a - tune2fs には -a オプションは存在しない。

⸻

❌ -j - ext2 を ext3 に変換するための mke2fs コマンド用オプションであり、tune2fs のラベル設定とは無関係。

⸻

❌ -i - 自動チェックの間隔（日数）を設定するオプション。- 例：tune2fs -i 10 /dev/sda1 は10日ごとに自動チェック。

⸻

❌ -c - マウント回数によるチェックの設定。- 例：tune2fs -c 20 /dev/sda1 は20回マウントごとにチェック。

⸻

### まとめ

```
オプション	説明	正解か
-L	ボリュームラベルの設定	✅
-a	無効なオプション（存在しない）	❌
-j	mke2fs 用：ext2→ext3 変換	❌
-i	自動チェックの間隔（日数）	❌
-c	マウント回数によるチェック設定	❌
```

⸻

💡 ポイント - ボリュームラベルの設定は tune2fs -L ラベル名 デバイス名 - ラベルは e2label コマンドでも確認・設定できる

✅ 「ボリュームラベルの設定は -L オプション！」

## ext2/ext3/ext4ファイルシステム作成時に予約される領域

### **問題**

ext2/ext3/ext4 ファイルシステムを作成した時に、**rootユーザ用に予約される領域**として正しいものはどれか。

### **選択肢**

1. 200MB
2. ファイルシステム全体の5%
3. 1GB
4. ファイルシステム全体の1%
5. デフォルトでは予約されない

---

### **正解**

✅ **ファイルシステム全体の5%**

---

### **解説**

#### **予約領域とは？**

- ext2/ext3/ext4 ファイルシステムでは、**システムの安定性や緊急時の復旧を目的として、ファイルシステムの一部を root ユーザ専用に予約**する。
- この予約領域により、一般ユーザがディスクを100%使い切っても、**root ユーザはログインして復旧作業ができる**ように設計されている。

#### **デフォルト値**

- `mke2fs` または `mkfs.ext4` などでファイルシステムを作成する際、**デフォルトで 5% の領域が root 用に予約される**。

✅ **正解！**

---

### **確認・変更方法**

#### **確認**

```bash
sudo tune2fs -l /dev/sdXn | grep 'Reserved block count'
```

変更（例：1%に変更）

sudo tune2fs -m 1 /dev/sdXn

    -	-m は予約領域の割合（%）を指定するオプション。

⸻

誤った選択肢の解説

❌ 200MB / 1GB - 固定サイズではなく、全体容量に対するパーセンテージで指定される。

❌ ファイルシステム全体の1% - 変更すれば1%に設定可能だが、デフォルトは5%。

❌ デフォルトでは予約されない - ext2/ext3/ext4 の初期設定では 5% が予約されるため誤り。

⸻

### まとめ

```
選択肢	内容	正解か
200MB	固定サイズ → 誤り	❌
ファイルシステム全体の5%	デフォルト設定	✅
1GB	固定サイズ → 誤り	❌
ファイルシステム全体の1%	設定変更は可能だがデフォルトではない	❌
デフォルトでは予約されない	ext系では予約されるため誤り	❌
```

⸻

💡 ポイント - ext2/ext3/ext4 のファイルシステムは、デフォルトで5%の容量を root のために予約！- tune2fs -m を使って変更可能！

✅ 「予約領域はファイルシステム全体の 5%！」

## fsckコマンドでファイルシステムの整合性を自動修復するオプション

### **問題**

`fsck` コマンドでファイルシステムの整合性をチェックする際、
**障害箇所を自動的に修復したい**。
適切なオプションはどれか。

### **選択肢**

1. `-a`
2. `-N`
3. `-auto`
4. `-r`
5. `-A`

---

### **正解**

✅ **`-a`**

---

### **解説**

#### **`-a` オプション**

- **自動修復（非対話モード）**で整合性を修復するためのオプション。
- **fsck が見つけたエラーに対して、自動的に「yes」で修復を進める**。
- **一部のファイルシステム（特に ext 系）でのみ有効**。
- 使用例：
  ```bash
  sudo fsck -a /dev/sdXn
  ```

✅ 正解！

⸻

誤った選択肢の解説

❌ -N - 実行されるコマンドを表示するだけで実行しないオプション（dry-run的な用途）。

❌ -auto - 存在しないオプション。- 自動修復には -a または -y を使う。

❌ -r - 対話式モード。ユーザーに修復の確認を求めるオプション。- 自動ではないため、誤り。

❌ -A - /etc/fstab にあるすべてのファイルシステムをチェック対象にするオプション。- 修復の自動化とは直接関係しない。

⸻

### まとめ

```
オプション 内容 自動修復 正解か
-a 自動修復（yesで進行） ✅ ✅
-N 実行内容を表示するだけ（実行しない） ❌ ❌
-auto 存在しないオプション ❌ ❌
-r 対話式修復（確認あり） ❌ ❌
-A 全ファイルシステムチェック（fstab） ❌ ❌
```

⸻

💡 ポイント - fsck -a でエラーを自動修復！（一部ファイルシステムのみ対応）- 対話なしで完全自動なら -y も使用可能（-a より強力）

✅ 「自動で修復したいなら fsck -a を使おう！」

## ファイルシステムのチェック間隔を3日間に変更するコマンド

### **問題**

`/dev/sda2` の **ファイルシステムをチェックする間隔** を **3日ごと** に設定したい。
適切なコマンドを **2つ選択**しなさい。

### **選択肢**

1. `tune2fs -D 3i /dev/sda2`
2. `tune2fs -i 3d /dev/sda2`
3. `tune2fs -i 3 /dev/sda2`
4. `tune2fs -day 3 /dev/sda2`

---

### **正解**

✅ **`tune2fs -i 3d /dev/sda2`**
✅ **`tune2fs -i 3 /dev/sda2`**

---

### **解説**

#### **`tune2fs` コマンド**

- `tune2fs` は **ext2/ext3/ext4 ファイルシステムの設定を調整するコマンド**。
- `-i` オプションは **fsck による自動チェックの間隔（days/weeks/months）を指定**する。

---

### **正しいコマンド**

#### **1. `tune2fs -i 3d /dev/sda2`**

- **3日ごとに自動チェックする**ように設定。
- `3d` は「3 days（3日）」を意味する。

✅ **正解！**

⸻

#### **2. `tune2fs -i 3 /dev/sda2`**

- デフォルトでは単位なしの数字は「日（days）」と解釈されるため、**これも「3日間隔」を意味する**。

✅ **正解！**

---

### **誤った選択肢の解説**

❌ **`tune2fs -D 3i /dev/sda2`**

- 存在しないオプションと無効な構文。
- `-D` も `3i` も不正。

⸻

❌ **`tune2fs -day 3 /dev/sda2`**

- `-day` というオプションは存在しない。

---

### **まとめ**

| コマンド                      | 説明                            | 正解か |
| ----------------------------- | ------------------------------- | ------ |
| **`tune2fs -i 3d /dev/sda2`** | **3日間隔で自動チェック**       | ✅     |
| **`tune2fs -i 3 /dev/sda2`**  | **単位なしでも3日と解釈される** | ✅     |
| `tune2fs -D 3i /dev/sda2`     | 存在しないオプション            | ❌     |
| `tune2fs -day 3 /dev/sda2`    | 無効なオプション                | ❌     |

---

💡 **ポイント**

- **`tune2fs -i` オプションで自動fsckの実行間隔（日数・週・月）を設定可能！**
- 単位は `d`（days）、`w`（weeks）、`m`（months）

✅ **「`tune2fs -i 3d /dev/sda2` または `-i 3` で3日間隔に設定！」**

## ファイルシステムをチェックせずにマウントできる回数を変更するコマンド

### **問題**

ファイルシステムをチェックせずに「/dev/sda2」が**マウントできる回数**を **10回** に変更したい。
適切なコマンドはどれか。

### **選択肢**

1. `tune2fs -c 10 /dev/sda2`
2. `tune2fs -L 10 /dev/sda2`
3. `tune2fs -j 10 /dev/sda2`
4. `tune2fs -mount 10 /dev/sda2`
5. `tune2fs -i 10 /dev/sda2`

---

### **正解**

✅ **`tune2fs -c 10 /dev/sda2`**

---

### **解説**

#### **`-c` オプション**

- `-c` は **fsck（ファイルシステムチェック）が実行されるまでの最大マウント回数**を設定するオプション。
- **指定回数マウントされたら、自動的に fsck によるチェックが実行される**。
- 使用例：

```bash
sudo tune2fs -c 10 /dev/sda2
```

    -	このコマンドにより、「10回マウントされるまで fsck をスキップ」する設定になる。

✅ 正解！

⸻

誤った選択肢の解説

❌ -L - ファイルシステムのラベル（名前）を設定するオプション。マウント回数とは無関係。

❌ -j - ext2 を ext3 に変換するためのジャーナリング機能を追加するオプション（mke2fs用）。

❌ -mount - 存在しないオプション。誤記。

❌ -i - 日数ベースでチェック間隔を指定するオプション（例：-i 10d = 10日ごとにチェック）。- マウント回数ではなく、時間ベースのチェック設定。

⸻

### まとめ

```
オプション	説明	正解か
-c	マウント回数でチェックを行う条件を設定	✅
-L	ラベル（名前）を設定	❌
-j	ジャーナリング機能を追加（ext2→ext3）	❌
-mount	存在しないオプション	❌
-i	チェック実行間隔（日数）を設定	❌
```

⸻

💡 ポイント - マウント回数ベースでチェックを制御するには -c オプション！- 時間間隔ベースなら -i、ラベル変更なら -L を使う！

✅ 「tune2fs -c 10 /dev/sda2 で、10回マウントするまで fsck をスキップ！」

## `fsck`コマンドで実行せずに内容だけ表示する方法（ext3の例）

### **問題**

`fsck` コマンドで **ext3 ファイルシステム `/dev/sda4` の整合性をチェック**する際、
**実際には実行せず、「何が行われるか」だけを表示したい**。
適切なコマンドはどれか。

### **選択肢**

1. `fsck ext3 /dev/sda4`
2. `fsck -t -A ext3 /dev/sda4`
3. `fsck -t -N ext3 /dev/sda4`
4. `fsck -t ext3 /dev/sda4`
5. `fsck -N -t ext3 /dev/sda4`

---

### **正解**

✅ **`fsck -N -t ext3 /dev/sda4`**

---

### **解説**

#### **`-N` オプション**

- **実行されるコマンドを表示するだけで、実際には何も実行しない**（dry-run）。
- スクリプトでのテストや確認に便利。

#### **`-t ext3`**

- **対象のファイルシステムタイプ（ここでは ext3）を明示的に指定**。
- `fsck` は複数のファイルシステムに対応しているため、必要に応じて明示することで適切なサブコマンド（`fsck.ext3` など）を選択する。

#### **使用例**

```bash
sudo fsck -N -t ext3 /dev/sda4
```

    -	出力例（実際の修復は行われず、内部的にどのコマンドが実行されるかを表示）：

```
Would execute command: fsck.ext3 /dev/sda4
```

✅ 正解！

⸻

誤った選択肢の解説

❌ fsck ext3 /dev/sda4 - 不正な構文。- ext3 がデバイス名のように解釈されてしまうため、正しく動作しない。

⸻

❌ fsck -t -A ext3 /dev/sda4 - -A は /etc/fstab に基づいて全ファイルシステムを処理するためのもので、単一のデバイス /dev/sda4 と併用するのは不自然。- -t の直後にファイルシステムタイプがないため構文ミスでもある。

⸻

❌ fsck -t -N ext3 /dev/sda4 - オプションの順序と構文が正しくない。- -t に続くファイルシステムタイプ ext3 が -N に割り込まれてしまっている。

⸻

❌ fsck -t ext3 /dev/sda4 - 正常に ext3 のチェックは実行されるが、実行を「表示するだけ」ではないため不正解。

⸻

### まとめ

```
コマンド 内容 実行されるか 正解か
fsck -N -t ext3 /dev/sda4 実行せず内容のみ表示 ❌ 実行されない ✅
fsck ext3 /dev/sda4 構文ミス ― ❌
fsck -t -A ext3 /dev/sda4 全体対象＋構文不正 実行される可能性あり ❌
fsck -t -N ext3 /dev/sda4 オプション順序が不正 ― ❌
fsck -t ext3 /dev/sda4 実行される（表示のみではない） ✅ 実行される ❌
```

⸻

💡 ポイント - -N：実行内容だけ表示（dry-run）- -t ファイルシステムタイプ：対象FSを明示 - fsck -N -t ext3 /dev/sda4 で実際には何もせず内容だけ表示できる！

✅ 「実行せず内容だけ確認したいなら fsck -N -t ext3 /dev/sda4！」

## XFSファイルシステムの情報を表示するコマンド

### **問題**

XFSファイルシステムの**情報を表示するための適切なコマンド**はどれか。

### **選択肢**

1. `mkfs.xfs`
2. `info.xfs`
3. `check.xfs`
4. `xfs_db`
5. `xfs_info`

---

### **正解**

✅ **`xfs_info`**

---

### **解説**

#### **`xfs_info` コマンド**

- **XFSファイルシステムの詳細情報（ブロックサイズ、セクタサイズ、ログ情報など）を表示するコマンド**。
- マウントされた XFS ファイルシステムに対して使用する。
- 使用例：

```bash
sudo xfs_info /mnt/data
```

    -	出力例：

```
meta-data=/dev/sda1              isize=512    agcount=4, agsize=327680 blks
         =                       sectsz=512   attr=2, projid32bit=1
```

...

✅ 正解！

⸻

誤った選択肢の解説

❌ mkfs.xfs - XFSファイルシステムを新しく作成するコマンド。- 情報を表示する用途ではない。

⸻

❌ info.xfs - 存在しないコマンド。

⸻

❌ check.xfs - 存在しないコマンド名。チェックは xfs_check または xfs_repair で行う。

⸻

❌ xfs_db - XFSメタデータを操作・調査するための対話的な低レベルツール。- 詳細情報の表示は可能だが、通常の情報確認には不向き。

⸻

### まとめ

```
コマンド	内容	正解か
xfs_info	XFSファイルシステムの基本情報表示	✅
mkfs.xfs	XFSファイルシステムの作成	❌
info.xfs	存在しない	❌
check.xfs	存在しない	❌
xfs_db	メタデータの調査・操作用（上級者向け）	❌
```

⸻

💡 ポイント - XFSの基本情報を確認したいなら xfs_info！- 高度な調査は xfs_db、整合性チェックは xfs_check や xfs_repair を使おう

✅ 「XFS の情報表示には xfs_info！」

## inodeの使用状況を確認するコマンド

### **問題**

inode の**使用状況（使用中/残りの数）**を確認するための適切なコマンドはどれか。

### **選択肢**

1. `df -h`
2. `df -i`
3. `df -u`
4. `df -I`
5. `df -H`

---

### **正解**

✅ **`df -i`**

---

### **解説**

#### **`df -i`**

- **ディスクの inode 使用状況（使用済み/空き）を表示するオプション**。
- 各マウントポイントごとの inode の数と使用率が確認できる。
- 使用例：

```bash
df -i
```

    -	出力例：

```
Filesystem     Inodes  IUsed   IFree IUse% Mounted on
/dev/sda1     6553600 125000 6428600    2% /
```

✅ 正解！

⸻

誤った選択肢の解説

❌ df -h - ディスク容量（サイズ・使用量）を「人間に読みやすい単位」で表示。- inode の情報は表示されない。

⸻

❌ df -u - 存在しないオプション。無効。

⸻

❌ df -I - df に -I オプションは存在しない。大文字小文字にも注意。

⸻

❌ df -H - ディスク容量を 1000バイト単位（SI単位） で表示。- inode とは無関係。

⸻

まとめ

コマンド 説明 inode表示 正解か
df -i inodeの使用状況を表示 ✅ ✅
df -h 容量を人間に読みやすく表示（MB/GBなど） ❌ ❌
df -u 存在しないオプション ❌ ❌
df -I 存在しないオプション（大文字） ❌ ❌
df -H 容量をSI単位（1000バイト）で表示 ❌ ❌

⸻

💡 ポイント - df -i で inode の「使用中」「残り」「使用率」が確認できる！- inode を使い切ると空き容量があってもファイルが作れなくなるので注意！

✅ 「inode の使用状況を確認するには df -i！」

## ファイルシステムのチェックおよび修復を行うコマンド

### **問題**

**ファイルシステムの整合性チェック**および **問題を修復** できるコマンドは次のうちどれか。  
（**全て選択**）

### **選択肢**

1. `fdisk`
2. `tune2fs`
3. `e2fsck`
4. `mke2fs`
5. `fsck`

---

### **正解**

✅ **`fsck`**  
✅ **`e2fsck`**

---

### **解説**

#### ✅ `fsck`（File System Consistency Check）

- **多くのファイルシステムに対応した整合性チェックツールのフロントエンド**。
- 使用するファイルシステムに応じて、`e2fsck`、`xfs_repair` など適切な実行ファイルを呼び出す。
- 問題を自動的に修復するには `-a` や `-y` オプションを使う。
- 例：
  ```bash
  sudo fsck /dev/sda1
  ```
  ✅ e2fsck - ext2/ext3/ext4 専用のファイルシステムチェックツール。- fsck が内部的に呼び出すこともある。- 例：

sudo e2fsck -p /dev/sda1

⸻

❌ 誤った選択肢の解説

❌ fdisk - ディスクのパーティション操作ツール（作成・削除など）。- ファイルシステムのチェックや修復は行わない。

❌ tune2fs - ext系ファイルシステムの設定を調整するツール（予約領域やチェック間隔など）。- 修復は行わない。

❌ mke2fs - 新しい ext2/ext3/ext4 ファイルシステムを作成するツール。- 整合性チェックや修復の機能はない（フォーマットに近い操作）。

⸻

### まとめ

```

コマンド 用途 修復機能 正解か
fsck ファイルシステムのチェックと修復（汎用） ✅ ✅
e2fsck ext2/3/4用のチェックと修復 ✅ ✅
fdisk パーティションの操作 ❌ ❌
tune2fs ファイルシステム設定の調整（ラベル・間隔など） ❌ ❌
mke2fs 新しいファイルシステムを作成 ❌ ❌

```

⸻

💡 ポイント - チェック＋修復 = fsck（汎用） or e2fsck（ext系）！- fdisk や tune2fs は設定やパーティション操作用。修復はできない！

✅ 「ファイルシステムの問題を修復したいなら fsck または e2fsck！」

## ext2ファイルシステムをext3に変換するコマンド

### **問題**

ext2ファイルシステムの **「/dev/hda5」** を **ext3 に変換**したい。
適切なコマンドはどれか。

### **選択肢**

1. `tune2fs -t ext3 /dev/hda5`
2. `tune2fs -j ext3 /dev/hda5`
3. `tune2fs -j /dev/hda5`
4. `mkfs -t ext3 /dev/hda5`
5. `mke2fs -j /dev/hda5`

---

### **正解**

✅ **`tune2fs -j /dev/hda5`**

---

### **解説**

#### ✅ `tune2fs -j /dev/hda5`

- **ext2 を ext3 に変換するための正しい手順**。
- ext3 は ext2 に「ジャーナリング機能」を追加したものなので、`tune2fs` で `-j` オプションを使うことで **ジャーナルを追加＝ext3 へ変換** となる。
- 使用例：

```bash
sudo tune2fs -j /dev/hda5
```

    -	変換後は /etc/fstab のファイルシステムタイプを ext2 → ext3 に変更するのを忘れずに！

✅ 正解！

⸻

❌ 誤った選択肢の解説

❌ tune2fs -t ext3 /dev/hda5 - -t オプションは ファイルシステムの種類ではなく、エラー処理の動作を指定する用途。- ext2 → ext3 の変換には無関係。

⸻

❌ tune2fs -j ext3 /dev/hda5 - -j オプションは引数を取らず、構文ミス。

⸻

❌ mkfs -t ext3 /dev/hda5 - これは ext3 ファイルシステムを新規作成（＝フォーマット）するコマンド。- 既存データはすべて消えるため、変換ではなく破壊的な再作成になる。

⸻

❌ mke2fs -j /dev/hda5 - これも ext3 ファイルシステムを作成するコマンドであり、既存の ext2 を変換するものではない。

⸻

### まとめ

```
コマンド	内容	変換できるか	正解か
tune2fs -j /dev/hda5	ext2 にジャーナルを追加 → ext3に変換	✅	✅
tune2fs -t ext3 /dev/hda5	エラー動作の設定 → 関係なし	❌	❌
tune2fs -j ext3 /dev/hda5	-j オプションは引数不要 → 構文エラー	❌	❌
mkfs -t ext3 /dev/hda5	ext3を新規作成（フォーマット） → データ消失	❌（再作成）	❌
mke2fs -j /dev/hda5	ext3を新規作成（ジャーナル付き）	❌（再作成）	❌
```

⸻

💡 ポイント - ext2 → ext3 変換は「ジャーナル追加」だけでOK！- 非破壊的に変換できるのは tune2fs -j のみ！

✅ 「ext2 を ext3 に変換するなら tune2fs -j /dev/hda5！」

## fsckコマンドで対話的に修復を行うオプション

### **問題**

`fsck` コマンドでファイルシステムの整合性をチェックする際、  
**障害箇所をユーザーに確認しながら（対話的に）修復したい**。  
適切なオプションはどれか。

### **選択肢**

1. `-N`
2. `-r`
3. `-t`
4. `-a`
5. `-A`

---

### **正解**

✅ **`-r`**

---

### **解説**

#### ✅ `-r`（repair interactively）

- **fsck 実行時に障害箇所が見つかった場合、ユーザーに修復するかどうかを確認しながら進めるオプション**。
- 通常はデフォルトで対話モードになるが、**明示的に指定したい場合に使用**。
- 使用例：

```bash
sudo fsck -r /dev/sda1
```

    -	出力例（確認を求められる）：

```
Inode 12345 has invalid mode.
Fix<y>?
```

✅ 正解！

⸻

❌ 誤った選択肢の解説

❌ -N - 実行せずに、実際にどのコマンドが呼ばれるかを表示する（dry-run）。- 修復は行わない。

⸻

❌ -t - ファイルシステムのタイプ（例：ext3, xfs など）を指定するオプション。- 修復方法には関係しない。

⸻

❌ -a - 自動修復モード（non-interactive）。- ユーザーに確認せず自動的に修復するので、対話的ではない。

⸻

❌ -A - /etc/fstab に記載されたファイルシステムすべてをチェック対象にするオプション。- 修復の方式には無関係。

⸻

### まとめ

```
オプション	内容	対話的修復	正解か
-r	対話的に修復（修復前に確認）	✅	✅
-N	実行内容の表示のみ（dry-run）	❌	❌
-t	ファイルシステムタイプを指定	❌	❌
-a	自動修復（ユーザー確認なし）	❌	❌
-A	全ファイルシステム対象（/etc/fstab 参照）	❌	❌
```

⸻

💡 ポイント - 対話的に修復したいなら -r（repair interactively）- 一切確認せず自動修復するなら -a または -y を使う - 安全に進めたいときは -r で手動判断がおすすめ！

✅ 「fsck で確認しながら修復したいなら fsck -r /dev/sdXn！」

## XFSファイルシステムのデバッグを行うコマンド

### **問題**

XFSファイルシステムの**デバッグ（詳細な内部構造の調査や操作）**を行うための適切なコマンドはどれか。

### **選択肢**

1. `xfs_fsr`
2. `xfs_check`
3. `xfs_db`
4. `metadump.xfs`
5. `mkfs.xfs`

---

### **正解**

✅ **`xfs_db`**

---

### **解説**

#### ✅ `xfs_db`

- **XFS ファイルシステムのメタデータを直接調査・操作できる低レベルのデバッグツール**。
- 主にトラブルシューティングや詳細な内部構造の確認に使用される。
- **破損したファイルシステムの修復や状態確認**にも役立つ。
- 使用例（読み取り専用で開く）：

```bash
sudo xfs_db -r /dev/sdXn
```

    -	対話モードで操作でき、sb（スーパーブロック）、inode、block などの情報が取得できる。

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ xfs_fsr - XFS ファイルシステムのデフラグ（断片化の解消）を行うコマンド。- デバッグ用途ではない。

⸻

❌ xfs_check - XFS ファイルシステムの整合性チェックを行うツール（読み取り専用）。- デバッグではなく健全性の確認に使用される。

⸻

❌ metadump.xfs - XFS メタデータのダンプ（バックアップ）を作成するコマンド。- デバッグ作業そのものではなく、問題調査用データを抽出するために使用。

⸻

❌ mkfs.xfs - XFS ファイルシステムを新規に作成するコマンド。- デバッグやトラブル対応とは無関係。

⸻

### まとめ

```
コマンド	用途	デバッグ対応	正解か
xfs_db	XFSメタデータの調査・操作（デバッグ用）	✅	✅
xfs_fsr	デフラグ（最適化）	❌	❌
xfs_check	整合性チェック（読み取り専用）	❌	❌
metadump.xfs	メタデータのダンプ作成	❌（補助的）	❌
mkfs.xfs	ファイルシステムの新規作成	❌	❌
```

⸻

💡 ポイント - XFS の内部を詳しく調査・デバッグしたい場合は xfs_db！- 使用には十分注意が必要（特に書き込みモード）

✅ 「XFS のデバッグには xfs_db を使おう！」

## `/etc/fstab` に記載された全ファイルシステムをチェックする fsck のオプション

### **問題**

`/etc/fstab` ファイルに記述されている**すべてのファイルシステムをチェック**したい。  
そのために使う `fsck` コマンドの適切なオプションはどれか。

### **選択肢**

1. `-ALL`
2. `-A`
3. `-all`
4. `-N`
5. `-t`

---

### **正解**

✅ **`-A`**

---

### **解説**

#### ✅ `-A` オプション

- **`/etc/fstab` に記述されているすべてのファイルシステムを対象にチェックを実行する**。
- ブート時に自動でファイルシステムを検査する処理と同等の処理を手動で行える。
- `fs_passno`（fstab の第6フィールド）に基づいて優先度付きでチェックが実行される。

##### 使用例：

```bash
sudo fsck -A
```

✅ 正解！

⸻

❌ 誤った選択肢の解説

❌ -ALL / -all - 存在しないオプション。大文字・小文字を変えても無効。

⸻

❌ -N - dry-run（実行せずに実行されるコマンドを表示）するオプション。- 実際のチェックは行われない。

⸻

❌ -t - ファイルシステムの種類を指定するオプション（例：-t ext4）。- -A と組み合わせて、特定のタイプだけを対象にするために使用される補助的なオプション。

⸻

### まとめ

```
オプション	説明	チェック対象	実行されるか	正解か
-A	/etc/fstab 全体に基づいてファイルシステムをチェック	✅	✅	✅
-ALL	無効なオプション（存在しない）	❌	❌	❌
-all	無効なオプション（存在しない）	❌	❌	❌
-N	実行されるコマンドの確認だけ（dry-run）	✅	❌	❌
-t	ファイルシステムタイプ指定（補助用）	条件付き	✅	❌
```

⸻

💡 ポイント - 複数のファイルシステムを一括チェックするには -A オプション - /etc/fstab の設定に基づいて安全に順序を守ってチェックされる

✅ 「全ファイルシステムをまとめてチェックしたいなら fsck -A！」

## XFSファイルシステムの検査・修復を行うコマンド

### **問題**

XFSファイルシステムの**検査および修復**を行いたい。  
適切なコマンドはどれか。

### **選択肢**

1. `xfs_info`
2. `xfs_check`
3. `xfs_db`
4. `xfs_fsr`
5. `xfs_repair`

---

### **正解**

✅ **`xfs_repair`**

---

### **解説**

#### ✅ `xfs_repair`

- **XFS ファイルシステム専用の検査・修復ツール**。
- **メタデータの整合性を検査・修復**し、破損している構造を修復する。
- 通常、**マウントされていない状態のデバイスに対して使用**する。

##### 使用例：

```bash
sudo umount /dev/sdXn
sudo xfs_repair /dev/sdXn
```

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ xfs_info - XFSファイルシステムの情報（ブロックサイズ・セクターサイズなど）を表示するツール。- 修復には使えない。

⸻

❌ xfs_check - 古い検査専用ツール。- 現在は非推奨であり、検査も xfs_repair -n を使うのが主流。- 実際には修復機能がない。

⸻

❌ xfs_db - XFSのメタデータを手動で調査・操作する高度なデバッグツール。- 使いこなすには専門知識が必要で、一般的な修復には不向き。

⸻

❌ xfs_fsr - XFSファイルシステムのデフラグ（最適化）を行うツール。- 整合性チェックや修復とは無関係。

⸻

### まとめ

```
コマンド	用途	修復機能	正解か
xfs_repair	XFSファイルシステムの検査・修復	✅	✅
xfs_info	ファイルシステム情報の表示	❌	❌
xfs_check	検査のみ（非推奨）	❌	❌
xfs_db	メタデータのデバッグ用	❌	❌
xfs_fsr	デフラグ（断片化解消）	❌	❌
```

⸻

💡 ポイント - XFSファイルシステムの修復には xfs_repair！- 読み取り専用チェックを行いたい場合は xfs_repair -n が推奨される - 実行前にはマウント解除を忘れずに！

✅ 「XFS を修復したいなら xfs_repair を使おう！」

## ext2/ext3/ext4ファイルシステムのパラメータを設定するコマンド

### **問題**

ext2/ext3/ext4 ファイルシステムの**パラメータ（例：ラベル、チェック間隔、予約領域など）を設定**したい。  
適切なコマンドはどれか。

### **選択肢**

1. `e2fsck`
2. `df`
3. `tune2fs`
4. `du`
5. `mkfs`

---

### **正解**

✅ **`tune2fs`**

---

### **解説**

#### ✅ `tune2fs`

- **ext2/ext3/ext4 ファイルシステムの各種パラメータを設定・変更するための専用コマンド**。
- 以下のような設定が可能：
  - ボリュームラベルの変更（`-L`）
  - fsck のチェック間隔（日数 or 回数）（`-i`, `-c`）
  - 予約領域の割合（`-m`）
  - ラストマウント日時やマウント回数の表示 など

##### 使用例：

```bash
sudo tune2fs -L MyVolume /dev/sda1        # ラベルを設定
sudo tune2fs -c 10 /dev/sda1              # チェックなしでマウントできる回数を10回に設定
sudo tune2fs -i 7d /dev/sda1              # 7日ごとにチェック
```

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ e2fsck - ファイルシステムのチェック・修復を行うコマンド。- パラメータの設定は行えない。

⸻

❌ df - ディスク使用量を表示するコマンド。- 設定は一切変更できない。

⸻

❌ du - ファイルやディレクトリ単位の容量（使用量）を表示するコマンド。- ファイルシステムの設定変更とは無関係。

⸻

❌ mkfs - 新しいファイルシステムを作成（フォーマット）するコマンド。- 一度作成したファイルシステムの「パラメータの調整」には使えない。

⸻

### まとめ

```
コマンド	用途	パラメータ設定可	正解か
tune2fs	ext系ファイルシステムのパラメータ調整	✅	✅
e2fsck	チェック・修復	❌	❌
df	使用量表示	❌	❌
du	ディレクトリ・ファイル容量表示	❌	❌
mkfs	ファイルシステムの新規作成	❌	❌
```

⸻

💡 ポイント - ext2/ext3/ext4 のパラメータ調整は tune2fs で！- 安全な運用・パフォーマンス調整に不可欠なコマンド

✅ 「パラメータ設定したいなら tune2fs！」

## systemdのmountユニットに関する正しい説明

### **問題**

systemd の **mountユニット** に関する説明として**正しいものを2つ**選びなさい。

### **選択肢**

1. 「/etc/fstab」の内容から mount ユニットが自動生成される
2. 手動でマウントを行うと、マウントポイント名の mount ユニットが生成される
3. 「/etc/fstab」の内容からスワップ領域が設定される
4. mount ユニットはインストール時に生成され、「/etc/fstab」の内容は反映されない
5. 手動でマウントを行うと、mount ユニットは生成されない

---

### **正解**

✅ **1. 「/etc/fstab」の内容から mount ユニットが自動生成される**  
✅ **2. 手動でマウントを行うと、マウントポイント名の mount ユニットが生成される**

---

### **解説**

#### ✅ 1. 「/etc/fstab」の内容から mount ユニットが自動生成される

- systemd は **起動時に `/etc/fstab` を読み取り、その内容に基づいて `.mount` ユニットを動的に生成**します。
- これにより fstab を使った従来のマウント設定が systemd にも反映されます。

✅ **正解！**

---

#### ✅ 2. 手動でマウントを行うと、マウントポイント名の mount ユニットが生成される

- `mount /mnt/data` のように手動でマウントすると、systemd は内部的にそのマウント状態を管理するために、**該当する mount ユニット（例: `mnt-data.mount`）を自動でトラッキング対象にします**。
- 厳密には persistent な `.mount` ユニットファイルが生成されるわけではありませんが、**ユニットとして認識・管理されます**。

✅ **正解！**

---

### ❌ その他の選択肢

#### ❌ 3. 「/etc/fstab」の内容からスワップ領域が設定される

- これは **swap ユニット (`.swap`) に関する内容**であり、**mount ユニットとは別の概念**。

⸻

#### ❌ 4. mount ユニットはインストール時に生成され、「/etc/fstab」の内容は反映されない

- systemd は起動時に `fstab` をパースして mount ユニットを**動的に生成**するため、**インストール時に固定の mount ユニットを作成するわけではない**。

⸻

#### ❌ 5. 手動でマウントを行うと、mount ユニットは生成されない

- 手動マウントは systemd に認識され、**マウント状態を管理するユニットとして扱われます**（ユニットファイルが生成されるわけではないが、systemd はそれを管理）。

---

### **まとめ**

| 選択肢 | 内容                                              | 正誤    |
| ------ | ------------------------------------------------- | ------- |
| 1      | `/etc/fstab` から mount ユニット自動生成          | ✅ 正解 |
| 2      | 手動マウントでも mount ユニットが生成される       | ✅ 正解 |
| 3      | スワップ領域に関する内容（mountとは別）           | ❌      |
| 4      | mount ユニットはインストール時に作られる？ → 誤り | ❌      |
| 5      | 手動マウントではユニットは生成されない？ → 誤り   | ❌      |

---

💡 **ポイント**

- systemd は **従来の fstab 設定にも完全対応**しており、自動で `.mount` ユニットを生成
- 手動マウントした場合も、systemd によってその状態は**ユニットとして管理される**

✅ **「mount ユニットは fstab からも、手動マウントからも動的に扱われる！」**

## `/etc/fstab` における CD-ROM の設定に関する正しい説明

### **問題**

以下のようなエントリが `/etc/fstab` にあるとき、  
**正しい説明を3つ選びなさい。**

```fstab
/dev/cdrom /mnt/cdrom iso9660 defaults,users,noauto 0 0
```

選択肢 1. mount /mnt/cdrom コマンドでマウントできる 2. 誰でもアンマウントできる 3. マウントしたユーザしかアンマウントできない 4. 起動時に自動的にマウントされる 5. 誰でもマウントできる

⸻

正解

✅ 1. mount /mnt/cdrom コマンドでマウントできる
✅ 2. 誰でもアンマウントできる
✅ 5. 誰でもマウントできる

⸻

### 解説

/etc/fstab の構成

```
<デバイス>   <マウントポイント>  <ファイルシステム>  <マウントオプション>     <dump>  <fsck>
/dev/cdrom   /mnt/cdrom          iso9660             defaults,users,noauto  0       0
```

    -	noauto: 起動時には自動でマウントしない。
    -	users: 一般ユーザでもマウント・アンマウントが可能。
    -	defaults: 通常のデフォルトオプションを適用。

⸻

### ✅ 正解の説明

✅ 1. mount /mnt/cdrom コマンドでマウントできる - fstab に記述されていれば、マウント元・タイプが省略されても mount /mnt/cdrom でマウント可能。

✅ 2. 誰でもアンマウントできる - users オプションにより、マウントしたユーザ以外でもアンマウントが可能。

✅ 5. 誰でもマウントできる - users により、root 以外の一般ユーザもマウントが可能。

⸻

### ❌ 不正解の説明

❌ 3. マウントしたユーザしかアンマウントできない - user オプションを使用した場合はこの動作だが、
users オプションでは「誰でもアンマウント可」となる。

❌ 4. 起動時に自動的にマウントされる - noauto が指定されているため、自動マウントはされない。

⸻

### まとめ

```
選択肢	内容	正誤
mount /mnt/cdrom でマウントできる	✅ fstab 記載により可能	✅
誰でもアンマウントできる	✅ users オプションの効果	✅
マウントしたユーザしかアンマウントできない	❌ user の動作、今回は users	❌
起動時に自動マウントされる	❌ noauto により自動マウントされない	❌
誰でもマウントできる	✅ users により可能	✅
```

⸻

💡 ポイント - user → マウント/アンマウントはそのユーザのみ - users → すべての一般ユーザがマウント・アンマウント可能 - noauto → 起動時の自動マウントを無効化

✅ 「users + noauto で、誰でもマウント可能＆起動時はマウントしない設定！」

## `/etc/fstab` の第1フィールドに指定できる値

### **問題**

`/etc/fstab` の **1つ目の設定項目（第1フィールド）** に指定できる値として正しいものを **3つ** 選びなさい。

### **選択肢**

1. `defaults`
2. `/dev/sda1`
3. `ext3`
4. `UUID=3b80b96c-df15-401e-b74c-e8dcbfb68cec`
5. `LABEL=/boot`

---

### **正解**

✅ **`/dev/sda1`**  
✅ **`UUID=3b80b96c-df15-401e-b74c-e8dcbfb68cec`**  
✅ **`LABEL=/boot`**

---

### **解説**

#### ✅ `/etc/fstab` の第1フィールドとは？

- 第1フィールドは **マウントする対象（デバイスや識別子）** を指定します。
- 指定可能な値には以下が含まれます：
  - **デバイスファイル名**（例：`/dev/sda1`）
  - **UUID指定**（例：`UUID=xxxx-xxxx`）
  - **ラベル指定**（例：`LABEL=/boot`）

---

### ✅ 正しい選択肢の解説

#### ✅ `/dev/sda1`

- **直接的なデバイス名の指定**。
- 最も一般的な方法のひとつ。

#### ✅ `UUID=3b80b96c-df15-401e-b74c-e8dcbfb68cec`

- **UUID（Universal Unique Identifier）を使った指定方法**。
- `blkid` コマンドなどで確認できる。

#### ✅ `LABEL=/boot`

- **ボリュームラベルによる指定方法**。
- `tune2fs` や `e2label` で設定されたラベルを使用。

---

### ❌ 不正解の解説

#### ❌ `defaults`

- **マウントオプション**であり、**第4フィールド**に記述するもの。
- 第1フィールドには無効。

#### ❌ `ext3`

- **ファイルシステムの種類**であり、**第3フィールド**に記述される。

---

### **fstab のフィールド構成（参考）**

| フィールド番号 | 意味                   | 例                               |
| -------------- | ---------------------- | -------------------------------- |
| 第1フィールド  | デバイス名 or 識別子   | `/dev/sda1`, `UUID=`, `LABEL=`   |
| 第2フィールド  | マウントポイント       | `/`, `/boot`, `/home`            |
| 第3フィールド  | ファイルシステムの種類 | `ext4`, `xfs`, `vfat`            |
| 第4フィールド  | マウントオプション     | `defaults`, `noauto`, `ro`, など |
| 第5フィールド  | dumpバックアップ有無   | `0` または `1`                   |
| 第6フィールド  | fsck実行順序           | `0`（無効）, `1`（優先）など     |

---

### **まとめ**

| 選択肢                   | 第1フィールドとして正しいか | 説明                                    |
| ------------------------ | --------------------------- | --------------------------------------- |
| `/dev/sda1`              | ✅                          | 一般的なデバイス名                      |
| `UUID=3b80b96c-df15-...` | ✅                          | UUIDによる識別                          |
| `LABEL=/boot`            | ✅                          | ラベルによる識別                        |
| `defaults`               | ❌                          | 第4フィールド（マウントオプション）     |
| `ext3`                   | ❌                          | 第3フィールド（ファイルシステムタイプ） |

---

💡 **ポイント**

- **fstab の第1フィールドには、どのデバイスをマウントするかを記述する**
- **`/dev/～`, `UUID=～`, `LABEL=～` がよく使われる**

✅ **「fstabの第1フィールドにはデバイス指定：`/dev/sda1`, `UUID=...`, `LABEL=...`！」**

## `/etc/fstab` に関する正しい記述

### **問題**

`/etc/fstab` に関して**正しいものを2つ**選びなさい。

### **選択肢**

1. `mount -a` コマンド実行時にマウントされないマウントオプション指定は `noauto` である
2. デフォルトのマウントオプションを使用する場合は、マウントオプションの項目は記載してはいけない
3. デフォルトのマウントオプションを使用する場合は、リードオンリーでマウントされる
4. デバイス名を指定するのは、UUID と LABEL のみである
5. 項目数は 6 つである
6. 項目数は 5 つである

---

### **正解**

✅ **1. `mount -a` コマンド実行時にマウントされないマウントオプション指定は `noauto` である**  
✅ **5. 項目数は 6 つである**

---

### **解説**

#### ✅ 1. `mount -a` でマウントされない条件：`noauto`

- `noauto` オプションが指定されたエントリは、**`mount -a` 実行時でもマウントされません**。
- 明示的に `mount /マウントポイント` でマウントする必要があります。

#### ✅ 5. 項目数は 6 つである

`/etc/fstab` の各行は 6 つのフィールドで構成されます：

| フィールド番号 | 説明                                        |
| -------------- | ------------------------------------------- |
| 1              | デバイス名（例: `/dev/sda1`, `UUID=...`）   |
| 2              | マウントポイント（例: `/`, `/boot`）        |
| 3              | ファイルシステムの種類（例: `ext4`, `xfs`） |
| 4              | マウントオプション（例: `defaults`, `ro`）  |
| 5              | dump によるバックアップの有無（通常 0）     |
| 6              | fsck 実行順序（0: 実行しない, 1: ルート）   |

---

### ❌ 不正解の解説

#### ❌ 2. 「マウントオプションは記載してはいけない」

- **記載しないとマウントできないこともあるため誤り**。  
  デフォルトで良ければ `defaults` と明記する。

#### ❌ 3. 「デフォルトだとリードオンリーでマウントされる」

- **`defaults` はリード/ライト（rw）です**。リードオンリーは `ro` オプションを明示する必要があります。

#### ❌ 4. 「UUIDとLABELしか使えない」

- `/dev/sdX` などの **デバイスファイルも使用可能** なので誤り。

#### ❌ 6. 「項目数は5つ」

- 正しくは **6つ** です。

---

### **まとめ**

| 選択肢 | 内容                                  | 正誤    |
| ------ | ------------------------------------- | ------- |
| 1      | `noauto` だと `mount -a` に含まれない | ✅ 正解 |
| 2      | マウントオプションは省略不可 → 誤り   | ❌      |
| 3      | `defaults` = 読み書き可（rw） → 誤り  | ❌      |
| 4      | `/dev/sdX` なども使える → 誤り        | ❌      |
| 5      | `/etc/fstab` の項目は6つ → 正解       | ✅      |
| 6      | 項目数5つ → 誤り                      | ❌      |

---

💡 **ポイント**

- `noauto` → 明示しないとマウントされない
- `/etc/fstab` の行は必ず **6フィールド**

✅ **「`fstab` の項目数は6つ！ `noauto` は自動マウントされない！」**

## マウントされたデバイスの正しいアンマウント方法

### **問題**

次のコマンドで `/dev/sdb2` を `/data` にマウントした：

```bash
mount -t xfs /dev/sdb2 /data
```

この後、エラーを出さずに正しくアンマウントするためのコマンドを 3つ選びなさい。

選択肢1. umount -at xfs 2. umount /data /dev/sdb2 3. umount /dev/sdb2 /data 4. umount /data 5. umount /dev/sdb2

⸻

正解

✅ umount /dev/sdb2
✅ umount /data
✅ umount -at xfs

⸻

### 解説

✅ umount /dev/sdb2 - デバイス名を指定してアンマウント。- /dev/sdb2 が /data にマウントされていれば正しくアンマウントされる。

✅ umount /data - マウントポイント名を指定してアンマウント。- こちらも /dev/sdb2 を /data にマウントしていた場合、有効。

✅ umount -at xfs - -a: /etc/mtab に記載されたすべてのファイルシステムを対象 - -t xfs: ファイルシステムタイプが xfs のものだけアンマウント - この条件にマッチする /dev/sdb2 が対象となり、アンマウントされる。

⸻

### ❌ 不正解の選択肢

❌ umount /data /dev/sdb2 - 複数の引数を同時に渡すのは無効（順番の問題ではなく構文エラー）。

❌ umount /dev/sdb2 /data - 上記と同じ理由で、同時指定はエラーになる可能性がある。- 正しくは一つずつアンマウントすべき。

⸻

### まとめ

```
コマンド	内容	正解か
umount /dev/sdb2	デバイス名指定でアンマウント	✅
umount /data	マウントポイント名指定でアンマウント	✅
umount -at xfs	xfs ファイルシステム全体をアンマウント	✅
umount /data /dev/sdb2	複数指定で構文エラーの可能性	❌
umount /dev/sdb2 /data	同上	❌
```

⸻

💡 ポイント - デバイス名またはマウントポイントを個別に指定してアンマウントが安全 - umount -at xfs のようにファイルシステムタイプで一括処理も可能だが注意して使おう！

✅ 「アンマウントには /dev/sdb2, /data, -at xfs のいずれかを単独で指定！」

## `/etc/fstab` に記載されたファイルシステムをすべてマウントするコマンド

### **問題**

`/etc/fstab` ファイルに記載されている**すべてのファイルシステムをマウント**したい。  
適切な `mount` コマンドのオプションはどれか。

### **選択肢**

1. `-o`
2. `-a`
3. `-A`
4. `-ALL`
5. `-t`

---

### **正解**

✅ **`-a`**

---

### **解説**

#### ✅ `mount -a`

- **`/etc/fstab` に記載されたすべてのファイルシステムを一括でマウント**する。
- `noauto` オプションが指定されているものは除外される。
- 使用例：

```bash
sudo mount -a
```

    -	通常、起動時に行われる自動マウントと同じ動作を再現する。

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ -o - マウントオプション（rw, ro, noexec など）を指定するためのオプション。- 一括マウントの意味はない。

⸻

❌ -A - mount ではなく fsck コマンドで使用されるオプション（/etc/fstab 全体に対してファイルシステムチェックを実行）。

⸻

❌ -ALL - 無効なオプション。mount にそのような指定はない。

⸻

❌ -t - ファイルシステムの種類（ext4, xfs, vfat など）を指定するオプション。- 一括マウントではなく、タイプによるフィルタとして使う。

⸻

### まとめ

```
オプション	内容	一括マウントできるか	正解か
-a	/etc/fstab の記述に基づき全てマウント	✅	✅
-o	オプション指定（rw, roなど）	❌	❌
-A	fsck 用（fstabの全ファイルシステムチェック）	❌	❌
-ALL	存在しないオプション	❌	❌
-t	ファイルシステムタイプの指定	❌（一部対象）	❌
```

⸻

💡 ポイント - mount -a は /etc/fstab の設定に従って全てのファイルシステムをマウント！- noauto が付いているものはスキップされるので注意！

✅ 「fstab の内容を反映してマウントしたいなら mount -a！」

## デバイスの UUID を表示できるコマンド

### **問題**

デバイスの **UUID（Universal Unique Identifier）** を表示できるコマンドとして正しいものを **2つ選びなさい**。

### **選択肢**

1. `blkid`
2. `lsblk`
3. `showblk`
4. `ps`
5. `mount`

---

### **正解**

✅ **`blkid`**  
✅ **`lsblk`**

---

### **解説**

#### ✅ `blkid`

- デバイスの **UUID・LABEL・ファイルシステムの種類（TYPE）などを一覧表示**する。
- 出力例：

```bash
sudo blkid

/dev/sda1: UUID="3b80b96c-df15-401e-b74c-e8dcbfb68cec" TYPE="ext4"
/dev/sdb1: UUID="f8a9b29d-45d3-4924-a2f5-b4f0b0f0c15d" TYPE="xfs"
```

✅ UUID 表示可能！

⸻

✅ lsblk - デバイスの階層構造を表示するコマンド。- -o オプションで UUID を含めたカラム指定ができる。

```
lsblk -o NAME,UUID
```

✅ UUID 表示可能！

⸻

❌ 不正解の選択肢

❌ showblk - 存在しないコマンド。誤記。

⸻

❌ ps - プロセス一覧を表示するコマンド。- デバイス情報とは無関係。

⸻

❌ mount - マウントされたファイルシステムを表示するが、UUID は表示されない。

⸻

### まとめ

```
コマンド	UUID 表示	用途	正解か
blkid	✅	デバイスの UUID, TYPE などを表示	✅
lsblk	✅（-o指定）	デバイス構成と属性を表示（ツリー形式）	✅
showblk	❌（存在しない）	誤記	❌
ps	❌	プロセス表示	❌
mount	❌	マウント情報表示（UUIDは非表示）	❌
```

⸻

💡 ポイント - UUID の確認には blkid が王道！- lsblk -o NAME,UUID も視覚的に分かりやすくておすすめ！

✅ 「UUID を確認するなら blkid または lsblk -o NAME,UUID！」

## `/etc/fstab` に記述する SUID と SGID を有効化するマウントオプション

### **問題**

`/etc/fstab` に記述するマウントオプションで、  
**SUID（Set User ID）と SGID（Set Group ID）を有効化**するものはどれか。

### **選択肢**

1. `users`
2. `nouser`
3. `suid`
4. `exec`
5. `user`

---

### **正解**

✅ **`suid`**

---

### **解説**

#### ✅ `suid`

- **SUID（SetUID）と SGID（SetGID）を有効にするマウントオプション**。
- このオプションにより、SUID/SGID ビットが設定されたバイナリファイルは、その所有者またはグループの権限で実行されます。
- 通常はセキュリティの観点から無効にされていることもあります（特に removable メディアなどでは `nosuid` が使われる）。

##### `/etc/fstab` での例：

```fstab
/dev/sdb1  /mnt/usb  vfat  defaults,suid  0  0
```

✅ 正解！

⸻

❌ 他の選択肢の解説

❌ users - 一般ユーザがマウント/アンマウントできるようにするオプション。- SUID/SGID の有効化とは無関係。

⸻

❌ nouser - 一般ユーザがマウントできないようにするオプション（root のみ可能）。- SUIDとは関係なし。

⸻

❌ exec - バイナリ実行を許可するオプション。- スクリプトや実行ファイルの実行に関係しますが、SUID/SGID の有効化とは別です。

⸻

❌ user - users と似ているが、マウントしたユーザだけがアンマウントできるオプション。- SUID/SGID の設定には影響しません。

⸻

### まとめ

```
オプション	説明	SUID/SGID有効化	正解か
suid	SUID/SGIDを有効にする	✅	✅
users	一般ユーザのマウント許可	❌	❌
nouser	一般ユーザのマウント禁止（root のみ）	❌	❌
exec	実行可能ファイルの実行を許可	❌	❌
user	ユーザ自身がマウント・アンマウントできる	❌	❌
```

⸻

💡 ポイント - SUID/SGID を有効にしたい場合は suid オプションを使う - セキュリティ上の理由で removable メディアなどには nosuid が使われることも多い

✅ 「SUID/SGID を有効にするなら suid オプション！」

## `/etc/fstab` に記述するバイナリ実行を許可するマウントオプション

### **問題**

`/etc/fstab` に記述するマウントオプションで、  
**バイナリの実行を許可する**ものはどれか。

### **選択肢**

1. `auto`
2. `async`
3. `noauto`
4. `noexec`
5. `exec`

---

### **正解**

✅ **`exec`**

---

### **解説**

#### ✅ `exec`

- **ファイルシステム上のバイナリファイルの実行を許可するマウントオプション**。
- 通常は `defaults` に含まれるが、**USBメモリやCD-ROMなどの外部メディアではセキュリティ目的で `noexec` が使われる場合もある**。
- `exec` を明示すると、スクリプトやバイナリファイルがそのマウントポイント上で実行できるようになる。

##### `/etc/fstab` 例：

```fstab
/dev/sdb1  /mnt/usb  vfat  defaults,exec  0  0
```

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ auto - 起動時や mount -a 実行時に 自動的にマウントする オプション。- 実行可否とは無関係。

⸻

❌ async - データの読み書きを 非同期モードで処理。- 実行とは関係なし。

⸻

❌ noauto - 自動マウントをしない（手動でマウントが必要）。- auto の逆で、バイナリの実行とは関係なし。

⸻

❌ noexec - バイナリの実行を禁止するマウントオプション。- セキュリティ強化目的で使われる。

⸻

### まとめ

```
オプション	説明	バイナリ実行許可	正解か
exec	バイナリの実行を許可	✅	✅
auto	起動時の自動マウント	❌	❌
async	非同期 I/O モード	❌	❌
noauto	自動マウントを無効化	❌	❌
noexec	バイナリの実行を禁止	❌	❌
```

⸻

💡 ポイント - セキュリティ上の理由で /tmp や外部メディアには noexec が使われることが多い - 実行を許可したいなら exec、禁止したいなら noexec を使おう

✅ 「バイナリ実行を許可するには exec オプション！」

## systemd による手動マウント時の挙動

### **問題**

`/etc/fstab` に記載がなく、systemd にも認識されていないファイルシステムを  
**手動でマウントしたときの systemd の挙動**について正しいものを **2つ選びなさい**。

### **選択肢**

1. systemdは「/etc/fstab」に設定がないファイルシステムでも認識する
2. systemdが認識していないファイルシステムは、マウントユニットがないため、自動的にアンマウントされる
3. systemdは「/etc/fstab」に設定がないファイルシステムを認識せず、管理の対象外となる
4. systemdが認識していないファイルシステムは、マウントすることにより認識される

---

### **正解**

✅ **1. systemdは「/etc/fstab」に設定がないファイルシステムでも認識する**  
✅ **4. systemdが認識していないファイルシステムは、マウントすることにより認識される**

---

### **解説**

#### ✅ 1. systemdは「/etc/fstab」に設定がないファイルシステムでも認識する

- systemd は `/etc/fstab` に依存するだけでなく、**カーネルのマウント情報や `/proc/self/mountinfo` を監視**して、  
  **手動でマウントされたファイルシステムもリアルタイムで認識します**。
- そのため、`fstab` に記載されていなくても管理対象になります。

---

#### ✅ 4. systemdが認識していないファイルシステムは、マウントすることにより認識される

- **手動でマウントすると、systemd はそれを検知して管理対象に追加します**（`.mount` ユニットが動的に生成される）。
- これは `systemd` の内部的なマウント監視によるものです。

---

### ❌ 誤った選択肢

#### ❌ 2. マウントユニットがないと自動的にアンマウントされる

- **自動でアンマウントされることはありません**。  
  マウントユニットがなくても、マウント状態は保持されます。

---

#### ❌ 3. fstab に設定がないと systemd は管理しない

- **手動マウントでも systemd は動的に mount ユニットを生成して管理**します。

---

### **まとめ**

| 選択肢 | 内容                                     | 正誤 | 解説                                   |
| ------ | ---------------------------------------- | ---- | -------------------------------------- |
| 1      | fstab になくても systemd は認識する      | ✅   | カーネルやマウント状態を監視           |
| 2      | 認識されなければ自動でアンマウントされる | ❌   | 勝手にアンマウントはされない           |
| 3      | fstab にないと管理対象外                 | ❌   | 手動マウントでも systemd は管理する    |
| 4      | 手動マウントで認識されるようになる       | ✅   | mount により .mount ユニットが作られる |

---

💡 **ポイント**

- systemd は `/etc/fstab` だけでなく **動的にマウント状態を検出して管理**する。
- **`mount` コマンドでマウントされたポイントは自動的にユニットとして扱われる**。

✅ **「fstab に書かれていなくても、マウントすれば systemd は認識する！」**

## `/var/log` を `/root/systemlogs` にマウントするための適切なオプション

### **問題**

rootユーザでログイン後、すぐにログファイルのある `/var/log` にアクセスできるようにしたい。  
そのために、ログディレクトリ `/var/log` を `/root/systemlogs` にマウントしたい。

このとき使用すべき `mount` コマンドのオプションはどれか。

```bash
mount __________ /var/log /root/systemlogs
```

選択肢1. -t 2. --bind 3. -o 4. -a 5. --dir

⸻

### 正解

✅ --bind

⸻

解説

✅ --bind - mount --bind は、既存のディレクトリを別のパスに「もう一つの入り口」としてマウント（バインド）するオプション。- 実体は変わらず、同じ内容に別パスからアクセス可能になります。- 使用例：

mount --bind /var/log /root/systemlogs

    -	この状態では /root/systemlogs にアクセスすれば、実質 /var/log を参照できます。

✅ 正解！

⸻

❌ その他の選択肢の解説

❌ -t - ファイルシステムの種類を指定するオプション（例: -t ext4）。- バインドマウントには使用しません。

⸻

❌ -o - 追加オプションを指定する際に使う（例: -o ro）。- バインドマウントに使うには -o bind とすべきだが、通常は --bind の方が明示的でわかりやすい。

⸻

❌ -a - /etc/fstab に記載されたすべてのファイルシステムをマウントするオプション。- 手動でのバインドマウントには関係ない。

⸻

❌ --dir - 無効なオプション。mount コマンドには --dir は存在しません。

⸻

### まとめ

```
オプション	説明	バインドに適切か	正解か
--bind	ディレクトリの内容を他のパスにマウント	✅	✅
-t	ファイルシステムの種類を指定	❌	❌
-o	その他のマウントオプションを指定	△（-o bindも可能）	❌
-a	/etc/fstab 全体をマウント	❌	❌
--dir	存在しないオプション	❌	❌
```

⸻

💡 ポイント - --bind で任意のディレクトリを別名アクセスできるようにする！- ログディレクトリの別パスへのマウントにも便利

✅ 「mount --bind /var/log /root/systemlogs でログにすぐアクセスできるようにしよう！」

## `/etc/fstab` による ext3 ファイルシステムの自動マウント設定

### **問題**

ext3 ファイルシステムの `/dev/sda1` を、**システム起動時に `/boot` に自動マウント**するように、  
`/etc/fstab` に記述したい。  
適切な記述はどれか（**全て選択**）。

### **選択肢**

1. `/dev/sda1 /boot ext3 defaults 1 1`
2. `/dev/sda1 /boot ext3 auto 1 1`
3. `/boot /dev/sda1 ext3 auto 1 1`
4. `/boot /dev/sda1 ext3 defaults 1 1`
5. `/dev/sda1 /boot ext3 noauto 1 1`

---

### **正解**

✅ **`/dev/sda1 /boot ext3 defaults 1 1`**  
✅ **`/dev/sda1 /boot ext3 auto 1 1`**

---

### **解説**

#### `/etc/fstab` のフィールド構成

| 項目番号 | 意味                        | 例                       |
| -------- | --------------------------- | ------------------------ |
| 1        | デバイスファイル            | `/dev/sda1`              |
| 2        | マウントポイント            | `/boot`                  |
| 3        | ファイルシステムの種類      | `ext3`                   |
| 4        | マウントオプション          | `defaults` または `auto` |
| 5        | `dump` 実行対象か（通常 0） | `1` or `0`               |
| 6        | `fsck` 実行の優先順位       | `1`（ルート）、`2`（他） |

---

### ✅ 正しい記述の理由

#### ✅ `/dev/sda1 /boot ext3 defaults 1 1`

- 一般的な形式で、**標準オプション（rw, suid, dev, exec, auto, nouser, async）**が適用される。
- 起動時に `/boot` に自動マウントされる。

#### ✅ `/dev/sda1 /boot ext3 auto 1 1`

- `auto` により、**起動時や `mount -a` 時にマウントされる**。
- 他のデフォルトオプションがない場合でも、明示的な自動マウントを指定できる。

---

### ❌ 誤った記述

#### ❌ `/boot /dev/sda1 ...`

- **フィールドの順序が間違っている**（マウントポイントとデバイス名が逆）。

#### ❌ `/dev/sda1 /boot ext3 noauto 1 1`

- `noauto` により、**起動時に自動マウントされない**ため不正解。

---

### **まとめ**

| 記述                                | 起動時に自動マウント            | フィールド順正しい | 正解か |
| ----------------------------------- | ------------------------------- | ------------------ | ------ |
| `/dev/sda1 /boot ext3 defaults 1 1` | ✅                              | ✅                 | ✅     |
| `/dev/sda1 /boot ext3 auto 1 1`     | ✅                              | ✅                 | ✅     |
| `/boot /dev/sda1 ext3 auto 1 1`     | ❌（順序誤り）                  | ❌                 | ❌     |
| `/boot /dev/sda1 ext3 defaults 1 1` | ❌（順序誤り）                  | ❌                 | ❌     |
| `/dev/sda1 /boot ext3 noauto 1 1`   | ❌（noauto = 自動マウントなし） | ✅                 | ❌     |

---

💡 **ポイント**

- **`defaults` か `auto` を使えば起動時マウント可能**
- **フィールドの順番（デバイス名 → マウントポイント）を守ることが重要**

✅ **「自動マウントしたいなら `/dev/sda1 /boot ext3 defaults 1 1` のように書こう！」**

## `/dev/hdc` を `/mnt/cdrom` にマウントするための適切なコマンド

### **問題**

CD-ROM ドライブが `/dev/hdc` として認識されており、  
それを `/mnt/cdrom` にマウントしたい。  
このエントリは **すでに `/etc/fstab` に追加済み**である。  
このとき、適切なマウントコマンドはどれか（**全て選択**）。

### **選択肢**

1. `mount`
2. `mount /mnt/cdrom`
3. `mount -t iso9660 /dev/hdc /mnt/cdrom`
4. `mount /dev/hdc`
5. `mount /mnt/cdrom /dev/hdc`

---

### **正解**

✅ **`mount -t iso9660 /dev/hdc /mnt/cdrom`**  
✅ **`mount /mnt/cdrom`**  
✅ **`mount /dev/hdc`**

---

### **解説**

#### ✅ `mount /mnt/cdrom`

- **`/etc/fstab` に該当エントリがある場合**、  
  マウントポイントを指定するだけでマウント可能。
- fstab の内容（デバイス名、ファイルシステムタイプなど）を使用してマウントされる。

---

#### ✅ `mount /dev/hdc`

- `/etc/fstab` に `/dev/hdc` のエントリがあれば、  
  その内容に基づいて適切なマウントポイント（例: `/mnt/cdrom`）にマウントされる。

---

#### ✅ `mount -t iso9660 /dev/hdc /mnt/cdrom`

- fstab に頼らず、**明示的にファイルシステムタイプとパスを指定してマウント**する方法。
- CD-ROM は通常 `iso9660` 形式のため、これが正しい指定。

---

### ❌ 誤りの選択肢

#### ❌ `mount`

- 引数なしでは単にマウント済みのファイルシステム一覧を表示するだけで、**マウント処理は実行されない**。

---

#### ❌ `mount /mnt/cdrom /dev/hdc`

- **順番が不正**。  
  正しい構文は `mount <デバイス> <マウントポイント>`  
  → `/dev/hdc` が先、`/mnt/cdrom` が後。

---

### **まとめ**

| コマンド                               | 説明                                   | 正解か |
| -------------------------------------- | -------------------------------------- | ------ |
| `mount`                                | 引数なし → マウント済みリストを表示    | ❌     |
| `mount /mnt/cdrom`                     | fstab を使ってマウント                 | ✅     |
| `mount -t iso9660 /dev/hdc /mnt/cdrom` | タイプ・パスを明示してマウント         | ✅     |
| `mount /dev/hdc`                       | fstab を使ってマウント（デバイス指定） | ✅     |
| `mount /mnt/cdrom /dev/hdc`            | **順番が逆** → 構文エラー              | ❌     |

---

💡 **ポイント**

- `/etc/fstab` にエントリがあれば、**どちらのパス（デバイス or マウントポイント）でもマウント可能**
- 明示的にマウントしたいなら `mount -t iso9660 /dev/hdc /mnt/cdrom`

✅ **「CD-ROM をマウントするなら `/mnt/cdrom` か `/dev/hdc` でOK！ `fstab` が設定されていれば簡単！」**

## 現在マウントされているファイルシステム情報が格納されているファイル

### **問題**

**現在マウントされているファイルシステムの情報**が格納されているファイルはどれか。

### **選択肢**

1. `/etc/self`
2. `/proc/mount/tab`
3. `/etc/fstab`
4. `/proc/mounts`

---

### **正解**

✅ **`/proc/mounts`**

---

### **解説**

#### ✅ `/proc/mounts`

- **現在カーネルによってマウントされているすべてのファイルシステムの一覧を表示**する仮想ファイル。
- 実際には `/proc` は仮想ファイルシステムで、`/proc/mounts` はリアルタイムなマウント情報を提供する。
- `mount` コマンドもこのファイルを参照している場合がある。

##### 内容の確認例：

```bash
cat /proc/mounts
```

✅ 正解！

⸻

❌ 不正解の選択肢の解説

❌ /etc/self - 存在しないパス。無効なファイル名。

⸻

❌ /proc/mount/tab - 存在しない仮想ファイル。正しくは /proc/mounts。

⸻

❌ /etc/fstab - 起動時や mount -a 実行時に使われる「マウント予定の定義ファイル」。- 現在のマウント状態ではなく、設定情報を持つファイル。

⸻

### まとめ

```
ファイルパス	内容	現在のマウント状態	正解か
/proc/mounts	現在マウントされている情報をカーネルから取得	✅	✅
/etc/fstab	マウントの設定定義（未来の予定）	❌	❌
/proc/mount/tab	存在しない仮想ファイル	❌	❌
/etc/self	存在しないディレクトリ	❌	❌
```

⸻

💡 ポイント - 「今」マウントされている状態を知りたいなら /proc/mounts を見よ！- cat /proc/mounts や mount コマンドで同じ情報を確認できる。

✅ 「現在のマウント情報は /proc/mounts にある！」

## 一般ユーザが USB メモリをマウントできるようにするための事前準備

### **問題**

Linux上で、一般ユーザが以下のように USB メモリをマウントしたい：

```bash
mount /mnt/usb
```

この操作を 一般ユーザが可能にするために、rootユーザとして事前に行うべき作業はどれか（2つ選択）。

選択肢 1. /etc/fstab ファイルに USB メモリのマウント設定を記述する 2. 特に事前の作業は必要ない 3. 一般ユーザでは USB メモリをマウントできない 4. USB メモリの UUID を確認し、マウント設定のデバイス名に記述する 5. USB メモリのデバイスファイルを確認し、マウント設定のデバイス名に記述する

⸻

### 正解

✅ 1. /etc/fstab ファイルに USB メモリのマウント設定を記述する
✅ 4. USB メモリの UUID を確認し、マウント設定のデバイス名に記述する

⸻

### 解説

✅ /etc/fstab にマウント設定を追加 - 一般ユーザが mount /mnt/usb を使えるようにするには、あらかじめ root が /etc/fstab に設定を記述しておく必要があります。- また、マウントオプションに user または users を指定することで、一般ユーザのマウントが許可されます。

例：

```
UUID=xxxx-xxxx  /mnt/usb  vfat  noauto,user  0  0
```

⸻

✅ UUID を使ってデバイスを正確に指定 - USB メモリは接続するたびに /dev/sdX が変わる可能性があるため、UUID を使ってデバイスを特定するのが安全。- UUID は blkid コマンドで確認可能：

sudo blkid

⸻

❌ 誤った選択肢

❌ 2. 特に事前の作業は必要ない - デフォルトでは、一般ユーザが mount コマンドを使うには権限が足りません。
/etc/fstab での設定が必要です。

⸻

❌ 3. 一般ユーザでは USB メモリをマウントできない - 適切に設定すれば 一般ユーザでもマウントは可能です。

⸻

❌ 5. デバイスファイルを直接指定するだけでは不十分 - /dev/sdX は再起動や再接続で変わる可能性があるため、UUID の方が信頼性が高い。

⸻

### まとめ

```
選択肢	内容	正誤	理由
/etc/fstab に記述する	✅	一般ユーザがマウント可能にするには必要
事前作業は不要	❌	権限エラーになる
一般ユーザはマウント不可	❌	正しく設定すれば可能
UUID を指定する	✅	再接続しても安定して識別できる
デバイス名だけ指定	❌	/dev/sdX は変更される可能性がある
```

⸻

💡 ポイント - fstab に user と noauto を指定することで、一般ユーザが明示的にマウントできるようになる - UUID を使うことで信頼性のあるマウント設定が可能

✅ 「fstab に UUID を使って記述＋user オプションを付けると一般ユーザでもマウントOK！」

## `/etc/fstab` 各項目の正しい説明

### **問題**

以下は `/etc/fstab` の内容に関する設問である。  
**各項目 (1)〜(6) の説明がすべて正しい選択肢はどれか。**

---

### **正解**

✅ **(1) デバイス名 (2) マウントポイント (3) ファイルシステムの種類 (4) マウントオプション (5) dumpフラグ (6) fsckフラグ**

---

### **解説**

#### ✅ `/etc/fstab` の各フィールドの正式な順序と説明

| フィールド番号             | 説明                                          | 例                                      |
| -------------------------- | --------------------------------------------- | --------------------------------------- |
| (1) デバイス名             | マウントするデバイスのパスまたはUUID、LABEL   | `/dev/sda1`, `UUID=xxxx`, `LABEL=home`  |
| (2) マウントポイント       | デバイスをマウントするディレクトリ            | `/`, `/boot`, `/mnt/usb`                |
| (3) ファイルシステムの種類 | 使用するファイルシステムタイプ                | `ext4`, `xfs`, `vfat`, `swap`           |
| (4) マウントオプション     | `defaults`, `noauto`, `ro`, `user` など       | `defaults`, `noexec`, `user`, etc.      |
| (5) dumpフラグ             | `dump` コマンドでバックアップするか（通常 0） | `0` or `1`                              |
| (6) fsckフラグ             | `fsck` による整合性チェックの順序             | `0`（無効）、`1`（優先）、`2`（後回し） |

---

### ❌ その他の選択肢の誤り

| 選択肢                                  | 誤っている部分                         |
| --------------------------------------- | -------------------------------------- |
| (1) マウントポイント (2) デバイス名 ... | **フィールド順が逆**                   |
| (3) マウントオプションが先に来ている    | 正しくは「ファイルシステムの種類」が先 |
| (5) fsckフラグが5番目になっている       | 正しくは6番目                          |

---

### **例：正しい `/etc/fstab` の1行**

```fstab
/dev/sda1  /boot  ext3  defaults  1  2
```

```
フィールド	値	意味
(1)	/dev/sda1	デバイス名
(2)	/boot	マウントポイント
(3)	ext3	ファイルシステムの種類
(4)	defaults	マウントオプション
(5)	1	dumpの対象（1=対象, 0=無視）
(6)	2	fsck実行順（1=ルート優先, 2=他）
```

⸻

💡 ポイント - /etc/fstab のフィールド順は固定 → 覚えておくとトラブル時に便利！- fsck の順序により、起動時のファイルシステムチェックの順番が決まる

✅ 「fstab の6項目は：デバイス名 / マウントポイント / FSタイプ / オプション / dump / fsck」！
