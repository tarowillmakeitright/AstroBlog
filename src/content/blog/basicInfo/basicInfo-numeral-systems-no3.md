---
author: Taro Gray
pubDatetime: 2024-06-30T15:30:00.000Z
title: 2進数・10進数・16進数の変換と計算方法 Part 3
postSlug: basicInfo-numeral-systems-no3
featured: true
ogImage: https://github.com/satnaing/astro-paper/assets/53733092/1ef0cf03-8137-4d67-ac81-84a032119e3a
tags:
  - binary
  - decimal
  - hexadecimal
  - numeral-systems
description: 2進数、10進数、16進数の変換と基本的な計算方法についての解説
---

## Table of contents

## 2の補数の計算方法

2の補数を求める手順は次の通りです。

1. 数字をビットごとに反転させる（0を1に、1を0に）。
2. その結果に1を加える。

#### 問題

3ビットの2進数 `010` を2の補数に変換せよ。

#### 解答

1. ビットごとに反転させます。

   ```
   010 → 101
   ```

2. その結果に1を加えます。
   ```
   101 + 1 = 110
   ```

したがって、3ビットの2進数 `010` の2の補数は `110` です。

## 2の補数の計算方法

2の補数を求める手順は次の通りです。

1. 数字をビットごとに反転させる（0を1に、1を0に）。
2. その結果に1を加える。

#### 問題

5ビットの2進数 `11111` を2の補数に変換せよ。

#### 解答

1. ビットごとに反転させます。

   ```
   11111 → 00000
   ```

2. その結果に1を加えます。
   ```
   00000 + 1 = 00001
   ```

したがって、5ビットの2進数 `11111` の2の補数は `00001` です。

## 2進数を10進数に変換する方法（2の補数表記を使用）

#### 問題

2進数「10000000」を10進数に変換せよ。ただし2の補数表記を用いている。

#### 手順

1. 2の補数表記では、最上位ビット（左端のビット）が1の場合、その数は負の値を表します。

2. 数を反転させて2の補数を取り、絶対値を求めます。

   ```
   10000000 → 01111111
   ```

3. 結果に1を加えます。

   ```
   01111111 + 1 = 10000000
   ```

4. 絶対値を計算します。

   ```
   01111111 (2進数) = 127 (10進数)
   ```

5. 符号を考慮して結果をマイナスにします。
   ```
   -127 - 1 = -128
   ```

したがって、2進数「10000000」を10進数に変換すると、「-128」になります。

## 多くのコンピュータが，演算回路を簡単にするために補数を用いている理由はどれか。

```
多くのコンピュータが演算回路を簡単にするために補数を用いる理由は、減算を加算に変換できるからです。2の補数を用いることで、減算を行う際に減数の2の補数を加えるだけで良くなります。この方法により、専用の減算回路を用意する必要がなくなり、加算回路だけで済むため、演算回路が簡素化され、設計や製造のコストが削減されます。
```

## 2の補数で表された負数の絶対値を求める方法

#### 問題

2の補数で表された負数 `10101110` の絶対値を求めよ。

#### 手順

1. 数字をビットごとに反転させる（0を1に、1を0に）。

   ```
   10101110 → 01010001
   ```

2. その結果に1を加える。

   ```
   01010001 + 1 = 01010010
   ```

3. 絶対値を計算する。
   ```
   01010010 (2進数) = 1 * 2^6 + 0 * 2^5 + 1 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0
                    = 64 + 16 + 2
                    = 82
   ```

したがって、2の補数で表された負数 `10101110` の絶対値は `82` です。

## 問題

負数を2の補数で表す8ビットの数値がある。この値を10進数で表現すると-100である。この値を符号なしの数値として解釈すると，10進数でいくらか。

### 手順

1. 負の数 `-100` を2の補数で表す8ビットの数値に変換します。

2. 正の数 `100` を2進数で表します。

   ```
   100 (10進数) = 01100100 (2進数)
   ```

3. この2進数をビットごとに反転させます。

   ```
   01100100 → 10011011
   ```

4. 反転した値に1を加えて2の補数を求めます。
   ```
   10011011 + 1 = 10011100
   ```

この結果、-100を2の補数で表すと `10011100` です。

次に、符号なしの数値として解釈します。

### 解答

2進数 `10011100` を符号なしの数値として解釈すると、次のように計算します。

```
1 * 2^7 + 0 * 2^6 + 0 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0
= 128 + 0 + 0 + 16 + 8 + 4 + 0 + 0
= 156
```

したがって、符号なしの数値として解釈すると `156` です。

## 負の整数を表現する代表的な方法

- **a** 1の補数による表現
- **b** 2の補数による表現
- **c** 絶対値に符号を付けた表現（左端ビットが0の場合は正、1の場合は負）

4ビットのパターン「1101」をa～cの方法で表現したものを解釈したとき、値が小さい順に並べます。

#### 各表現方法での値

- **a** 1の補数: -2 (負)
- **b** 2の補数: -3 (負)
- **c** 符号付き絶対値: -5 (負)

したがって、値が小さい順に並べると次のようになります。

### 答え

```
エ c, b, a
```

### 負の整数を表現する代表的な方法と計算方法

- **a** 1の補数による表現
- **b** 2の補数による表現
- **c** 絶対値に符号を付けた表現（左端ビットが0の場合は正、1の場合は負）

4ビットのパターン「1101」をa～cの方法で表現したものを解釈します。

### 計算方法

#### a. 1の補数による表現

1の補数は、ビットを反転させたものです。

```
1101 → 0010
```

これは `-2` です。

#### b. 2の補数による表現

2の補数は、1の補数に1を加えたものです。

```
1101 → 0010 (1の補数)
0010 + 1 = 0011
```

これは `-3` です。

#### c. 絶対値に符号を付けた表現

最上位ビットが1なので、符号は負です。

```
1101 → - (101) = -5
```

### 結論

4ビットのパターン「1101」を小さい順に並べると、次のようになります。

```
エ. c, b, a
```

これで、cは-5、bは-3、aは-2となり、最小から最大の順に並んでいます。

## 2の補数による8桁の2進数で表現できる数値の範囲

2の補数を用いると、8桁の2進数で表現できる範囲は次の通りです。

#### 計算手順

1. 8ビットの2進数は、最上位ビットが符号ビットとなります。
2. 符号ビットが0の場合、数値は正の値を表します。
3. 符号ビットが1の場合、数値は負の値を表します。

### 正の範囲

符号ビットが0の場合、残りの7ビットで数値を表現します。

```
最大値: 01111111 (2進数) = 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0 = 127 (10進数)
```

### 負の範囲

符号ビットが1の場合、最小値は次の通りです。

```
最小値: 10000000 (2進数) = -2^7 = -128 (10進数)
```

したがって、2の補数で表現できる8桁の2進数の範囲は、10進数で表すと `-128` から `127` です。

## 3ビットの2進数「111」を左に2ビット論理シフト

論理シフトは、数値をシフトし、右側に空いたビットを0で埋める操作です。

#### 問題

3ビットの2進数「111」を左に2ビット論理シフトした結果を求めよ。

#### 手順

1. 「111」を左に2ビットシフトします。
   ```
   111 (2進数) を左に2ビットシフト
   ```
2. 右側に2ビットの0が追加されますが、3ビット目までの部分を取ります。
   ```
   11100 → 100
   ```

#### 結果

3ビットの2進数「111」を左に2ビット論理シフトした結果は「100」です。

## 4ビットの2進数「0111」を右に1ビット論理シフト

論理シフトは、数値をそのままシフトし、左側に空いたビットを0で埋める操作です。

#### 問題

4ビットの2進数「0111」を右に1ビット論理シフトした結果を求め、10進数で答えよ。

#### 手順

1. 「0111」を右に1ビットシフトします。
   ```
   0111 (2進数) を右に1ビットシフト
   ```
2. 左側に1ビットの0が追加されます。

   ```
   0111 → 0011
   ```

3. 結果を10進数に変換します。
   ```
   0011 (2進数) = 0*2^3 + 0*2^2 + 1*2^1 + 1*2^0
                = 0 + 0 + 2 + 1
                = 3
   ```

#### 結果

4ビットの2進数「0111」を右に1ビット論理シフトした結果は10進数で「3」です。

## 数値を10倍する操作を2進数で行うためには

シフト操作と加算操作を組み合わせます。具体的には、2進数で10は`1010`なので、数値を左に3ビットシフトして8倍し、さらに元の数値を左に1ビットシフトして2倍したものを加算します。

### 手順

```
1. 数値 ( x ) を1ビット左シフトして2倍します。
2. 数値 ( x ) を3ビット左シフトして8倍します。
3. これらの結果を加算します。
```

#### 例

```
数値 ( x ) を10倍する場合：
[ x times 10 = (x times 8) + (x times 2) ]
```

### 具体的な操作

```
1. ( x ) を3ビット左シフトする： ( x << 3 )
2. ( x ) を1ビット左シフトする： ( x << 1 )
3. これらを加算する： ( (x << 3) + (x << 1) )
```

## 問題の整理

8ビットの2進数 `11010000` を右に2ビット算術シフトしたものを、`00010100` から減じた値を求めます。負の数は2の補数表現によるものとします。

### 手順

1. **右に2ビット算術シフト**

   - 算術シフトでは、符号ビット（最上位ビット）を保持します。
   - `11010000` を右に2ビット算術シフトすると：
     ```
     11010000 → 11110100
     ```

2. **2進数を10進数に変換**

   - `11110100` は2の補数表現です。
     1. ビットを反転：
        ```
        11110100 → 00001011
        ```
     2. 1を加える：
        ```
        00001011 + 1 = 00001100
        ```
     - したがって、絶対値は `12` で、負の数なので `-12` です。

3. **減算**
   - `00010100` は10進数で `20` です。
   - `20 - (-12)` の計算：
     ```
     20 + 12 = 32
     ```

### 結果

8ビットの2進数 `11010000` を右に2ビット算術シフトしたものを `00010100` から減じた値は `32` です。

## 問題の整理

8ビットの2進数 `11010000` を右に2ビット算術シフトしたものを、`00010100` から減じた値を求めます。負の数は2の補数表現によるものとします。

### 手順

1. **右に2ビット算術シフト**

   - 算術シフトでは、符号ビット（最上位ビット）を保持します。
   - `11010000` を右に2ビット算術シフトすると：
     ```
     11010000 → 11110100
     ```

2. **2進数を10進数に変換**

   - `11110100` は2の補数表現です。
     1. ビットを反転：
        ```
        11110100 → 00001011
        ```
     2. 1を加える：
        ```
        00001011 + 1 = 00001100
        ```
     - したがって、絶対値は `12` で、負の数なので `-12` です。

3. **減算**
   - `00010100` は10進数で `20` です。
   - `20 - (-12)` の計算：
     ```
     20 + 12 = 32
     ```

### 結果

8ビットの2進数 `11010000` を右に2ビット算術シフトしたものを `00010100` から減じた値は `32` です。

## 数値を2進数で格納するレジスタがある。このレジスタに正の整数xを設定した後，"レジスタの値を2ビット左にシフトして，xを加える"操作を行うと，レジスタの値はxの何倍になるか。ここで，あふれ(オーバフロー)は，発生しないものとする。

### 手順

1. 数値 ( x ) をレジスタに設定します。
2. レジスタの値を2ビット左にシフトします（これにより ( x times 4 ) となります）。
3. その結果に元の数値 ( x ) を加えます。

### 具体的な操作

```
1. ( x ) を2ビット左シフトする： ( x << 2 )
2. その結果に ( x ) を加える： ( (x << 2) + x )
```

### 計算

左に2ビットシフトすると、数値は4倍になります。そこに元の数値を加えるので：

```
[
(x << 2) + x = 4x + x = 5x
]
```

### 結論

したがって、この操作を行うと、レジスタの値は \( x \) の5倍になります。

## 32ビットのレジスタに16進数ABCDが入っているとき，2ビットだけ右に論理シフトしたときの値はどれか。

### 16進数ABCDを2ビット右に論理シフトする

1. **16進数を2進数に変換**

   - `ABCD` の16進数は2進数で表すと次のようになります：
     ```
     A = 1010
     B = 1011
     C = 1100
     D = 1101
     ```
   - したがって、32ビットの2進数表記は：
     ```
     ABCD = 1010 1011 1100 1101
     ```

2. **2ビット右に論理シフト**

   - 2ビット右に論理シフトすると、左側に2ビットの `0` が追加され、右側の2ビットが切り捨てられます：
     ```
     1010 1011 1100 1101 → 0010 1010 1111 0011
     ```

3. **シフト後の値を16進数に変換**
   - `0010 1010 1111 0011` を16進数に変換すると：
     ```
     0010 = 2
     1010 = A
     1111 = F
     0011 = 3
     ```
   - したがって、2ビット右に論理シフトした後の値は `2AF3` です。

### 結果

32ビットのレジスタに16進数 `ABCD` が入っているとき、2ビット右に論理シフトした値は `2AF3` です。
2ビット右に論理シフトする手順は次の通りです。

### 手順

1. 16進数 `ABCD` を2進数に変換します。
2. 2ビット右に論理シフトします。
3. シフト後の値を16進数に変換します。

### 具体的な計算

1. **16進数 `ABCD` を2進数に変換**

   - `A = 1010`
   - `B = 1011`
   - `C = 1100`
   - `D = 1101`
   - 32ビットで表すと：
     ```
     0000 0000 0000 0000 1010 1011 1100 1101
     ```

2. **2ビット右に論理シフト**

   - 右に2ビットシフトすると：
     ```
     0000 0000 0000 0000 0010 1010 1111 0011
     ```

3. **シフト後の値を16進数に変換**
   - `0010 = 2`
   - `1010 = A`
   - `1111 = F`
   - `0011 = 3`
   - したがって、2ビット右に論理シフトした後の値は `002AF3` です。

### 結果

32ビットのレジスタに16進数 `ABCD` が入っているとき、2ビット右に論理シフトした値は `002AF3` です。

### 問題の整理

10進数 `-5.625` を、8ビット固定小数点形式による2進数で表します。小数点位置は3ビット目と4ビット目の間にあり、負数には2の補数表現を用います。

### 手順

1. 10進数 `-5.625` を2進数に変換する。
2. 変換した2進数を8ビットの2の補数表現で表す。

#### 1. 10進数 `-5.625` を2進数に変換

- 5を2進数に変換すると `101`。
- 0.625を2進数に変換すると：

  ```
  0.625 * 2 = 1.25 → 1
  0.25 * 2 = 0.5 → 0
  0.5 * 2 = 1.0 → 1
  ```

  したがって、0.625は `0.101`。

- よって、5.625は `101.101`。

#### 2. 2の補数表現に変換

- 正の数5.625は `000101.101` ですが、8ビットの表現では `01011010` となります。
- 負の数の2の補数を求めるために、まずビット反転：
  ```
  01011010 → 10100101
  ```
- 反転後に1を加える：
  ```
  10100101 + 1 = 10100110
  ```

### 結論

10進数 `-5.625` を8ビット固定小数点形式で表すと `10100110` です。よって、選択肢の中では **ウ. 10100110** が正しい答えです。

## 数値を浮動小数点表示で表現する場合、仮数部の最上位桁が0以外にな るように、桁合わせする操作はどれか。ここで、仮数部の表現方法は、絶対値表現とする。

ア切上げ
イ切捨て
ウ桁上げ
エ正規化
浮動小数点数を表現する場合、仮数部の最上位桁が0以外になるように桁合わせする操作は「正規化」です。

### 正規化の説明

正規化は、浮動小数点数の仮数部を調整し、最上位桁が0以外になるようにする操作です。これにより、数値の精度を最大限に活用し、一意の表現が保証されます。

したがって、問20に対する答えは **エ. 正規化** です。

### 実数 \( a \) を \( a = f \times r^e \) と表す浮動小数点表示に関する記述として、適切なものはどれか。

### 選択肢

ア. \( f \) を仮数、\( e \) を指数、\( r \) を基数という。  
イ. \( f \) を基数、\( e \) を仮数、\( r \) を指数という。  
ウ. \( f \) を基数、\( e \) を指数、\( r \) を仮数という。  
エ. \( f \) を指数、\( e \) を基数、\( r \) を仮数という。

### 解答

正しい記述は **ア** です。

### 解説

浮動小数点表示において、実数 \( a \) を \( a = f \times r^e \) と表現する場合、次のように定義します：

- \( f \): 仮数
- \( r \): 基数
- \( e \): 指数

したがって、適切な記述は **ア** の「\( f \) を仮数、\( e \) を指数、\( r \) を基数という。」です。

## 16ビットの浮動小数点形式において、10進数 `0.25` を正規化した表現を求めます。ここで、正規化は仮数部の最上位桁が `1` になるように指数部と仮数部を調節する操作とします。

#### 表示形式

- `s`: 仮数部の符号（0：正、1：負）
- `e`: 指数部（2を基数とし、負数は2の補数で表現）
- `f`: 仮数部（符号なし2進数）

### 解答手順

1. **数値の2進数表現**：

   - `0.25` は2進数で `0.01` です。

2. **正規化**：

   - `0.01` を正規化すると `1.0 × 2^{-2}` です。

3. **符号、指数、仮数の設定**：
   - 符号部 `s` は `0`（正の数）
   - 指数部 `e` は `-2` を4ビットの2の補数で表現すると `1110`
   - 仮数部 `f` は `1.0` の小数点以下の部分で `00000000000`

### 結果

したがって、10進数 `0.25` を正規化した2進数の表現は `0111100000000000` です。これに最も近い選択肢は **ウ. 0111100000000000** です。
